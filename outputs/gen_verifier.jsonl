{"scenario": "surveymonkey_apply", "task_idx": 0, "task": "Create a new program named \"STEM Scholars Grant\" with the description \"Supports undergraduate research projects in STEM fields\" and set the default time zone to \"America/New_York\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Target values\n    target_name = 'STEM Scholars Grant'\n    target_desc = 'Supports undergraduate research projects in STEM fields'\n    target_tz = 'America/New_York'\n    \n    # Query 'programs' in initial and final db\n    init_matches = safe_query(\n        initial_db_path,\n        \"SELECT id FROM programs WHERE name = ? AND description = ? AND default_time_zone = ?\",\n        (target_name, target_desc, target_tz),\n    )\n    final_matches = safe_query(\n        final_db_path,\n        \"SELECT id FROM programs WHERE name = ? AND description = ? AND default_time_zone = ?\",\n        (target_name, target_desc, target_tz),\n    )\n    \n    # Check existence and creation\n    if len(init_matches) == 0 and len(final_matches) > 0:\n        # Defensive: check record fields in final DB for exact match\n        final_record_check = safe_query(\n            final_db_path,\n            \"SELECT name, description, default_time_zone FROM programs WHERE name = ?\",\n            (target_name,)\n        )\n        \n        # All returned records must have exact values\n        for rec in final_record_check:\n            if rec[0] != target_name or rec[1] != target_desc or rec[2] != target_tz:\n                return {\"result\": \"others\"}\n        return {\"result\": \"complete\"}\n    else:\n        return {\"result\": \"others\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure a new program named 'STEM Scholars Grant' was created, its description is 'Supports undergraduate research projects in STEM fields', and its default time zone is 'America/New_York'. We must check that this record did not previously exist in the initial database, and is present in the final database with the exact requested values. No cycles, forms, submissions, or related objects are required for this specific task: only the program record itself. Edge cases include partial creations, incorrect naming, description or time zone, or accidental updates to existing records instead of creation.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"The programs table in the final database contains at least one record with name = 'STEM Scholars Grant', description = 'Supports undergraduate research projects in STEM fields', and default_time_zone = 'America/New_York'\",\n        \"The programs table in the initial database does NOT contain such a record\",\n        \"No error or malformed data (e.g., blank strings, partial matches)\",\n        \"Defensive: if multiple matching records, only accept if all fields match exactly\",\n        \"Defensive: description and name require exact case-sensitive match\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Target values\\n    target_name = 'STEM Scholars Grant'\\n    target_desc = 'Supports undergraduate research projects in STEM fields'\\n    target_tz = 'America/New_York'\\n    \\n    # Query 'programs' in initial and final db\\n    init_matches = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM programs WHERE name = ? AND description = ? AND default_time_zone = ?\\\",\\n        (target_name, target_desc, target_tz),\\n    )\\n    final_matches = safe_query(\\n        final_db_path,\\n        \\\"SELECT id FROM programs WHERE name = ? AND description = ? AND default_time_zone = ?\\\",\\n        (target_name, target_desc, target_tz),\\n    )\\n    \\n    # Check existence and creation\\n    if len(init_matches) == 0 and len(final_matches) > 0:\\n        # Defensive: check record fields in final DB for exact match\\n        final_record_check = safe_query(\\n            final_db_path,\\n            \\\"SELECT name, description, default_time_zone FROM programs WHERE name = ?\\\",\\n            (target_name,)\\n        )\\n        \\n        # All returned records must have exact values\\n        for rec in final_record_check:\\n            if rec[0] != target_name or rec[1] != target_desc or rec[2] != target_tz:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    else:\\n        return {\\\"result\\\": \\\"others\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 1, "task": "Create an application cycle for the program \"STEM Scholars Grant\" named \"Fall 2026\" with open date \"2026-08-01T09:00:00-04:00\" and deadline \"2026-10-01T17:00:00-04:00\" and enable late submissions until \"2026-10-08T17:00:00-04:00\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper for read-only query\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # 1. Find the program_id for 'STEM Scholars Grant' in BOTH dbs (should be the same)\n    prog_q = \"SELECT id FROM programs WHERE name = ?\"\n    initial_prog = safe_query(initial_db_path, prog_q, ('STEM Scholars Grant',))\n    final_prog = safe_query(final_db_path, prog_q, ('STEM Scholars Grant',))\n    if not final_prog or len(final_prog[0]) != 1:\n        return {\"result\": \"others\"}\n    program_id = final_prog[0][0]\n    if not isinstance(program_id, int):\n        return {\"result\": \"others\"}\n    # 2. Try to find the target cycle in the FINAL db\n    cycle_values = {\n        'program_id': program_id,\n        'name': 'Fall 2026',\n        'open_at': '2026-08-01T09:00:00-04:00',\n        'deadline_at': '2026-10-01T17:00:00-04:00',\n        'late_until_at': '2026-10-08T17:00:00-04:00',\n    }\n    cyq = \"\"\"\n        SELECT id, program_id, name, open_at, deadline_at, late_until_at FROM cycles\n        WHERE program_id = ? AND name = ? AND open_at = ? AND deadline_at = ? AND late_until_at = ?\n    \"\"\"\n    final_cycles = safe_query(\n        final_db_path, cyq, (\n            cycle_values['program_id'],\n            cycle_values['name'],\n            cycle_values['open_at'],\n            cycle_values['deadline_at'],\n            cycle_values['late_until_at'],\n        )\n    )\n    if not final_cycles or len(final_cycles) == 0:\n        # Cycle doesn't exist in final db\n        return {\"result\": \"others\"}\n    if len(final_cycles) > 1:\n        # Ambiguity, not deterministic\n        return {\"result\": \"others\"}\n    # Confirm this cycle wasn't present in the initial db\n    initial_cycles = safe_query(\n        initial_db_path, cyq, (\n            cycle_values['program_id'],\n            cycle_values['name'],\n            cycle_values['open_at'],\n            cycle_values['deadline_at'],\n            cycle_values['late_until_at'],\n        )\n    )\n    if initial_cycles:\n        # It was already present - agent did not newly create it\n        return {\"result\": \"others\"}\n    # All requirements strictly satisfied\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To confirm completion, we must verify that the agent created an application cycle for the program 'STEM Scholars Grant' named 'Fall 2026' with the exact specified open date, deadline, and late submission period. The verification must ensure: (a) the new cycle exists in the 'cycles' table for the exact program, name, and all dates; (b) the corresponding program record for 'STEM Scholars Grant' exists to ensure proper program_id linkage; (c) these changes were not present in the initial database, confirming that this is a new creation and not an existing or renamed record. As the task is solely about creating the cycle, there is no requirement to check final_answer.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Confirm program 'STEM Scholars Grant' exists and its program_id is obtained.\",\n        \"Ensure that in the final database (but not the initial), a cycle exists for this program with name 'Fall 2026', open_at '2026-08-01T09:00:00-04:00', deadline_at '2026-10-01T17:00:00-04:00', and late_until_at '2026-10-08T17:00:00-04:00'.\",\n        \"Ensure the combination of (program_id, name) for this cycle did not exist in the initial database.\",\n        \"Check all relevant columns for exact match; do not accept partial matches or cycles with any differing field.\",\n        \"Return 'complete' only if all checks pass, else 'others'.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper for read-only query\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # 1. Find the program_id for 'STEM Scholars Grant' in BOTH dbs (should be the same)\\n    prog_q = \\\"SELECT id FROM programs WHERE name = ?\\\"\\n    initial_prog = safe_query(initial_db_path, prog_q, ('STEM Scholars Grant',))\\n    final_prog = safe_query(final_db_path, prog_q, ('STEM Scholars Grant',))\\n    if not final_prog or len(final_prog[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    program_id = final_prog[0][0]\\n    if not isinstance(program_id, int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 2. Try to find the target cycle in the FINAL db\\n    cycle_values = {\\n        'program_id': program_id,\\n        'name': 'Fall 2026',\\n        'open_at': '2026-08-01T09:00:00-04:00',\\n        'deadline_at': '2026-10-01T17:00:00-04:00',\\n        'late_until_at': '2026-10-08T17:00:00-04:00',\\n    }\\n    cyq = \\\"\\\"\\\"\\n        SELECT id, program_id, name, open_at, deadline_at, late_until_at FROM cycles\\n        WHERE program_id = ? AND name = ? AND open_at = ? AND deadline_at = ? AND late_until_at = ?\\n    \\\"\\\"\\\"\\n    final_cycles = safe_query(\\n        final_db_path, cyq, (\\n            cycle_values['program_id'],\\n            cycle_values['name'],\\n            cycle_values['open_at'],\\n            cycle_values['deadline_at'],\\n            cycle_values['late_until_at'],\\n        )\\n    )\\n    if not final_cycles or len(final_cycles) == 0:\\n        # Cycle doesn't exist in final db\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if len(final_cycles) > 1:\\n        # Ambiguity, not deterministic\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Confirm this cycle wasn't present in the initial db\\n    initial_cycles = safe_query(\\n        initial_db_path, cyq, (\\n            cycle_values['program_id'],\\n            cycle_values['name'],\\n            cycle_values['open_at'],\\n            cycle_values['deadline_at'],\\n            cycle_values['late_until_at'],\\n        )\\n    )\\n    if initial_cycles:\\n        # It was already present - agent did not newly create it\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All requirements strictly satisfied\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 2, "task": "Design an application form for cycle \"Fall 2026\" with three sections (\"Applicant Info\", \"Project Details\", \"Budget\") and add questions: full name (text, required), university (dropdown: \"State U\",\"City College\",\"Other\"), project abstract (long text, required, 2000 char limit), and requested amount (number, required, min 500, max 5000).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Find all cycles in initial and final\n    initial_cycles = safe_query(initial_db_path, \"SELECT id, name FROM cycles\")\n    final_cycles = safe_query(final_db_path, \"SELECT id, name FROM cycles\")\n    \n    # Find if 'Fall 2026' is newly present\n    initial_cycle_names = set([c[1] for c in initial_cycles])\n    final_cycle_names = set([c[1] for c in final_cycles])\n    new_cycle_names = final_cycle_names - initial_cycle_names\n    if 'Fall 2026' not in new_cycle_names:\n        return {\"result\": \"others\"}\n    \n    # Get the new cycle id\n    final_cycle_dict = {c[1]: c[0] for c in final_cycles}\n    cycle_id = final_cycle_dict.get('Fall 2026')\n    if not cycle_id:\n        return {\"result\": \"others\"}\n    \n    # Check for new application_form for 'Fall 2026'\n    app_form = safe_query(final_db_path, \"SELECT id, cycle_id, name FROM application_forms WHERE cycle_id=?\", (cycle_id,))\n    if len(app_form) != 1:\n        return {\"result\": \"others\"}\n    form_id = app_form[0][0]\n    \n    # Check for sections (by form_id and section_order)\n    sections = safe_query(final_db_path, \"SELECT title, section_order FROM form_sections WHERE form_id=? ORDER BY section_order\", (form_id,))\n    expected_sections = [('Applicant Info', 1), ('Project Details', 2), ('Budget', 3)]\n    # Normalize section titles\n    actual_sections = [(str(title).strip(), int(order)) for title, order in sections]\n    if actual_sections != expected_sections:\n        return {\"result\": \"others\"}\n    \n    # Get section IDs for later\n    section_ids = safe_query(final_db_path, \"SELECT id, title FROM form_sections WHERE form_id=?\", (form_id,))\n    section_id_map = {t: i for i, t in section_ids}\n    # To support defensive code, check that all expected sections are found\n    for stitle in ['Applicant Info', 'Project Details', 'Budget']:\n        if stitle not in section_id_map:\n            return {\"result\": \"others\"}\n    \n    # Check for questions on this form\n    # Determine existence of form_questions table\n    question_fields = safe_query(final_db_path, \"PRAGMA table_info('form_questions')\")\n    if not question_fields:\n        return {\"result\": \"others\"}\n    # Query all questions for this form\n    questions = safe_query(final_db_path, \"SELECT id, section_id, text, type, is_required, char_limit, min_value, max_value FROM form_questions WHERE section_id IN (SELECT id FROM form_sections WHERE form_id=?)\", (form_id,))\n    # Defensive: Question count\n    if len(questions) < 4:\n        return {\"result\": \"others\"}\n    # Match required fields\n    found_fullname = found_university = found_projectabstract = found_requestedamount = False\n    for q in questions:\n        q_id, sec_id, text, qtype, is_required, char_limit, min_value, max_value = q\n        text_norm = (text or '').strip().lower()\n        # Full name (Applicant Info, text, required, no char limit/min/max)\n        if text_norm in ['full name','name'] and sec_id == section_id_map['Applicant Info']:\n            if qtype == 'text' and is_required == 1 and (char_limit is None or char_limit == 0) and min_value is None and max_value is None:\n                found_fullname = True\n        # University dropdown (Applicant Info)\n        elif text_norm in ['university','university attended'] and sec_id == section_id_map['Applicant Info']:\n            if qtype == 'dropdown' and (is_required == 0 or is_required == 1):\n                # Check for options\n                opts = safe_query(final_db_path, \"SELECT value FROM form_question_options WHERE question_id=? ORDER BY option_order\", (q_id,))\n                opts_list = [o[0].strip() for o in opts]\n                if set(opts_list) == set(['State U','City College','Other']):\n                    found_university = True\n        # Project abstract (Project Details, textarea, required, char_limit 2000)\n        elif ('abstract' in text_norm or 'project abstract' in text_norm) and sec_id == section_id_map['Project Details']:\n            if qtype in ['textarea', 'longtext', 'text'] and is_required == 1 and char_limit == 2000:\n                found_projectabstract = True\n        # Requested amount (Budget, number, required, min 500, max 5000)\n        elif ('amount' in text_norm or 'requested amount' in text_norm) and sec_id == section_id_map['Budget']:\n            if qtype in ['number','numeric'] and is_required == 1 and min_value == 500 and max_value == 5000:\n                found_requestedamount = True\n    # Verify all required\n    if not (found_fullname and found_university and found_projectabstract and found_requestedamount):\n        return {\"result\": \"others\"}\n    \n    # Check that these entities (cycle, form) did NOT exist in initial db\n    initial_cycle_ids = [c[0] for c in initial_cycles if c[1] == 'Fall 2026']\n    if initial_cycle_ids:\n        return {\"result\": \"others\"}\n    initial_form = safe_query(initial_db_path, \"SELECT id FROM application_forms WHERE cycle_id=?\", (cycle_id,))\n    if initial_form:\n        return {\"result\": \"others\"}\n    \n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure that the agent created a new application form for cycle 'Fall 2026' (which did not exist before), structured it into three specified sections ('Applicant Info', 'Project Details', 'Budget'), and added four questions with the exact required configuration. Each question must have the correct field type, validation criteria, required flags, and dropdown options where applicable. All these need to be newly present in the final database and not in the initial database. The verification is based only on database changes.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"A new cycle named 'Fall 2026' must exist in the final_db but not in initial_db\",\n        \"A new application_form associated ONLY with the 'Fall 2026' cycle must exist in final_db\",\n        \"This form must have three sections titled 'Applicant Info', 'Project Details', and 'Budget' in that order\",\n        \"Four questions must be added to the new form with these configurations:\",\n        \"  - Full name: text field, required\",\n        \"  - University: dropdown with options ['State U', 'City College', 'Other']\",\n        \"  - Project abstract: long text (textarea), required, 2000 character limit\",\n        \"  - Requested amount: number, required, min 500, max 5000\",\n        \"All above questions must be linked to the correct section\",\n        \"No ambiguous/missing/partially completed attributes\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Find all cycles in initial and final\\n    initial_cycles = safe_query(initial_db_path, \\\"SELECT id, name FROM cycles\\\")\\n    final_cycles = safe_query(final_db_path, \\\"SELECT id, name FROM cycles\\\")\\n    \\n    # Find if 'Fall 2026' is newly present\\n    initial_cycle_names = set([c[1] for c in initial_cycles])\\n    final_cycle_names = set([c[1] for c in final_cycles])\\n    new_cycle_names = final_cycle_names - initial_cycle_names\\n    if 'Fall 2026' not in new_cycle_names:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Get the new cycle id\\n    final_cycle_dict = {c[1]: c[0] for c in final_cycles}\\n    cycle_id = final_cycle_dict.get('Fall 2026')\\n    if not cycle_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Check for new application_form for 'Fall 2026'\\n    app_form = safe_query(final_db_path, \\\"SELECT id, cycle_id, name FROM application_forms WHERE cycle_id=?\\\", (cycle_id,))\\n    if len(app_form) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    form_id = app_form[0][0]\\n    \\n    # Check for sections (by form_id and section_order)\\n    sections = safe_query(final_db_path, \\\"SELECT title, section_order FROM form_sections WHERE form_id=? ORDER BY section_order\\\", (form_id,))\\n    expected_sections = [('Applicant Info', 1), ('Project Details', 2), ('Budget', 3)]\\n    # Normalize section titles\\n    actual_sections = [(str(title).strip(), int(order)) for title, order in sections]\\n    if actual_sections != expected_sections:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Get section IDs for later\\n    section_ids = safe_query(final_db_path, \\\"SELECT id, title FROM form_sections WHERE form_id=?\\\", (form_id,))\\n    section_id_map = {t: i for i, t in section_ids}\\n    # To support defensive code, check that all expected sections are found\\n    for stitle in ['Applicant Info', 'Project Details', 'Budget']:\\n        if stitle not in section_id_map:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Check for questions on this form\\n    # Determine existence of form_questions table\\n    question_fields = safe_query(final_db_path, \\\"PRAGMA table_info('form_questions')\\\")\\n    if not question_fields:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Query all questions for this form\\n    questions = safe_query(final_db_path, \\\"SELECT id, section_id, text, type, is_required, char_limit, min_value, max_value FROM form_questions WHERE section_id IN (SELECT id FROM form_sections WHERE form_id=?)\\\", (form_id,))\\n    # Defensive: Question count\\n    if len(questions) < 4:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Match required fields\\n    found_fullname = found_university = found_projectabstract = found_requestedamount = False\\n    for q in questions:\\n        q_id, sec_id, text, qtype, is_required, char_limit, min_value, max_value = q\\n        text_norm = (text or '').strip().lower()\\n        # Full name (Applicant Info, text, required, no char limit/min/max)\\n        if text_norm in ['full name','name'] and sec_id == section_id_map['Applicant Info']:\\n            if qtype == 'text' and is_required == 1 and (char_limit is None or char_limit == 0) and min_value is None and max_value is None:\\n                found_fullname = True\\n        # University dropdown (Applicant Info)\\n        elif text_norm in ['university','university attended'] and sec_id == section_id_map['Applicant Info']:\\n            if qtype == 'dropdown' and (is_required == 0 or is_required == 1):\\n                # Check for options\\n                opts = safe_query(final_db_path, \\\"SELECT value FROM form_question_options WHERE question_id=? ORDER BY option_order\\\", (q_id,))\\n                opts_list = [o[0].strip() for o in opts]\\n                if set(opts_list) == set(['State U','City College','Other']):\\n                    found_university = True\\n        # Project abstract (Project Details, textarea, required, char_limit 2000)\\n        elif ('abstract' in text_norm or 'project abstract' in text_norm) and sec_id == section_id_map['Project Details']:\\n            if qtype in ['textarea', 'longtext', 'text'] and is_required == 1 and char_limit == 2000:\\n                found_projectabstract = True\\n        # Requested amount (Budget, number, required, min 500, max 5000)\\n        elif ('amount' in text_norm or 'requested amount' in text_norm) and sec_id == section_id_map['Budget']:\\n            if qtype in ['number','numeric'] and is_required == 1 and min_value == 500 and max_value == 5000:\\n                found_requestedamount = True\\n    # Verify all required\\n    if not (found_fullname and found_university and found_projectabstract and found_requestedamount):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Check that these entities (cycle, form) did NOT exist in initial db\\n    initial_cycle_ids = [c[0] for c in initial_cycles if c[1] == 'Fall 2026']\\n    if initial_cycle_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_form = safe_query(initial_db_path, \\\"SELECT id FROM application_forms WHERE cycle_id=?\\\", (cycle_id,))\\n    if initial_form:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 3, "task": "Configure required document uploads for cycle \"Fall 2026\": \"Unofficial Transcript\" (PDF only, max 10MB, required) and \"Letter of Recommendation\" (PDF only, max 10MB, required, must be submitted by recommender).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper function to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()):        \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Check for the new cycle: 'Fall 2026'. It must NOT exist in the initial_db, but MUST in the final_db (case-sensitive).\n    cycle_query = \"SELECT id, name FROM cycles WHERE name = ?\"\n    initial_cycles = safe_query(initial_db_path, cycle_query, (\"Fall 2026\",))\n    final_cycles = safe_query(final_db_path, cycle_query, (\"Fall 2026\",))\n    if len(initial_cycles) != 0:\n        return {\"result\": \"others\"}  # Should not exist before\n    if len(final_cycles) != 1:\n        return {\"result\": \"others\"}  # Should be created and must be exactly one\n    cycle_id = final_cycles[0][0]\n    if not isinstance(cycle_id, int):\n        return {\"result\": \"others\"}\n\n    # 2. Check document requirements for that cycle in final_db\n    docreq_query = \"\"\"\n        SELECT name, is_required, allowed_mime_types, max_bytes, submitted_by_role\n        FROM document_requirements WHERE cycle_id = ?\n    \"\"\"\n    docreqs = safe_query(final_db_path, docreq_query, (cycle_id,))\n    if len(docreqs) != 2:\n        return {\"result\": \"others\"}  # Exactly two required\n\n    # To ease comparison, collect requirements\n    wanted = [\n        {\n            \"name\": \"Unofficial Transcript\",\n            \"is_required\": 1,\n            \"allowed_mime_types\": \"application/pdf\",\n            \"max_bytes\": 10485760,\n            \"submitted_by_role\": \"applicant\"\n        },\n        {\n            \"name\": \"Letter of Recommendation\",\n            \"is_required\": 1,\n            \"allowed_mime_types\": \"application/pdf\",\n            \"max_bytes\": 10485760,\n            \"submitted_by_role\": \"recommender\"\n        }\n    ]\n    found = [\n        {\n            \"name\": row[0],\n            \"is_required\": int(row[1]) if row[1] is not None else None,\n            \"allowed_mime_types\": row[2],\n            \"max_bytes\": int(row[3]) if row[3] is not None else None,\n            \"submitted_by_role\": row[4]\n        } for row in docreqs\n    ]\n    # Each wanted requirement must exactly match one and only one entry in found\n    for w in wanted:\n        matches = [f for f in found if all(f[k] == v for k, v in w.items())]\n        if len(matches) != 1:\n            return {\"result\": \"others\"}\n\n    # Ensure no extras\n    for f in found:\n        matches = [w for w in wanted if all(f[k] == v for k, v in w.items())]\n        if len(matches) != 1:\n            return {\"result\": \"others\"}\n\n    # 3. Check that such document requirements do not exist in initial_db for any cycle\n    # (for safety: neither for \"Unofficial Transcript\" nor \"Letter of Recommendation\").\n    for w in wanted:\n        initial_check = safe_query(\n            initial_db_path,\n            \"\"\"\n            SELECT 1 FROM document_requirements WHERE \n            name = ? AND is_required = ? AND allowed_mime_types = ? AND max_bytes = ? AND submitted_by_role = ?\n            \"\"\",\n            (w[\"name\"], w[\"is_required\"], w[\"allowed_mime_types\"], w[\"max_bytes\"], w[\"submitted_by_role\"])\n        )\n        if len(initial_check) != 0:\n            return {\"result\": \"others\"}\n\n    # All validations passed strictly\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify if the AI agent configured the required document uploads for the cycle 'Fall 2026', we must ensure: (1) a cycle named exactly 'Fall 2026' exists after agent action (it did NOT exist before), (2) two required document_requirements are present and only for the Fall 2026 cycle: 'Unofficial Transcript' (PDF only, max 10MB, required, submitted by applicant or default is applicant) and 'Letter of Recommendation' (PDF only, max 10MB, required, submitted_by_role must be 'recommender'). Each field must match exactly. No extra, missing, or misconfigured requirement is allowed for that cycle. The requirements must not exist in the initial database. Robustness is necessary to discard cases of imprecise document setup, for example wrong allowed_mime_types, wrong max_bytes, wrong required/optional flags, or missing cycle. There are no constraints on the final_answer. No 'Fall 2026' cycle exists before, so there should be new entries in cycles and document_requirements. All checks are on the modification of the database.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Verify a new cycle named exactly 'Fall 2026' exists in the final_db, and did NOT exist in the initial_db.\",\n        \"Get the id of the new 'Fall 2026' cycle in final_db.\",\n        \"Check exactly two rows exist in document_requirements for the new cycle_id.\",\n        \"Ensure document_requirements for 'Unofficial Transcript': name matches exactly, is_required=1, allowed_mime_types='application/pdf', max_bytes=10485760, submitted_by_role is 'applicant'.\",\n        \"Ensure document_requirements for 'Letter of Recommendation': name matches exactly, is_required=1, allowed_mime_types='application/pdf', max_bytes=10485760, submitted_by_role is 'recommender'.\",\n        \"No extra (i.e., neither other nor duplicate) document requirements for the new cycle.\",\n        \"No such requirements and no such cycle existed in the initial_db.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper function to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()):        \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Check for the new cycle: 'Fall 2026'. It must NOT exist in the initial_db, but MUST in the final_db (case-sensitive).\\n    cycle_query = \\\"SELECT id, name FROM cycles WHERE name = ?\\\"\\n    initial_cycles = safe_query(initial_db_path, cycle_query, (\\\"Fall 2026\\\",))\\n    final_cycles = safe_query(final_db_path, cycle_query, (\\\"Fall 2026\\\",))\\n    if len(initial_cycles) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}  # Should not exist before\\n    if len(final_cycles) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}  # Should be created and must be exactly one\\n    cycle_id = final_cycles[0][0]\\n    if not isinstance(cycle_id, int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Check document requirements for that cycle in final_db\\n    docreq_query = \\\"\\\"\\\"\\n        SELECT name, is_required, allowed_mime_types, max_bytes, submitted_by_role\\n        FROM document_requirements WHERE cycle_id = ?\\n    \\\"\\\"\\\"\\n    docreqs = safe_query(final_db_path, docreq_query, (cycle_id,))\\n    if len(docreqs) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}  # Exactly two required\\n\\n    # To ease comparison, collect requirements\\n    wanted = [\\n        {\\n            \\\"name\\\": \\\"Unofficial Transcript\\\",\\n            \\\"is_required\\\": 1,\\n            \\\"allowed_mime_types\\\": \\\"application/pdf\\\",\\n            \\\"max_bytes\\\": 10485760,\\n            \\\"submitted_by_role\\\": \\\"applicant\\\"\\n        },\\n        {\\n            \\\"name\\\": \\\"Letter of Recommendation\\\",\\n            \\\"is_required\\\": 1,\\n            \\\"allowed_mime_types\\\": \\\"application/pdf\\\",\\n            \\\"max_bytes\\\": 10485760,\\n            \\\"submitted_by_role\\\": \\\"recommender\\\"\\n        }\\n    ]\\n    found = [\\n        {\\n            \\\"name\\\": row[0],\\n            \\\"is_required\\\": int(row[1]) if row[1] is not None else None,\\n            \\\"allowed_mime_types\\\": row[2],\\n            \\\"max_bytes\\\": int(row[3]) if row[3] is not None else None,\\n            \\\"submitted_by_role\\\": row[4]\\n        } for row in docreqs\\n    ]\\n    # Each wanted requirement must exactly match one and only one entry in found\\n    for w in wanted:\\n        matches = [f for f in found if all(f[k] == v for k, v in w.items())]\\n        if len(matches) != 1:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Ensure no extras\\n    for f in found:\\n        matches = [w for w in wanted if all(f[k] == v for k, v in w.items())]\\n        if len(matches) != 1:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Check that such document requirements do not exist in initial_db for any cycle\\n    # (for safety: neither for \\\"Unofficial Transcript\\\" nor \\\"Letter of Recommendation\\\").\\n    for w in wanted:\\n        initial_check = safe_query(\\n            initial_db_path,\\n            \\\"\\\"\\\"\\n            SELECT 1 FROM document_requirements WHERE \\n            name = ? AND is_required = ? AND allowed_mime_types = ? AND max_bytes = ? AND submitted_by_role = ?\\n            \\\"\\\"\\\",\\n            (w[\\\"name\\\"], w[\\\"is_required\\\"], w[\\\"allowed_mime_types\\\"], w[\\\"max_bytes\\\"], w[\\\"submitted_by_role\\\"])\\n        )\\n        if len(initial_check) != 0:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All validations passed strictly\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 4, "task": "Add eligibility rules to cycle \"Fall 2026\" to automatically mark applicants ineligible if GPA is below 3.2 or enrollment status is not \"Full-time\" (values: \"Full-time\",\"Part-time\").", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Find 'Fall 2026' cycle in initial and final DB\n    get_cycle = lambda db_path: safe_query(\n        db_path,\n        \"SELECT id, name FROM cycles WHERE name = ?\",\n        (\"Fall 2026\",)\n    )\n    initial_cycle = get_cycle(initial_db_path)\n    final_cycle = get_cycle(final_db_path)\n    \n    if not final_cycle or len(final_cycle) != 1:\n        # 'Fall 2026' cycle not present in final db, or ambiguous\n        return {\"result\": \"others\"}\n    final_cycle_id = final_cycle[0][0]\n    \n    # It is possible that 'Fall 2026' is new, or existed and only rules were changed.\n    initial_cycle_id = initial_cycle[0][0] if initial_cycle and len(initial_cycle) == 1 else None\n    \n    # Get eligibility rules for 'Fall 2026' cycle in both DBs\n    def get_rules(db_path, cycle_id):\n        if not cycle_id:\n            return []\n        return safe_query(\n            db_path,\n            \"SELECT field_key, operator, value_json, on_fail_action FROM eligibility_rules WHERE cycle_id = ?\",\n            (cycle_id,)\n        )\n    final_rules = get_rules(final_db_path, final_cycle_id)\n    initial_rules = get_rules(initial_db_path, initial_cycle_id) if initial_cycle_id else []\n\n    # Define what the rules must be (strict)\n    expected_gpa_rule = (\n        'gpa', '<', '3.2', 'mark_ineligible'\n    )\n    expected_enroll_rule = (\n        'enrollment_status', '!=', '\"Full-time\"', 'mark_ineligible'\n    )\n    \n    # Should be present, exactly and only once each, and not present in initial_rules\n    found_gpa = False\n    found_enroll = False\n    gpa_count = 0\n    enroll_count = 0\n    for rule in final_rules:\n        # Defensive: use tuple equality\n        if rule == expected_gpa_rule:\n            found_gpa = True\n            gpa_count += 1\n        if rule == expected_enroll_rule:\n            found_enroll = True\n            enroll_count += 1\n    # Must be exactly one of each\n    if not (found_gpa and found_enroll):\n        return {\"result\": \"others\"}\n    if not (gpa_count == 1 and enroll_count == 1):\n        return {\"result\": \"others\"}\n    # They must be NEW (not present in initial_rules)\n    if expected_gpa_rule in initial_rules or expected_enroll_rule in initial_rules:\n        return {\"result\": \"others\"}\n    \n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure that new eligibility rules were added to the 'Fall 2026' cycle to automatically mark applicants ineligible if their GPA is below 3.2 or if their enrollment status is not exactly 'Full-time'. First, we must confirm that a 'Fall 2026' cycle exists (or was created), then check that at least two new eligibility_rules were created (compared to initial), associated with the correct cycle: 1) a GPA rule with operator '<', value '3.2', and on_fail_action 'mark_ineligible', and 2) an enrollment_status rule with operator '!=', value '\\\"Full-time\\\"', and on_fail_action 'mark_ineligible'. The rules must be present, exactly match, be for the correct cycle, and not exist in the initial database. No other changes are required for this task.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Locate the 'Fall 2026' cycle in the final database and get its id\",\n        \"Check if the initial database did not have 'Fall 2026' cycle (i.e. it was newly added) or if it existed, compare the eligibility_rules for that cycle\",\n        \"Locate all eligibility_rules for the 'Fall 2026' cycle in the final database\",\n        \"Check for a GPA rule: field_key = 'gpa', operator = '<', value_json = '3.2', on_fail_action = 'mark_ineligible'\",\n        \"Check for enrollment status rule: field_key = 'enrollment_status', operator = '!=', value_json = '\\\"Full-time\\\"', on_fail_action = 'mark_ineligible'\",\n        \"Both rules must be present, exactly and only once, and not present for that cycle in the initial database\",\n        \"If any required information is missing, malformed, or ambiguous, return {'result': 'others'}\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Find 'Fall 2026' cycle in initial and final DB\\n    get_cycle = lambda db_path: safe_query(\\n        db_path,\\n        \\\"SELECT id, name FROM cycles WHERE name = ?\\\",\\n        (\\\"Fall 2026\\\",)\\n    )\\n    initial_cycle = get_cycle(initial_db_path)\\n    final_cycle = get_cycle(final_db_path)\\n    \\n    if not final_cycle or len(final_cycle) != 1:\\n        # 'Fall 2026' cycle not present in final db, or ambiguous\\n        return {\\\"result\\\": \\\"others\\\"}\\n    final_cycle_id = final_cycle[0][0]\\n    \\n    # It is possible that 'Fall 2026' is new, or existed and only rules were changed.\\n    initial_cycle_id = initial_cycle[0][0] if initial_cycle and len(initial_cycle) == 1 else None\\n    \\n    # Get eligibility rules for 'Fall 2026' cycle in both DBs\\n    def get_rules(db_path, cycle_id):\\n        if not cycle_id:\\n            return []\\n        return safe_query(\\n            db_path,\\n            \\\"SELECT field_key, operator, value_json, on_fail_action FROM eligibility_rules WHERE cycle_id = ?\\\",\\n            (cycle_id,)\\n        )\\n    final_rules = get_rules(final_db_path, final_cycle_id)\\n    initial_rules = get_rules(initial_db_path, initial_cycle_id) if initial_cycle_id else []\\n\\n    # Define what the rules must be (strict)\\n    expected_gpa_rule = (\\n        'gpa', '<', '3.2', 'mark_ineligible'\\n    )\\n    expected_enroll_rule = (\\n        'enrollment_status', '!=', '\\\"Full-time\\\"', 'mark_ineligible'\\n    )\\n    \\n    # Should be present, exactly and only once each, and not present in initial_rules\\n    found_gpa = False\\n    found_enroll = False\\n    gpa_count = 0\\n    enroll_count = 0\\n    for rule in final_rules:\\n        # Defensive: use tuple equality\\n        if rule == expected_gpa_rule:\\n            found_gpa = True\\n            gpa_count += 1\\n        if rule == expected_enroll_rule:\\n            found_enroll = True\\n            enroll_count += 1\\n    # Must be exactly one of each\\n    if not (found_gpa and found_enroll):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (gpa_count == 1 and enroll_count == 1):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # They must be NEW (not present in initial_rules)\\n    if expected_gpa_rule in initial_rules or expected_enroll_rule in initial_rules:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 5, "task": "Find all submissions in cycle \"Fall 2026\" with status \"Submitted\" that were created between \"2026-09-15\" and \"2026-09-30\" and move them to status \"In Review\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime\n\n    # Helper: Safely query DB\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Helper: parse date\n    def parse_dt(val):\n        try:\n            # Accept both naive and iso formats\n            if isinstance(val, str):\n                if 'T' in val and '-' in val:\n                    # Potentially iso format with timezone\n                    return datetime.fromisoformat(val.replace('Z','').split('+')[0])\n                # Accept usual datetime\n                return datetime.strptime(val[:19], '%Y-%m-%d %H:%M:%S')\n        except Exception:\n            pass\n        return None\n\n    # Step 1: Find cycle_id for 'Fall 2026'\n    cycle_rows = safe_query(initial_db_path, \"SELECT id FROM cycles WHERE name = ?\", (\"Fall 2026\",))\n    if not cycle_rows or not isinstance(cycle_rows[0][0], int):\n        return {\"result\": \"others\"}  # cycle missing or ambiguous\n    cycle_id = cycle_rows[0][0]\n\n    # Step 2: Get qualifying submissions from initial_db\n    initial_submissions = safe_query(\n        initial_db_path,\n        \"SELECT id, status, created_at, applicant_user_id, submission_code, cycle_id, ineligible_reason, updated_at, submitted_at FROM submissions WHERE cycle_id = ? AND status = ?\",\n        (cycle_id, \"Submitted\")\n    )\n\n    lower_bound = \"2026-09-15\"\n    upper_bound = \"2026-09-30\"\n    def date_in_range(dt_val):\n        # Accept both datetime and date\n        try:\n            if dt_val is None:\n                return False\n            if isinstance(dt_val, str):\n                dt_check = None\n                try:\n                    dt_check = datetime.strptime(dt_val[:10], \"%Y-%m-%d\")\n                except Exception:\n                    dt_check = parse_dt(dt_val)\n                if dt_check is None:\n                    return False\n                lb = datetime.strptime(lower_bound, \"%Y-%m-%d\")\n                ub = datetime.strptime(upper_bound, \"%Y-%m-%d\")\n                return lb <= dt_check <= ub\n            return False\n        except Exception:\n            return False\n\n    # Filter qualifying submissions\n    qual_ids = []\n    submission_initial_info = {}\n    for row in initial_submissions:\n        sid, status, created_at, applicant_user_id, submission_code, cyc_id, ineligible_reason, updated_at, submitted_at = row\n        if date_in_range(created_at):\n            qual_ids.append(sid)\n            # Save all fields except updated_at for later comparison\n            submission_initial_info[sid] = {\n                \"status\": status,\n                \"created_at\": created_at,\n                \"applicant_user_id\": applicant_user_id,\n                \"submission_code\": submission_code,\n                \"cycle_id\": cyc_id,\n                \"ineligible_reason\": ineligible_reason,\n                \"submitted_at\": submitted_at\n            }\n\n    # If no qualifying submission, return 'others' (task cannot be fulfilled)\n    if not qual_ids:\n        return {\"result\": \"others\"}\n\n    # Step 3: Check these submissions in final_db\n    # Fetch all relevant submissions\n    final_submissions = safe_query(\n        final_db_path,\n        \"SELECT id, status, created_at, applicant_user_id, submission_code, cycle_id, ineligible_reason, updated_at, submitted_at FROM submissions WHERE id IN (%s)\" % (','.join(['?']*len(qual_ids))),\n        tuple(qual_ids)\n    ) if qual_ids else []\n    # Defensive: if missing any submission row, return others\n    final_info = {}\n    for row in final_submissions:\n        sid, status, created_at, applicant_user_id, submission_code, cyc_id, ineligible_reason, updated_at, submitted_at = row\n        final_info[sid] = {\n            \"status\": status,\n            \"created_at\": created_at,\n            \"applicant_user_id\": applicant_user_id,\n            \"submission_code\": submission_code,\n            \"cycle_id\": cyc_id,\n            \"ineligible_reason\": ineligible_reason,\n            \"submitted_at\": submitted_at\n        }\n\n    # All qualifying ids must be present\n    if set(qual_ids) != set(final_info.keys()):\n        return {\"result\": \"others\"}\n\n    # Step 4: For each, check status and all other fields except updated_at\n    for sid in qual_ids:\n        fin = final_info[sid]\n        ini = submission_initial_info[sid]\n        # Must be 'In Review', and others must match\n        if fin[\"status\"] != \"In Review\":\n            return {\"result\": \"others\"}\n        for fld in [\"created_at\", \"applicant_user_id\", \"submission_code\", \"cycle_id\", \"ineligible_reason\", \"submitted_at\"]:\n            if fin[fld] != ini[fld]:\n                return {\"result\": \"others\"}\n\n    # Step 5: Defensive - Make sure no other submission in this cycle changed status incorrectly\n    # Get all submissions in 'Fall 2026' in both DBs\n    all_init = safe_query(\n        initial_db_path,\n        \"SELECT id, status FROM submissions WHERE cycle_id = ?\",\n        (cycle_id,)\n    )\n    all_final = safe_query(\n        final_db_path,\n        \"SELECT id, status FROM submissions WHERE cycle_id = ?\",\n        (cycle_id,)\n    )\n    init_status_map = {sid: status for sid, status in all_init}\n    final_status_map = {sid: status for sid, status in all_final}\n\n    # For non-qualifying submissions, status should remain unchanged\n    for sid, status in init_status_map.items():\n        if sid not in qual_ids:\n            if sid not in final_status_map:\n                return {\"result\": \"others\"}\n            if final_status_map[sid] != status:\n                return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify the task, we must ensure that in the final database, ALL submissions in the cycle \\\"Fall 2026\\\" that had status \\\"Submitted\\\" and were created between \\\"2026-09-15\\\" and \\\"2026-09-30\\\" in the initial database have had their status updated to \\\"In Review\\\". No other submissions should have been affected. We must (1) identify the cycle_id for 'Fall 2026', (2) query the initial database for qualifying submissions, (3) check those submission ids in the final database for correct status, and (4) ensure their other values are unchanged. If any submission failed to be updated or extra records were altered, or if no qualifying submissions exist, we must handle gracefully and return 'others' unless the operation is fully complete and correct.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find cycle_id for 'Fall 2026' in both initial and final databases (must exist in both or else 'others')\",\n        \"Identify all submission ids in initial database in cycle 'Fall 2026' with status 'Submitted' and created_at between '2026-09-15' and '2026-09-30' inclusive\",\n        \"If no such submissions, return 'others' (nothing to move)\",\n        \"For each qualifying submission, verify in final database: status is 'In Review' and all other fields (except updated_at) are unchanged\",\n        \"Ensure no other submission in initial 'Fall 2026' received status modification from 'Submitted' to other than 'In Review'\",\n        \"Defensively handle missing tables and malformed values\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime\\n\\n    # Helper: Safely query DB\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Helper: parse date\\n    def parse_dt(val):\\n        try:\\n            # Accept both naive and iso formats\\n            if isinstance(val, str):\\n                if 'T' in val and '-' in val:\\n                    # Potentially iso format with timezone\\n                    return datetime.fromisoformat(val.replace('Z','').split('+')[0])\\n                # Accept usual datetime\\n                return datetime.strptime(val[:19], '%Y-%m-%d %H:%M:%S')\\n        except Exception:\\n            pass\\n        return None\\n\\n    # Step 1: Find cycle_id for 'Fall 2026'\\n    cycle_rows = safe_query(initial_db_path, \\\"SELECT id FROM cycles WHERE name = ?\\\", (\\\"Fall 2026\\\",))\\n    if not cycle_rows or not isinstance(cycle_rows[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}  # cycle missing or ambiguous\\n    cycle_id = cycle_rows[0][0]\\n\\n    # Step 2: Get qualifying submissions from initial_db\\n    initial_submissions = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id, status, created_at, applicant_user_id, submission_code, cycle_id, ineligible_reason, updated_at, submitted_at FROM submissions WHERE cycle_id = ? AND status = ?\\\",\\n        (cycle_id, \\\"Submitted\\\")\\n    )\\n\\n    lower_bound = \\\"2026-09-15\\\"\\n    upper_bound = \\\"2026-09-30\\\"\\n    def date_in_range(dt_val):\\n        # Accept both datetime and date\\n        try:\\n            if dt_val is None:\\n                return False\\n            if isinstance(dt_val, str):\\n                dt_check = None\\n                try:\\n                    dt_check = datetime.strptime(dt_val[:10], \\\"%Y-%m-%d\\\")\\n                except Exception:\\n                    dt_check = parse_dt(dt_val)\\n                if dt_check is None:\\n                    return False\\n                lb = datetime.strptime(lower_bound, \\\"%Y-%m-%d\\\")\\n                ub = datetime.strptime(upper_bound, \\\"%Y-%m-%d\\\")\\n                return lb <= dt_check <= ub\\n            return False\\n        except Exception:\\n            return False\\n\\n    # Filter qualifying submissions\\n    qual_ids = []\\n    submission_initial_info = {}\\n    for row in initial_submissions:\\n        sid, status, created_at, applicant_user_id, submission_code, cyc_id, ineligible_reason, updated_at, submitted_at = row\\n        if date_in_range(created_at):\\n            qual_ids.append(sid)\\n            # Save all fields except updated_at for later comparison\\n            submission_initial_info[sid] = {\\n                \\\"status\\\": status,\\n                \\\"created_at\\\": created_at,\\n                \\\"applicant_user_id\\\": applicant_user_id,\\n                \\\"submission_code\\\": submission_code,\\n                \\\"cycle_id\\\": cyc_id,\\n                \\\"ineligible_reason\\\": ineligible_reason,\\n                \\\"submitted_at\\\": submitted_at\\n            }\\n\\n    # If no qualifying submission, return 'others' (task cannot be fulfilled)\\n    if not qual_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Check these submissions in final_db\\n    # Fetch all relevant submissions\\n    final_submissions = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, status, created_at, applicant_user_id, submission_code, cycle_id, ineligible_reason, updated_at, submitted_at FROM submissions WHERE id IN (%s)\\\" % (','.join(['?']*len(qual_ids))),\\n        tuple(qual_ids)\\n    ) if qual_ids else []\\n    # Defensive: if missing any submission row, return others\\n    final_info = {}\\n    for row in final_submissions:\\n        sid, status, created_at, applicant_user_id, submission_code, cyc_id, ineligible_reason, updated_at, submitted_at = row\\n        final_info[sid] = {\\n            \\\"status\\\": status,\\n            \\\"created_at\\\": created_at,\\n            \\\"applicant_user_id\\\": applicant_user_id,\\n            \\\"submission_code\\\": submission_code,\\n            \\\"cycle_id\\\": cyc_id,\\n            \\\"ineligible_reason\\\": ineligible_reason,\\n            \\\"submitted_at\\\": submitted_at\\n        }\\n\\n    # All qualifying ids must be present\\n    if set(qual_ids) != set(final_info.keys()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: For each, check status and all other fields except updated_at\\n    for sid in qual_ids:\\n        fin = final_info[sid]\\n        ini = submission_initial_info[sid]\\n        # Must be 'In Review', and others must match\\n        if fin[\\\"status\\\"] != \\\"In Review\\\":\\n            return {\\\"result\\\": \\\"others\\\"}\\n        for fld in [\\\"created_at\\\", \\\"applicant_user_id\\\", \\\"submission_code\\\", \\\"cycle_id\\\", \\\"ineligible_reason\\\", \\\"submitted_at\\\"]:\\n            if fin[fld] != ini[fld]:\\n                return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 5: Defensive - Make sure no other submission in this cycle changed status incorrectly\\n    # Get all submissions in 'Fall 2026' in both DBs\\n    all_init = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id, status FROM submissions WHERE cycle_id = ?\\\",\\n        (cycle_id,)\\n    )\\n    all_final = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, status FROM submissions WHERE cycle_id = ?\\\",\\n        (cycle_id,)\\n    )\\n    init_status_map = {sid: status for sid, status in all_init}\\n    final_status_map = {sid: status for sid, status in all_final}\\n\\n    # For non-qualifying submissions, status should remain unchanged\\n    for sid, status in init_status_map.items():\\n        if sid not in qual_ids:\\n            if sid not in final_status_map:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if final_status_map[sid] != status:\\n                return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 6, "task": "Create three reviewers (\"Dr. Maya Chen\", \"Alex Rivera\", \"Priya Nair\") and assign each \"In Review\" submission in cycle \"Fall 2026\" to exactly two reviewers while ensuring no reviewer is assigned to an applicant from their own organization.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    # Defensive DB querying\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # Reviewer setup: get reviewer user_ids, names, organization_ids from 'users'\n    reviewer_names = ['Dr. Maya Chen', 'Alex Rivera', 'Priya Nair']\n    reviewer_data = safe_query(final_db_path, \"SELECT id, full_name, organization_id FROM users WHERE full_name IN (?, ?, ?)\", tuple(reviewer_names))\n    if len(reviewer_data) != 3:\n        return {\"result\": \"others\"}\n    user_id_map = {row[1]: row[0] for row in reviewer_data}\n    org_map = {row[1]: row[2] for row in reviewer_data}\n    # Reviewer user_ids\n    reviewer_user_ids = [user_id_map[n] for n in reviewer_names if n in user_id_map]\n    # Confirm all reviewers are present\n    if len(reviewer_user_ids) != 3:\n        return {\"result\": \"others\"}\n    # Get reviewer ids from reviewers table (user_id -> reviewer_id)\n    reviewer_id_rows = safe_query(final_db_path, \"SELECT id, user_id FROM reviewers WHERE user_id IN (?, ?, ?)\", tuple(reviewer_user_ids))\n    if len(reviewer_id_rows) != 3:\n        return {\"result\": \"others\"}\n    user_to_reviewer_id = {row[1]: row[0] for row in reviewer_id_rows}\n    reviewer_ids = [user_to_reviewer_id[uid] for uid in reviewer_user_ids if uid in user_to_reviewer_id]\n    if len(reviewer_ids) != 3:\n        return {\"result\": \"others\"}\n    # Find cycle_id for 'Fall 2026'\n    cycle = safe_query(final_db_path, \"SELECT id FROM cycles WHERE name = ?\", (\"Fall 2026\",))\n    if not cycle or not cycle[0] or cycle[0][0] is None:\n        return {\"result\": \"others\"}\n    cycle_id = cycle[0][0]\n    # Find all 'In Review' submissions for this cycle\n    submissions_rows = safe_query(final_db_path, \"SELECT id, applicant_user_id FROM submissions WHERE cycle_id = ? AND status = ?\", (cycle_id, \"In Review\"))\n    if not submissions_rows:\n        return {\"result\": \"others\"}\n    in_review_submission_ids = [row[0] for row in submissions_rows]\n    submission_applicant_map = {row[0]: row[1] for row in submissions_rows}\n    # Get applicant organizations\n    applicant_org_map = {}\n    for sid, applicant_uid in submission_applicant_map.items():\n        org_rows = safe_query(final_db_path, \"SELECT organization_id FROM users WHERE id = ?\", (applicant_uid,))\n        applicant_org_map[sid] = org_rows[0][0] if org_rows and org_rows[0] else None\n    # Get review assignments for these submissions in this cycle\n    assignments = safe_query(final_db_path, \n        f\"SELECT submission_id, reviewer_id FROM review_assignments WHERE cycle_id = ? AND submission_id IN ({','.join(['?']*len(in_review_submission_ids))})\",\n        (cycle_id, *in_review_submission_ids) if in_review_submission_ids else (cycle_id,)\n    )\n    # Organize assignments per submission\n    assignments_per_submission = {}\n    for row in assignments:\n        sid, reviewer_id = row\n        if sid not in assignments_per_submission:\n            assignments_per_submission[sid] = []\n        assignments_per_submission[sid].append(reviewer_id)\n    # For each submission, check:\n    for sid in in_review_submission_ids:\n        assigned_reviewers = assignments_per_submission.get(sid, [])\n        # Exactly two reviewers\n        if len(assigned_reviewers) != 2:\n            return {\"result\": \"others\"}\n        # Both reviewers are in the correct set\n        for rev_id in assigned_reviewers:\n            if rev_id not in reviewer_ids:\n                return {\"result\": \"others\"}\n        # No organization conflict with applicant\n        applicant_org = applicant_org_map.get(sid)\n        for rev_id in assigned_reviewers:\n            # Find reviewer user_id\n            reviewer_user_id_row = safe_query(final_db_path, \"SELECT user_id FROM reviewers WHERE id = ?\", (rev_id,))\n            reviewer_user_id = reviewer_user_id_row[0][0] if reviewer_user_id_row and reviewer_user_id_row[0] else None\n            if reviewer_user_id is None:\n                return {\"result\": \"others\"}\n            reviewer_org_row = safe_query(final_db_path, \"SELECT organization_id FROM users WHERE id = ?\", (reviewer_user_id,))\n            reviewer_org = reviewer_org_row[0][0] if reviewer_org_row and reviewer_org_row[0] else None\n            # If applicant_org or reviewer_org is missing, cannot pass\n            if applicant_org is None or reviewer_org is None:\n                return {\"result\": \"others\"}\n            if reviewer_org == applicant_org:\n                return {\"result\": \"others\"}\n    # Additional check: ensure no extra assignments for these submissions to other reviewers\n    for sid in assignments_per_submission:\n        assigned_reviewers = assignments_per_submission[sid]\n        if set(assigned_reviewers) - set(reviewer_ids):\n            return {\"result\": \"others\"}\n    # Check for extra reviewers assigned to 'In Review' submissions by diff\n    # Check that initial_db_path didn't have these assignments\n    # Optionally: If initial assignments were present, ensure they were fully overwritten (i.e., by the correct set, but since the task is 'create & assign', we only check final state)\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The agent must create three reviewers ('Dr. Maya Chen', 'Alex Rivera', 'Priya Nair'), assign each 'In Review' submission in cycle 'Fall 2026' to exactly two reviewers, and ensure no reviewer is assigned to an applicant from their own organization. Therefore, verification requires:\\n1. Confirm all three reviewers exist in the reviewers table and are correctly mapped to their user records.\\n2. Identify the correct cycle ('Fall 2026') and retrieve all submissions in this cycle with status 'In Review'.\\n3. For each such submission, verify it is assigned to exactly two reviewers, both being from the correct reviewer set.\\n4. Ensure neither reviewer is from the same organization as the applicant of the submission.\\n5. Edge cases include missing reviewers, extra reviewers, incorrect assignments, organization conflicts, or incomplete assignments.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Confirm exactly three reviewers ('Dr. Maya Chen', 'Alex Rivera', 'Priya Nair') exist in the reviewers table and are mapped to the users table.\",\n        \"Find cycle_id for cycle named 'Fall 2026'.\",\n        \"Find all submissions in this cycle with status 'In Review'.\",\n        \"For each such submission, check if there are exactly two review_assignments to the above reviewers.\",\n        \"For each assignment, ensure assigned reviewer organization does not match applicant organization.\",\n        \"Ensure no extra assignments, missing assignments, or assignments to wrong reviewers.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    # Defensive DB querying\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # Reviewer setup: get reviewer user_ids, names, organization_ids from 'users'\\n    reviewer_names = ['Dr. Maya Chen', 'Alex Rivera', 'Priya Nair']\\n    reviewer_data = safe_query(final_db_path, \\\"SELECT id, full_name, organization_id FROM users WHERE full_name IN (?, ?, ?)\\\", tuple(reviewer_names))\\n    if len(reviewer_data) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    user_id_map = {row[1]: row[0] for row in reviewer_data}\\n    org_map = {row[1]: row[2] for row in reviewer_data}\\n    # Reviewer user_ids\\n    reviewer_user_ids = [user_id_map[n] for n in reviewer_names if n in user_id_map]\\n    # Confirm all reviewers are present\\n    if len(reviewer_user_ids) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Get reviewer ids from reviewers table (user_id -> reviewer_id)\\n    reviewer_id_rows = safe_query(final_db_path, \\\"SELECT id, user_id FROM reviewers WHERE user_id IN (?, ?, ?)\\\", tuple(reviewer_user_ids))\\n    if len(reviewer_id_rows) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    user_to_reviewer_id = {row[1]: row[0] for row in reviewer_id_rows}\\n    reviewer_ids = [user_to_reviewer_id[uid] for uid in reviewer_user_ids if uid in user_to_reviewer_id]\\n    if len(reviewer_ids) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find cycle_id for 'Fall 2026'\\n    cycle = safe_query(final_db_path, \\\"SELECT id FROM cycles WHERE name = ?\\\", (\\\"Fall 2026\\\",))\\n    if not cycle or not cycle[0] or cycle[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    cycle_id = cycle[0][0]\\n    # Find all 'In Review' submissions for this cycle\\n    submissions_rows = safe_query(final_db_path, \\\"SELECT id, applicant_user_id FROM submissions WHERE cycle_id = ? AND status = ?\\\", (cycle_id, \\\"In Review\\\"))\\n    if not submissions_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    in_review_submission_ids = [row[0] for row in submissions_rows]\\n    submission_applicant_map = {row[0]: row[1] for row in submissions_rows}\\n    # Get applicant organizations\\n    applicant_org_map = {}\\n    for sid, applicant_uid in submission_applicant_map.items():\\n        org_rows = safe_query(final_db_path, \\\"SELECT organization_id FROM users WHERE id = ?\\\", (applicant_uid,))\\n        applicant_org_map[sid] = org_rows[0][0] if org_rows and org_rows[0] else None\\n    # Get review assignments for these submissions in this cycle\\n    assignments = safe_query(final_db_path, \\n        f\\\"SELECT submission_id, reviewer_id FROM review_assignments WHERE cycle_id = ? AND submission_id IN ({','.join(['?']*len(in_review_submission_ids))})\\\",\\n        (cycle_id, *in_review_submission_ids) if in_review_submission_ids else (cycle_id,)\\n    )\\n    # Organize assignments per submission\\n    assignments_per_submission = {}\\n    for row in assignments:\\n        sid, reviewer_id = row\\n        if sid not in assignments_per_submission:\\n            assignments_per_submission[sid] = []\\n        assignments_per_submission[sid].append(reviewer_id)\\n    # For each submission, check:\\n    for sid in in_review_submission_ids:\\n        assigned_reviewers = assignments_per_submission.get(sid, [])\\n        # Exactly two reviewers\\n        if len(assigned_reviewers) != 2:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # Both reviewers are in the correct set\\n        for rev_id in assigned_reviewers:\\n            if rev_id not in reviewer_ids:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        # No organization conflict with applicant\\n        applicant_org = applicant_org_map.get(sid)\\n        for rev_id in assigned_reviewers:\\n            # Find reviewer user_id\\n            reviewer_user_id_row = safe_query(final_db_path, \\\"SELECT user_id FROM reviewers WHERE id = ?\\\", (rev_id,))\\n            reviewer_user_id = reviewer_user_id_row[0][0] if reviewer_user_id_row and reviewer_user_id_row[0] else None\\n            if reviewer_user_id is None:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            reviewer_org_row = safe_query(final_db_path, \\\"SELECT organization_id FROM users WHERE id = ?\\\", (reviewer_user_id,))\\n            reviewer_org = reviewer_org_row[0][0] if reviewer_org_row and reviewer_org_row[0] else None\\n            # If applicant_org or reviewer_org is missing, cannot pass\\n            if applicant_org is None or reviewer_org is None:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if reviewer_org == applicant_org:\\n                return {\\\"result\\\": \\\"others\\\"}\\n    # Additional check: ensure no extra assignments for these submissions to other reviewers\\n    for sid in assignments_per_submission:\\n        assigned_reviewers = assignments_per_submission[sid]\\n        if set(assigned_reviewers) - set(reviewer_ids):\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Check for extra reviewers assigned to 'In Review' submissions by diff\\n    # Check that initial_db_path didn't have these assignments\\n    # Optionally: If initial assignments were present, ensure they were fully overwritten (i.e., by the correct set, but since the task is 'create & assign', we only check final state)\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 7, "task": "Create a scoring rubric named \"Research Potential v1\" with criteria: \"Feasibility\" (0-5), \"Impact\" (0-5), \"Clarity\" (0-5) and require an overall comment, then attach it to the review stage for cycle \"Fall 2026\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper for read-only, returns list of dicts\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\n            conn.row_factory = sqlite3.Row\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = [dict(row) for row in cur.fetchall()]\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Check that the rubric is new (not in initial) and meets spec in final\n    rubric_name = 'Research Potential v1'\n    # Check if the rubric exists in initial db\n    initial_rubric = safe_query(\n        initial_db_path,\n        'SELECT id FROM rubrics WHERE name = ?',\n        (rubric_name,)\n    )\n    if initial_rubric:\n        # Already existed, cannot be task completion\n        return {\"result\": \"others\"}\n\n    # Now find the rubric in the final DB\n    final_rubrics = safe_query(\n        final_db_path,\n        'SELECT id, require_overall_comment FROM rubrics WHERE name = ?',\n        (rubric_name,)\n    )\n    if len(final_rubrics) != 1:\n        # Must be exactly one\n        return {\"result\": \"others\"}\n    rubric_id = final_rubrics[0]['id']\n    require_overall_comment = final_rubrics[0]['require_overall_comment']\n    if require_overall_comment != 1:\n        return {\"result\": \"others\"}\n\n    # 2. Check the criteria\n    criteria_rows = safe_query(\n        final_db_path,\n        'SELECT name, min_score, max_score FROM rubric_criteria WHERE rubric_id = ? ORDER BY criterion_order',\n        (rubric_id,)\n    )\n    # Should be exactly three with exact names/values\n    expected_criteria = [\n        {\"name\": \"Feasibility\", \"min_score\": 0, \"max_score\": 5},\n        {\"name\": \"Impact\", \"min_score\": 0, \"max_score\": 5},\n        {\"name\": \"Clarity\", \"min_score\": 0, \"max_score\": 5}\n    ]\n    if len(criteria_rows) != 3:\n        return {\"result\": \"others\"}\n    for expected in expected_criteria:\n        found = False\n        for row in criteria_rows:\n            if (row['name'] == expected['name'] and\n                row['min_score'] == expected['min_score'] and\n                row['max_score'] == expected['max_score']):\n                found = True\n                break\n        if not found:\n            return {\"result\": \"others\"}\n    # Also ensure no extra criteria: set names must match\n    names_in_db = set([row['name'] for row in criteria_rows])\n    expected_names = set([c['name'] for c in expected_criteria])\n    if names_in_db != expected_names:\n        return {\"result\": \"others\"}\n\n    # 3. Check that the rubric is attached to the 'Review' stage for cycle 'Fall 2026'\n    # Find cycle id for 'Fall 2026' in final db\n    fall_cycle = safe_query(final_db_path, 'SELECT id FROM cycles WHERE name = ?', ('Fall 2026',))\n    if len(fall_cycle) != 1:\n        return {\"result\": \"others\"}\n    cycle_id = fall_cycle[0]['id']\n\n    # Find the Review stage for this cycle\n    review_stage = safe_query(\n        final_db_path,\n        'SELECT id FROM cycle_stages WHERE cycle_id = ? AND name = ?',\n        (cycle_id, 'Review')\n    )\n    if len(review_stage) != 1:\n        return {\"result\": \"others\"}\n    review_stage_id = review_stage[0]['id']\n\n    # Ensure that this stage_rubrics entry did NOT exist prior\n    initial_stage_rubric = safe_query(\n        initial_db_path,\n        'SELECT id FROM stage_rubrics WHERE cycle_stage_id = ?',\n        (review_stage_id,)\n    )\n    # (Edge: The same stage id may not exist if cycle .id values were different; but here, they do not exist before as cycle 'Fall 2026' did not exist previously)\n    # There is no stage for Fall 2026 in initial, so this is a new attachment as long as exists in final.\n    # But to be absolutely safe, lookup by stage name/cycle name, not just id\n    # Sanity: confirm stage_stages for 'Fall 2026' and 'Review' stage in initial DB yields nothing\n    any_prior = safe_query(\n        initial_db_path,\n        'SELECT cs.id FROM cycle_stages cs JOIN cycles c ON c.id = cs.cycle_id WHERE c.name = ? AND cs.name = ?',\n        ('Fall 2026', 'Review')\n    )\n    if any_prior:\n        return {\"result\": \"others\"}\n\n    # Now in final DB, is the correct stage_rubrics entry there?\n    stage_rubrics_rows = safe_query(\n        final_db_path,\n        'SELECT id, rubric_id FROM stage_rubrics WHERE cycle_stage_id = ?',\n        (review_stage_id,)\n    )\n    if len(stage_rubrics_rows) != 1:\n        # Must be exactly one\n        return {\"result\": \"others\"}\n    if stage_rubrics_rows[0]['rubric_id'] != rubric_id:\n        return {\"result\": \"others\"}\n\n    # No extra 'Review' stage_rubric for Fall 2026\n    # (since cycle_stage_id is unique in stage_rubrics by schema)\n    # Is there any other rubric linked to the Review stage for Fall 2026? (already checked: only one, and it's correct)\n\n    # Everything accounted for\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify successful completion of the task, we need to deterministically confirm ALL of the following by directly comparing the initial and final database states: 1) A rubric named 'Research Potential v1' has been added to the rubrics table. 2) This rubric has exactly three criteria: 'Feasibility', 'Impact', and 'Clarity', each with a min_score of 0 and max_score of 5. 3) The rubric is configured to require an overall comment (require_overall_comment=1). 4) The rubric is attached to the 'Review' stage (cycle_stages.name = 'Review') of the cycle named 'Fall 2026', via an entry in stage_rubrics, properly referencing the correct cycle_stage and rubric. For each of these, we must check relationships: the rubric must not exist in the initial DB, and it must exist as specified in the final DB with all links and values correct. Any missing, extra, or mismatched data, or any uncertainty or initial state ambiguity, must result in a non-complete output. The final_answer is not used for modification-only tasks.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Rubric 'Research Potential v1' does NOT exist in initial DB; it exists in final DB.\",\n        \"Rubric in final DB has require_overall_comment=1.\",\n        \"Exactly three criteria are attached to the new rubric: 'Feasibility', 'Impact', 'Clarity', (names match exactly, case-sensitive), each with min_score=0, max_score=5.\",\n        \"No extra/missing criteria are present for this rubric.\",\n        \"The rubric is attached via stage_rubrics to the cycle_stage representing the 'Review' stage of cycle 'Fall 2026' (use cycles and cycle_stages table to match both).\",\n        \"No other rubric is attached to the Review stage for Fall 2026 (one-to-one mapping).\",\n        \"All foreign key relationships are valid and the operation is not ambiguous.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper for read-only, returns list of dicts\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\\n            conn.row_factory = sqlite3.Row\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = [dict(row) for row in cur.fetchall()]\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Check that the rubric is new (not in initial) and meets spec in final\\n    rubric_name = 'Research Potential v1'\\n    # Check if the rubric exists in initial db\\n    initial_rubric = safe_query(\\n        initial_db_path,\\n        'SELECT id FROM rubrics WHERE name = ?',\\n        (rubric_name,)\\n    )\\n    if initial_rubric:\\n        # Already existed, cannot be task completion\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Now find the rubric in the final DB\\n    final_rubrics = safe_query(\\n        final_db_path,\\n        'SELECT id, require_overall_comment FROM rubrics WHERE name = ?',\\n        (rubric_name,)\\n    )\\n    if len(final_rubrics) != 1:\\n        # Must be exactly one\\n        return {\\\"result\\\": \\\"others\\\"}\\n    rubric_id = final_rubrics[0]['id']\\n    require_overall_comment = final_rubrics[0]['require_overall_comment']\\n    if require_overall_comment != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Check the criteria\\n    criteria_rows = safe_query(\\n        final_db_path,\\n        'SELECT name, min_score, max_score FROM rubric_criteria WHERE rubric_id = ? ORDER BY criterion_order',\\n        (rubric_id,)\\n    )\\n    # Should be exactly three with exact names/values\\n    expected_criteria = [\\n        {\\\"name\\\": \\\"Feasibility\\\", \\\"min_score\\\": 0, \\\"max_score\\\": 5},\\n        {\\\"name\\\": \\\"Impact\\\", \\\"min_score\\\": 0, \\\"max_score\\\": 5},\\n        {\\\"name\\\": \\\"Clarity\\\", \\\"min_score\\\": 0, \\\"max_score\\\": 5}\\n    ]\\n    if len(criteria_rows) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    for expected in expected_criteria:\\n        found = False\\n        for row in criteria_rows:\\n            if (row['name'] == expected['name'] and\\n                row['min_score'] == expected['min_score'] and\\n                row['max_score'] == expected['max_score']):\\n                found = True\\n                break\\n        if not found:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Also ensure no extra criteria: set names must match\\n    names_in_db = set([row['name'] for row in criteria_rows])\\n    expected_names = set([c['name'] for c in expected_criteria])\\n    if names_in_db != expected_names:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Check that the rubric is attached to the 'Review' stage for cycle 'Fall 2026'\\n    # Find cycle id for 'Fall 2026' in final db\\n    fall_cycle = safe_query(final_db_path, 'SELECT id FROM cycles WHERE name = ?', ('Fall 2026',))\\n    if len(fall_cycle) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    cycle_id = fall_cycle[0]['id']\\n\\n    # Find the Review stage for this cycle\\n    review_stage = safe_query(\\n        final_db_path,\\n        'SELECT id FROM cycle_stages WHERE cycle_id = ? AND name = ?',\\n        (cycle_id, 'Review')\\n    )\\n    if len(review_stage) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    review_stage_id = review_stage[0]['id']\\n\\n    # Ensure that this stage_rubrics entry did NOT exist prior\\n    initial_stage_rubric = safe_query(\\n        initial_db_path,\\n        'SELECT id FROM stage_rubrics WHERE cycle_stage_id = ?',\\n        (review_stage_id,)\\n    )\\n    # (Edge: The same stage id may not exist if cycle .id values were different; but here, they do not exist before as cycle 'Fall 2026' did not exist previously)\\n    # There is no stage for Fall 2026 in initial, so this is a new attachment as long as exists in final.\\n    # But to be absolutely safe, lookup by stage name/cycle name, not just id\\n    # Sanity: confirm stage_stages for 'Fall 2026' and 'Review' stage in initial DB yields nothing\\n    any_prior = safe_query(\\n        initial_db_path,\\n        'SELECT cs.id FROM cycle_stages cs JOIN cycles c ON c.id = cs.cycle_id WHERE c.name = ? AND cs.name = ?',\\n        ('Fall 2026', 'Review')\\n    )\\n    if any_prior:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Now in final DB, is the correct stage_rubrics entry there?\\n    stage_rubrics_rows = safe_query(\\n        final_db_path,\\n        'SELECT id, rubric_id FROM stage_rubrics WHERE cycle_stage_id = ?',\\n        (review_stage_id,)\\n    )\\n    if len(stage_rubrics_rows) != 1:\\n        # Must be exactly one\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if stage_rubrics_rows[0]['rubric_id'] != rubric_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # No extra 'Review' stage_rubric for Fall 2026\\n    # (since cycle_stage_id is unique in stage_rubrics by schema)\\n    # Is there any other rubric linked to the Review stage for Fall 2026? (already checked: only one, and it's correct)\\n\\n    # Everything accounted for\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 8, "task": "For submission ID \"SUB-1042\", record reviewer \"Dr. Maya Chen\" scores Feasibility=4, Impact=5, Clarity=3 with the comment \"Strong idea; budget needs more detail\", flag a conflict of interest as \"None\", and advance the submission to status \"Shortlisted\" if the average score is at least 4.0.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Safe DB query helper\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Find the submission_id for 'SUB-1042' in both DBs\n    sub_row_init = safe_query(initial_db_path, \"SELECT id, status FROM submissions WHERE submission_code=?\", (\"SUB-1042\",))\n    sub_row_final = safe_query(final_db_path, \"SELECT id, status FROM submissions WHERE submission_code=?\", (\"SUB-1042\",))\n    if len(sub_row_init)!=1 or len(sub_row_final)!=1:\n        return {\"result\": \"others\"}\n    submission_id = sub_row_init[0][0]\n    submission_id_f = sub_row_final[0][0]\n    if submission_id!=submission_id_f:\n        return {\"result\": \"others\"}\n    initial_status = sub_row_init[0][1]\n    final_status = sub_row_final[0][1]\n\n    # 2. Find Dr. Maya Chen's user_id, then reviewer_id\n    user_rows = safe_query(final_db_path, \"SELECT id FROM users WHERE full_name=?\", (\"Dr. Maya Chen\",))\n    if len(user_rows)!=1:\n        return {\"result\": \"others\"}\n    user_id = user_rows[0][0]\n    reviewer_rows = safe_query(final_db_path, \"SELECT id FROM reviewers WHERE user_id=?\", (user_id,))\n    if len(reviewer_rows)!=1:\n        return {\"result\": \"others\"}\n    reviewer_id = reviewer_rows[0][0]\n\n    # 3. Find rubric_id for the review stage (application cycle), or get most recent relevant rubric\n    submission_cycle = safe_query(final_db_path, \"SELECT cycle_id FROM submissions WHERE id=?\", (submission_id,))\n    if len(submission_cycle)!=1:\n        return {\"result\": \"others\"}\n    cycle_id = submission_cycle[0][0]\n    # Find the review stage for this cycle\n    stage_row = safe_query(final_db_path, \"SELECT id FROM cycle_stages WHERE cycle_id=? AND name='Review'\", (cycle_id,))\n    if not stage_row:\n        return {\"result\": \"others\"}\n    review_stage_id = stage_row[0][0]\n    rubric_row = safe_query(final_db_path, \"SELECT rubric_id FROM stage_rubrics WHERE cycle_stage_id=?\", (review_stage_id,))\n    if not rubric_row:\n        return {\"result\": \"others\"}\n    rubric_id = rubric_row[0][0]\n\n    # 4. In FINAL DB, look for a new review row for this submission_id/reviewer_id/rubric_id\n    final_review_rows = safe_query(final_db_path, \"SELECT id, conflict_status, overall_comment FROM reviews WHERE submission_id=? AND reviewer_id=? AND rubric_id=?\", (submission_id, reviewer_id, rubric_id))\n    if len(final_review_rows)!=1:\n        return {\"result\": \"others\"}\n    review_id, conflict_status, overall_comment = final_review_rows[0]\n    # Must be new (not present in initial DB)\n    init_review_rows = safe_query(initial_db_path, \"SELECT id FROM reviews WHERE submission_id=? AND reviewer_id=? AND rubric_id=?\", (submission_id, reviewer_id, rubric_id))\n    if init_review_rows:\n        return {\"result\": \"others\"}\n    # Check conflict_status and comment\n    if conflict_status != \"None\":\n        return {\"result\": \"others\"}\n    if overall_comment != \"Strong idea; budget needs more detail\":\n        return {\"result\": \"others\"}\n\n    # 5. The task requires Feasibility=4, Impact=5, Clarity=3 scores. Map these to criterion_ids.\n    # Find all criteria for the rubric\n    crit_rows = safe_query(final_db_path, \"SELECT id, name FROM rubric_criteria WHERE rubric_id=?\", (rubric_id,))\n    # Case-insensitive mapping for flexibility\n    crit_map = {row[1].lower(): row[0] for row in crit_rows}\n    req_scores = {\n        \"feasibility\": 4,\n        \"impact\": 5,\n        \"clarity\": 3\n    }\n    for name in req_scores.keys():\n        if name not in crit_map:\n            return {\"result\": \"others\"}\n    # There must be exactly 3 criterion_ids for these names\n    required_crit_ids = [crit_map[\"feasibility\"], crit_map[\"impact\"], crit_map[\"clarity\"]]\n    \n    # Now check that exactly the matching scores are present\n    review_scores_rows = safe_query(final_db_path, \"SELECT criterion_id, score FROM review_scores WHERE review_id=?\", (review_id,))\n    if len(review_scores_rows) != 3:\n        return {\"result\": \"others\"}\n    score_check = {\"feasibility\": None, \"impact\": None, \"clarity\": None}\n    remaining_crit_ids = set(required_crit_ids)\n    for criterion_id, score in review_scores_rows:\n        found = False\n        for k, cid in crit_map.items():\n            if cid == criterion_id:\n                if k in score_check:\n                    score_check[k] = score\n                    found = True\n                else:\n                    return {\"result\": \"others\"}\n        if not found:\n            return {\"result\": \"others\"}\n        if criterion_id not in remaining_crit_ids:\n            return {\"result\": \"others\"}  # Extra/unexpected criterion\n        remaining_crit_ids.remove(criterion_id)\n    if any(score_check[k] != req_scores[k] for k in req_scores):\n        return {\"result\": \"others\"}\n\n    # 6. Calculate average\n    avg = (req_scores[\"feasibility\"] + req_scores[\"impact\"] + req_scores[\"clarity\"]) / 3.0\n\n    # 7. Submission status logic\n    if avg >= 4.0:\n        if final_status != \"Shortlisted\":\n            return {\"result\": \"others\"}\n    else:\n        if final_status == \"Shortlisted\":\n            return {\"result\": \"others\"}\n\n    # If we pass all checks above, it's a 100% certain completion\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task requires the agent to (1) record a review for submission SUB-1042 by Dr. Maya Chen with specific scores (Feasibility=4, Impact=5, Clarity=3), a particular comment and no conflict, and (2) advance the submission to 'Shortlisted' ONLY if the average of those scores is at least 4.0. All data must be verified in the final DB, and data lookup must establish IDs for relevant entities. The review must include the specified conflict status and comment, and the submission's status must reflect advancement (conditional on the average score). The function must ensure all changes are limited strictly to the requirements, and not accept partial or incorrect completion.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Locate submission with submission_code = 'SUB-1042' in both DBs; get the corresponding submission_id.\",\n        \"Check for user_id of 'Dr. Maya Chen' and ensure she is a reviewer; get reviewer_id.\",\n        \"Find matching rubric used for the review assignment.\",\n        \"In FINAL DB, ensure there is a new reviews record for this submission_id, reviewer_id, rubric_id, with conflict_status = 'None', and overall_comment equal to the required string. The review must not exist in the initial DB.\",\n        \"Check that review_scores for this review_id record EXACTLY the required scores for Feasibility=4, Impact=5, Clarity=3, matching only those criteria (and no extra criteria), and that each links to the correct criterion_id (by order/name).\",\n        \"Compute average of scores (should be (4+5+3)/3 = 4.0) and check if it is at least 4.0.\",\n        \"If average >= 4.0, submission status in FINAL DB must be 'Shortlisted' (and must be different than before, unless it was already Shortlisted in initial DB).\",\n        \"If average < 4.0, submission status in FINAL DB must NOT be 'Shortlisted'.\",\n        \"Require no missing or ambiguous links, and all values must match exactly.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Safe DB query helper\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Find the submission_id for 'SUB-1042' in both DBs\\n    sub_row_init = safe_query(initial_db_path, \\\"SELECT id, status FROM submissions WHERE submission_code=?\\\", (\\\"SUB-1042\\\",))\\n    sub_row_final = safe_query(final_db_path, \\\"SELECT id, status FROM submissions WHERE submission_code=?\\\", (\\\"SUB-1042\\\",))\\n    if len(sub_row_init)!=1 or len(sub_row_final)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    submission_id = sub_row_init[0][0]\\n    submission_id_f = sub_row_final[0][0]\\n    if submission_id!=submission_id_f:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_status = sub_row_init[0][1]\\n    final_status = sub_row_final[0][1]\\n\\n    # 2. Find Dr. Maya Chen's user_id, then reviewer_id\\n    user_rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE full_name=?\\\", (\\\"Dr. Maya Chen\\\",))\\n    if len(user_rows)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    user_id = user_rows[0][0]\\n    reviewer_rows = safe_query(final_db_path, \\\"SELECT id FROM reviewers WHERE user_id=?\\\", (user_id,))\\n    if len(reviewer_rows)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    reviewer_id = reviewer_rows[0][0]\\n\\n    # 3. Find rubric_id for the review stage (application cycle), or get most recent relevant rubric\\n    submission_cycle = safe_query(final_db_path, \\\"SELECT cycle_id FROM submissions WHERE id=?\\\", (submission_id,))\\n    if len(submission_cycle)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    cycle_id = submission_cycle[0][0]\\n    # Find the review stage for this cycle\\n    stage_row = safe_query(final_db_path, \\\"SELECT id FROM cycle_stages WHERE cycle_id=? AND name='Review'\\\", (cycle_id,))\\n    if not stage_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    review_stage_id = stage_row[0][0]\\n    rubric_row = safe_query(final_db_path, \\\"SELECT rubric_id FROM stage_rubrics WHERE cycle_stage_id=?\\\", (review_stage_id,))\\n    if not rubric_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    rubric_id = rubric_row[0][0]\\n\\n    # 4. In FINAL DB, look for a new review row for this submission_id/reviewer_id/rubric_id\\n    final_review_rows = safe_query(final_db_path, \\\"SELECT id, conflict_status, overall_comment FROM reviews WHERE submission_id=? AND reviewer_id=? AND rubric_id=?\\\", (submission_id, reviewer_id, rubric_id))\\n    if len(final_review_rows)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    review_id, conflict_status, overall_comment = final_review_rows[0]\\n    # Must be new (not present in initial DB)\\n    init_review_rows = safe_query(initial_db_path, \\\"SELECT id FROM reviews WHERE submission_id=? AND reviewer_id=? AND rubric_id=?\\\", (submission_id, reviewer_id, rubric_id))\\n    if init_review_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check conflict_status and comment\\n    if conflict_status != \\\"None\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if overall_comment != \\\"Strong idea; budget needs more detail\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. The task requires Feasibility=4, Impact=5, Clarity=3 scores. Map these to criterion_ids.\\n    # Find all criteria for the rubric\\n    crit_rows = safe_query(final_db_path, \\\"SELECT id, name FROM rubric_criteria WHERE rubric_id=?\\\", (rubric_id,))\\n    # Case-insensitive mapping for flexibility\\n    crit_map = {row[1].lower(): row[0] for row in crit_rows}\\n    req_scores = {\\n        \\\"feasibility\\\": 4,\\n        \\\"impact\\\": 5,\\n        \\\"clarity\\\": 3\\n    }\\n    for name in req_scores.keys():\\n        if name not in crit_map:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # There must be exactly 3 criterion_ids for these names\\n    required_crit_ids = [crit_map[\\\"feasibility\\\"], crit_map[\\\"impact\\\"], crit_map[\\\"clarity\\\"]]\\n    \\n    # Now check that exactly the matching scores are present\\n    review_scores_rows = safe_query(final_db_path, \\\"SELECT criterion_id, score FROM review_scores WHERE review_id=?\\\", (review_id,))\\n    if len(review_scores_rows) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    score_check = {\\\"feasibility\\\": None, \\\"impact\\\": None, \\\"clarity\\\": None}\\n    remaining_crit_ids = set(required_crit_ids)\\n    for criterion_id, score in review_scores_rows:\\n        found = False\\n        for k, cid in crit_map.items():\\n            if cid == criterion_id:\\n                if k in score_check:\\n                    score_check[k] = score\\n                    found = True\\n                else:\\n                    return {\\\"result\\\": \\\"others\\\"}\\n        if not found:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if criterion_id not in remaining_crit_ids:\\n            return {\\\"result\\\": \\\"others\\\"}  # Extra/unexpected criterion\\n        remaining_crit_ids.remove(criterion_id)\\n    if any(score_check[k] != req_scores[k] for k in req_scores):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Calculate average\\n    avg = (req_scores[\\\"feasibility\\\"] + req_scores[\\\"impact\\\"] + req_scores[\\\"clarity\\\"]) / 3.0\\n\\n    # 7. Submission status logic\\n    if avg >= 4.0:\\n        if final_status != \\\"Shortlisted\\\":\\n            return {\\\"result\\\": \\\"others\\\"}\\n    else:\\n        if final_status == \\\"Shortlisted\\\":\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # If we pass all checks above, it's a 100% certain completion\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 0, "task": "Create a new digital product listing in my shop titled 'Minimalist Wedding Invitation Template (A5)', category 'Invitations', tags ['wedding','minimalist','editable','A5','printable'], price 12.00 USD, license 'personal use', auto-delivery enabled, and attach two files with metadata: 'invitation-template-canva-link.txt' (text/plain, 1 KB) and 'invitation-A5.pdf' (application/pdf, 2.4 MB).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Find listing_ids that are new in final_db\n    initial_listing_ids = set(row[0] for row in safe_query(initial_db_path, \"SELECT id FROM listings\"))\n    final_listings = safe_query(final_db_path, \"SELECT id, shop_id, title, category_id, base_price_amount, currency_code, fulfillment_type, status, removed_reason, removed_by_user_id, removed_at FROM listings\")\n    new_listing_rows = [row for row in final_listings if row[0] not in initial_listing_ids]\n    # 2. Among new listings, find one with exact title\n    found_listing = None\n    for row in new_listing_rows:\n        id, shop_id, title, category_id, price, currency, fulfillment, status, removed_reason, removed_by_user_id, removed_at = row\n        if title == 'Minimalist Wedding Invitation Template (A5)':\n            found_listing = row\n            break\n    if not found_listing:\n        return {\"result\": \"others\"}\n    id, shop_id, title, category_id, price, currency, fulfillment, status, removed_reason, removed_by_user_id, removed_at = found_listing\n    # 3. Verify shop, category, price, auto-delivery, status\n    if shop_id != 101:\n        return {\"result\": \"others\"}\n    if category_id != 1:\n        return {\"result\": \"others\"}\n    if price != 12.00:\n        return {\"result\": \"others\"}\n    if currency != 'USD':\n        return {\"result\": \"others\"}\n    if fulfillment != 'auto':\n        return {\"result\": \"others\"}\n    if status != 'active':\n        return {\"result\": \"others\"}\n    if removed_reason is not None or removed_by_user_id is not None or removed_at is not None:\n        return {\"result\": \"others\"}\n\n    # 4. Check listing_files for this listing\n    listing_files = safe_query(final_db_path, \"SELECT filename, mime_type, size_bytes FROM listing_files WHERE listing_id = ?\", (id,))\n    if len(listing_files) != 2:\n        return {\"result\": \"others\"}\n    files_expected = {\n        'invitation-template-canva-link.txt': ('text/plain', 1024),\n        'invitation-A5.pdf': ('application/pdf', 2516582)\n    }\n    files_matched = 0\n    used_files = set()\n    for file in listing_files:\n        fname, mime, size = file\n        if fname in files_expected:\n            exp_mime, exp_min_size = files_expected[fname]\n            # For size, allow +/- 3% for potential small encoding diffs\n            if mime == exp_mime and size >= exp_min_size * 0.97 and size <= exp_min_size * 1.03:\n                files_matched += 1\n                used_files.add(fname)\n    if files_matched != 2 or used_files != set(files_expected.keys()):\n        return {\"result\": \"others\"}\n\n    # 5. Confirm tags are exactly ['wedding','minimalist','editable','A5','printable']\n    # Get tag_ids for those names\n    tag_names = ['wedding','minimalist','editable','A5','printable']\n    tag_id_rows = safe_query(final_db_path, \"SELECT id, name FROM tags WHERE name IN (?,?,?,?,?)\", tuple(tag_names))\n    tag_name_to_id = {name:id for id,name in tag_id_rows}\n    if len(tag_name_to_id) != 5:\n        return {\"result\": \"others\"}\n    expected_tag_ids = set(tag_name_to_id.values())\n    # Get actual tag_ids for the listing\n    actual_tag_rows = safe_query(final_db_path, \"SELECT tag_id FROM listing_tags WHERE listing_id = ?\", (id,))\n    actual_tag_ids = set(row[0] for row in actual_tag_rows)\n    if actual_tag_ids != expected_tag_ids:\n        return {\"result\": \"others\"}\n    # Also ensure only those tags are present (no extras)\n    if len(actual_tag_ids) != 5:\n        return {\"result\": \"others\"}\n\n    # 6. Confirm license 'personal use' via variations/options\n    # Variant is stored in listing_variations and variation_options\n    variation_rows = safe_query(final_db_path, \"SELECT id, name FROM listing_variations WHERE listing_id = ?\", (id,))\n    found_license = False\n    for var_id, var_name in variation_rows:\n        if re.search(r'license', var_name, re.IGNORECASE):\n            opt_rows = safe_query(final_db_path, \"SELECT value FROM variation_options WHERE variation_id = ?\", (var_id,))\n            values = set([v[0].lower().strip() for v in opt_rows])\n            if 'personal' in values or 'personal use' in values:\n                found_license = True\n                break\n    # If there is NO license variation, or it does not contain 'personal', return others\n    if not found_license:\n        return {\"result\": \"others\"}\n\n    # 7. Passes all checks\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify whether the agent successfully created a new digital product listing in the shop with all specified properties, we must detect a new listing in the 'listings' table (not present in the initial_db) called 'Minimalist Wedding Invitation Template (A5)' with correct category, price, fulfillment_type, license, tags, and attached files with correct metadata. We must confirm tags and category are correct, ensure auto-delivery is enabled (fulfillment_type = 'auto'), price is exactly 12.00 USD, category matches 'Invitations', and check the license. The agent must have attached exactly two files: 'invitation-template-canva-link.txt' (text/plain, 1 KB) and 'invitation-A5.pdf' (application/pdf, 2.4 MB). We must ensure the listing is not removed or inactive. We also check the tag mapping and license (either via variations/options or another clear field). The listing must be for shop_id=101 (Minimal Studio Downloads). Edge cases: If multiple listings match, or any aspect is missing, improper, or ambiguous, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Detect a new row in 'listings' (not present in initial_db) with title exactly 'Minimalist Wedding Invitation Template (A5)'\",\n        \"Confirm listing has category 'Invitations' (category_id=1)\",\n        \"Confirm base_price_amount = 12.00, currency_code = 'USD'\",\n        \"Confirm fulfillment_type = 'auto' (auto-delivery enabled)\",\n        \"Confirm status = 'active', and removed fields are NULL\",\n        \"Confirm listing is in shop_id=101\",\n        \"Confirm there are exactly two files in 'listing_files' for this listing: 'invitation-template-canva-link.txt' (text/plain, size ~1024 bytes) and 'invitation-A5.pdf' (application/pdf, size ~2516582 bytes)\",\n        \"Confirm tags: must be ['wedding','minimalist','editable','A5','printable'] (map via tags table), and only those tags\",\n        \"Confirm license 'personal use': via variations/options or clear field (if ambiguity, must return 'others')\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Find listing_ids that are new in final_db\\n    initial_listing_ids = set(row[0] for row in safe_query(initial_db_path, \\\"SELECT id FROM listings\\\"))\\n    final_listings = safe_query(final_db_path, \\\"SELECT id, shop_id, title, category_id, base_price_amount, currency_code, fulfillment_type, status, removed_reason, removed_by_user_id, removed_at FROM listings\\\")\\n    new_listing_rows = [row for row in final_listings if row[0] not in initial_listing_ids]\\n    # 2. Among new listings, find one with exact title\\n    found_listing = None\\n    for row in new_listing_rows:\\n        id, shop_id, title, category_id, price, currency, fulfillment, status, removed_reason, removed_by_user_id, removed_at = row\\n        if title == 'Minimalist Wedding Invitation Template (A5)':\\n            found_listing = row\\n            break\\n    if not found_listing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    id, shop_id, title, category_id, price, currency, fulfillment, status, removed_reason, removed_by_user_id, removed_at = found_listing\\n    # 3. Verify shop, category, price, auto-delivery, status\\n    if shop_id != 101:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if category_id != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if price != 12.00:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if currency != 'USD':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if fulfillment != 'auto':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if status != 'active':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if removed_reason is not None or removed_by_user_id is not None or removed_at is not None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check listing_files for this listing\\n    listing_files = safe_query(final_db_path, \\\"SELECT filename, mime_type, size_bytes FROM listing_files WHERE listing_id = ?\\\", (id,))\\n    if len(listing_files) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    files_expected = {\\n        'invitation-template-canva-link.txt': ('text/plain', 1024),\\n        'invitation-A5.pdf': ('application/pdf', 2516582)\\n    }\\n    files_matched = 0\\n    used_files = set()\\n    for file in listing_files:\\n        fname, mime, size = file\\n        if fname in files_expected:\\n            exp_mime, exp_min_size = files_expected[fname]\\n            # For size, allow +/- 3% for potential small encoding diffs\\n            if mime == exp_mime and size >= exp_min_size * 0.97 and size <= exp_min_size * 1.03:\\n                files_matched += 1\\n                used_files.add(fname)\\n    if files_matched != 2 or used_files != set(files_expected.keys()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Confirm tags are exactly ['wedding','minimalist','editable','A5','printable']\\n    # Get tag_ids for those names\\n    tag_names = ['wedding','minimalist','editable','A5','printable']\\n    tag_id_rows = safe_query(final_db_path, \\\"SELECT id, name FROM tags WHERE name IN (?,?,?,?,?)\\\", tuple(tag_names))\\n    tag_name_to_id = {name:id for id,name in tag_id_rows}\\n    if len(tag_name_to_id) != 5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    expected_tag_ids = set(tag_name_to_id.values())\\n    # Get actual tag_ids for the listing\\n    actual_tag_rows = safe_query(final_db_path, \\\"SELECT tag_id FROM listing_tags WHERE listing_id = ?\\\", (id,))\\n    actual_tag_ids = set(row[0] for row in actual_tag_rows)\\n    if actual_tag_ids != expected_tag_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Also ensure only those tags are present (no extras)\\n    if len(actual_tag_ids) != 5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Confirm license 'personal use' via variations/options\\n    # Variant is stored in listing_variations and variation_options\\n    variation_rows = safe_query(final_db_path, \\\"SELECT id, name FROM listing_variations WHERE listing_id = ?\\\", (id,))\\n    found_license = False\\n    for var_id, var_name in variation_rows:\\n        if re.search(r'license', var_name, re.IGNORECASE):\\n            opt_rows = safe_query(final_db_path, \\\"SELECT value FROM variation_options WHERE variation_id = ?\\\", (var_id,))\\n            values = set([v[0].lower().strip() for v in opt_rows])\\n            if 'personal' in values or 'personal use' in values:\\n                found_license = True\\n                break\\n    # If there is NO license variation, or it does not contain 'personal', return others\\n    if not found_license:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. Passes all checks\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 1, "task": "Update my existing listing with SKU 'PLN-2024-009' by changing the title to 'Budget Planner Spreadsheet (Google Sheets + Excel)', adding the tag 'finance', setting the price to 9.50 USD, and enabling a commercial license variation priced at 19.00 USD.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Locate correct initial and final listing (by SKU)\n    initial_listing = safe_query(\n        initial_db_path,\n        \"SELECT id, title, base_price_amount, currency_code FROM listings WHERE sku = ?\",\n        (\"PLN-2024-009\",)\n    )\n    final_listing = safe_query(\n        final_db_path,\n        \"SELECT id, title, base_price_amount, currency_code FROM listings WHERE sku = ?\",\n        (\"PLN-2024-009\",)\n    )\n    if not initial_listing or not final_listing:\n        return {\"result\": \"others\"}\n    initial_id, _, _, _ = initial_listing[0]\n    final_id, final_title, final_price, final_currency = final_listing[0]\n    # Defensive: confirm IDs match (should never change, but double-check)\n    if initial_id != final_id:\n        return {\"result\": \"others\"}\n    listing_id = final_id\n    # 2. Title check\n    if final_title != 'Budget Planner Spreadsheet (Google Sheets + Excel)':\n        return {\"result\": \"others\"}\n    # 3. Price check\n    if not (isinstance(final_price, float) or isinstance(final_price, int)) or float(final_price) != 9.5:\n        return {\"result\": \"others\"}\n    if final_currency != 'USD':\n        return {\"result\": \"others\"}\n    # 4. Tag check for 'finance'\n    tag_rows = safe_query(final_db_path, \"SELECT id FROM tags WHERE LOWER(name) = 'finance'\")\n    if not tag_rows:\n        return {\"result\": \"others\"}\n    finance_tag_id = tag_rows[0][0]\n    tag_attach = safe_query(final_db_path, \"SELECT 1 FROM listing_tags WHERE listing_id = ? AND tag_id = ?\", (listing_id, finance_tag_id))\n    if not tag_attach:\n        return {\"result\": \"others\"}\n    # 5. License variation & Commercial option check\n    # Find the 'License' variation (case-insensitive) for this listing\n    lic_vars = safe_query(final_db_path, \"SELECT id FROM listing_variations WHERE listing_id = ? AND LOWER(name) = 'license'\", (listing_id,))\n    if not lic_vars:\n        return {\"result\": \"others\"}\n    lic_var_id = lic_vars[0][0]\n    # Look for 'Commercial' option under this variation, and check price_delta\n    commer_opts = safe_query(final_db_path, \"SELECT price_delta_amount FROM variation_options WHERE variation_id = ? AND LOWER(value) = 'commercial'\", (lic_var_id,))\n    if not commer_opts:\n        return {\"result\": \"others\"}\n    price_delta = commer_opts[0][0]\n    # The final price must be 19.0 = base 9.5 + commercial delta 9.5\n    # Accept only if float equals exactly 9.5 (not 25, 8, or any other price).\n    if not (isinstance(price_delta, float) or isinstance(price_delta, int)) or float(price_delta) != 9.5:\n        return {\"result\": \"others\"}\n    # All conditions met\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the agent fulfilled the modification task to update a listing with SKU 'PLN-2024-009' on Etsy, we require four things: (1) The row in 'listings' with this SKU must have its title changed to the exact new value, (2) price set to 9.50 USD, and (3) the listing must have the 'finance' tag added, and (4) a 'commercial' license variation must be present and enabled at an exact price of 19.00 USD. The tag and variation must be correctly related to this listing - i.e., a 'License' variation (if not already present) with a 'Commercial' option at the right price. All four conditions must be met. Any deviation, ambiguity, or partial fulfillment must result in 'others'. No checks on the free text response are required, only the database delta.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find the listing with SKU 'PLN-2024-009' in both initial and final DB. It must exist in both.\",\n        \"Listing's title in the final DB must be exactly 'Budget Planner Spreadsheet (Google Sheets + Excel)'.\",\n        \"Listing's base_price_amount in the final DB must be exactly 9.50 and currency_code 'USD'.\",\n        \"A tag named 'finance' must exist in 'tags', and 'listing_tags' must have a row associating this listing ID with the correct tag_id.\",\n        \"A 'License' variation must exist for this listing in 'listing_variations'. In 'variation_options' for this variation, there must exist a value 'Commercial' with price_delta_amount=9.50 (to reach a total of 19.00 price).\",\n        \"None of the four conditions above may fail or be ambiguous.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Locate correct initial and final listing (by SKU)\\n    initial_listing = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id, title, base_price_amount, currency_code FROM listings WHERE sku = ?\\\",\\n        (\\\"PLN-2024-009\\\",)\\n    )\\n    final_listing = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, title, base_price_amount, currency_code FROM listings WHERE sku = ?\\\",\\n        (\\\"PLN-2024-009\\\",)\\n    )\\n    if not initial_listing or not final_listing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_id, _, _, _ = initial_listing[0]\\n    final_id, final_title, final_price, final_currency = final_listing[0]\\n    # Defensive: confirm IDs match (should never change, but double-check)\\n    if initial_id != final_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    listing_id = final_id\\n    # 2. Title check\\n    if final_title != 'Budget Planner Spreadsheet (Google Sheets + Excel)':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 3. Price check\\n    if not (isinstance(final_price, float) or isinstance(final_price, int)) or float(final_price) != 9.5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if final_currency != 'USD':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 4. Tag check for 'finance'\\n    tag_rows = safe_query(final_db_path, \\\"SELECT id FROM tags WHERE LOWER(name) = 'finance'\\\")\\n    if not tag_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    finance_tag_id = tag_rows[0][0]\\n    tag_attach = safe_query(final_db_path, \\\"SELECT 1 FROM listing_tags WHERE listing_id = ? AND tag_id = ?\\\", (listing_id, finance_tag_id))\\n    if not tag_attach:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 5. License variation & Commercial option check\\n    # Find the 'License' variation (case-insensitive) for this listing\\n    lic_vars = safe_query(final_db_path, \\\"SELECT id FROM listing_variations WHERE listing_id = ? AND LOWER(name) = 'license'\\\", (listing_id,))\\n    if not lic_vars:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    lic_var_id = lic_vars[0][0]\\n    # Look for 'Commercial' option under this variation, and check price_delta\\n    commer_opts = safe_query(final_db_path, \\\"SELECT price_delta_amount FROM variation_options WHERE variation_id = ? AND LOWER(value) = 'commercial'\\\", (lic_var_id,))\\n    if not commer_opts:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    price_delta = commer_opts[0][0]\\n    # The final price must be 19.0 = base 9.5 + commercial delta 9.5\\n    # Accept only if float equals exactly 9.5 (not 25, 8, or any other price).\\n    if not (isinstance(price_delta, float) or isinstance(price_delta, int)) or float(price_delta) != 9.5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All conditions met\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 2, "task": "Create two variations for my listing 'Logo Kit Bundle' (listing ID 4812): variation 'License' with options 'Personal' (+$0) and 'Commercial' (+$25), and variation 'File Format' with options 'SVG', 'PNG', and 'EPS' (+$0 for each).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    # helper function to safely query DB\n    def safe_query(db_path: str, query: str, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            res = cursor.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n    # Listing: 'Logo Kit Bundle' (id=4812)\n    # Required variations/options (with price deltas):\n    variations_needed = {\n        'License': {\n            'options': {'Personal': 0.0, 'Commercial': 25.0}\n        },\n        'File Format': {\n            'options': {'SVG': 0.0, 'PNG': 0.0, 'EPS': 0.0}\n        }\n    }\n    # Step 1. Get all listing_variations for listing_id=4812 from FINAL DB\n    final_vars = safe_query(\n        final_db_path,\n        \"SELECT id, name FROM listing_variations WHERE listing_id = ?\",\n        (4812,)\n    )\n    if not final_vars or len(final_vars) < 2:\n        return {\"result\": \"others\"}\n    # Map name -> variation_id for 4812\n    var_name_to_id = {}\n    for vid, vname in final_vars:\n        if not isinstance(vname, str):\n            return {\"result\": \"others\"}\n        var_name_to_id[vname.strip()] = vid\n    # Check both required variations present\n    for vname in variations_needed:\n        if vname not in var_name_to_id:\n            return {\"result\": \"others\"}\n    # Step 2. Check their options (variation_options)\n    # For each, get all options for the variation_id in FINAL DB\n    for vname, vdetails in variations_needed.items():\n        vid = var_name_to_id[vname]\n        options = safe_query(\n            final_db_path,\n            \"SELECT value, price_delta_amount FROM variation_options WHERE variation_id = ?\",\n            (vid,)\n        )\n        # Map value -> price\n        option_map = {}\n        for val, price in options:\n            if not isinstance(val, str):\n                return {\"result\": \"others\"}\n            option_map[val.strip()] = price\n        # Exact number of options required:\n        if len(option_map) != len(vdetails['options']):\n            return {\"result\": \"others\"}\n        # Check each required option and price delta\n        for req_val, req_price in vdetails['options'].items():\n            if req_val not in option_map:\n                return {\"result\": \"others\"}\n            final_price = option_map[req_val]\n            # Defensive float check: allow 0.00 == 0\n            try:\n                if abs(float(final_price) - float(req_price)) > 0.01:\n                    return {\"result\": \"others\"}\n            except Exception:\n                return {\"result\": \"others\"}\n    # Step 3. Ensure no extraneous variations created for listing_id=4812\n    # (should only be two variations, no more than those required)\n    if len(final_vars) != len(variations_needed):\n        return {\"result\": \"others\"}\n    # Step 4. Ensure no extraneous option values for each variation\n    for vname, vdetails in variations_needed.items():\n        vid = var_name_to_id[vname]\n        options = safe_query(\n            final_db_path,\n            \"SELECT value FROM variation_options WHERE variation_id = ?\",\n            (vid,)\n        )\n        option_vals = set(val.strip() for val, in options if isinstance(val, str))\n        required_vals = set(vdetails['options'].keys())\n        if option_vals != required_vals:\n            return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify if the agent completed the task of creating two variations ('License' and 'File Format') for the listing 'Logo Kit Bundle' (listing ID 4812) with precise options and pricing, we must compare the initial and final database states. The task is modification-based and requires: (1) Creation of a 'License' variation for listing 4812 with options 'Personal' (+$0) and 'Commercial' (+$25), (2) Creation of a 'File Format' variation for listing 4812 with options 'SVG', 'PNG', and 'EPS', each with $0 price delta. The checks must confirm that: both variations exist for listing 4812; all required options exist for each variation; price deltas are correctly set; and no extraneous items are created. All these are database checks; the final_answer is ignored. If any check fails, or we encounter ambiguity or missing/damaged data, we return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Check that listing_variations for listing_id=4812 include two variations: 'License' and 'File Format'\",\n        \"Ensure 'License' variation has options: 'Personal' (price_delta_amount=0) and 'Commercial' (price_delta_amount=25)\",\n        \"Ensure 'File Format' variation has options: 'SVG', 'PNG', 'EPS' (all price_delta_amount=0)\",\n        \"Confirm no extraneous variations/options created for listing_id=4812\",\n        \"Validate option values and price deltas exactly match requirements\",\n        \"Handle malformed, missing, or ambiguous database states gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    # helper function to safely query DB\\n    def safe_query(db_path: str, query: str, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            res = cursor.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n    # Listing: 'Logo Kit Bundle' (id=4812)\\n    # Required variations/options (with price deltas):\\n    variations_needed = {\\n        'License': {\\n            'options': {'Personal': 0.0, 'Commercial': 25.0}\\n        },\\n        'File Format': {\\n            'options': {'SVG': 0.0, 'PNG': 0.0, 'EPS': 0.0}\\n        }\\n    }\\n    # Step 1. Get all listing_variations for listing_id=4812 from FINAL DB\\n    final_vars = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, name FROM listing_variations WHERE listing_id = ?\\\",\\n        (4812,)\\n    )\\n    if not final_vars or len(final_vars) < 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Map name -> variation_id for 4812\\n    var_name_to_id = {}\\n    for vid, vname in final_vars:\\n        if not isinstance(vname, str):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        var_name_to_id[vname.strip()] = vid\\n    # Check both required variations present\\n    for vname in variations_needed:\\n        if vname not in var_name_to_id:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Step 2. Check their options (variation_options)\\n    # For each, get all options for the variation_id in FINAL DB\\n    for vname, vdetails in variations_needed.items():\\n        vid = var_name_to_id[vname]\\n        options = safe_query(\\n            final_db_path,\\n            \\\"SELECT value, price_delta_amount FROM variation_options WHERE variation_id = ?\\\",\\n            (vid,)\\n        )\\n        # Map value -> price\\n        option_map = {}\\n        for val, price in options:\\n            if not isinstance(val, str):\\n                return {\\\"result\\\": \\\"others\\\"}\\n            option_map[val.strip()] = price\\n        # Exact number of options required:\\n        if len(option_map) != len(vdetails['options']):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # Check each required option and price delta\\n        for req_val, req_price in vdetails['options'].items():\\n            if req_val not in option_map:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            final_price = option_map[req_val]\\n            # Defensive float check: allow 0.00 == 0\\n            try:\\n                if abs(float(final_price) - float(req_price)) > 0.01:\\n                    return {\\\"result\\\": \\\"others\\\"}\\n            except Exception:\\n                return {\\\"result\\\": \\\"others\\\"}\\n    # Step 3. Ensure no extraneous variations created for listing_id=4812\\n    # (should only be two variations, no more than those required)\\n    if len(final_vars) != len(variations_needed):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Step 4. Ensure no extraneous option values for each variation\\n    for vname, vdetails in variations_needed.items():\\n        vid = var_name_to_id[vname]\\n        options = safe_query(\\n            final_db_path,\\n            \\\"SELECT value FROM variation_options WHERE variation_id = ?\\\",\\n            (vid,)\\n        )\\n        option_vals = set(val.strip() for val, in options if isinstance(val, str))\\n        required_vals = set(vdetails['options'].keys())\\n        if option_vals != required_vals:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 3, "task": "Set an inventory rule for my listing ID 7720 so that the 'Commercial' license variation is limited to 50 total sales, while the 'Personal' license variation remains unlimited.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely get query results\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            res = cur.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n\n    # 1. Get License variation_id for listing 7720\n    lic_var = safe_query(\n        final_db_path,\n        \"SELECT id FROM listing_variations WHERE listing_id=? AND name=?\",\n        (7720, 'License'),\n    )\n    if not lic_var or not isinstance(lic_var[0][0], int):\n        return {'result': 'others'}\n    variation_id = lic_var[0][0]\n\n    # 2. Get 'Personal' and 'Commercial' option_ids\n    options = safe_query(\n        final_db_path,\n        \"SELECT value, id FROM variation_options WHERE variation_id=? AND (value=? OR value=?)\",\n        (variation_id, 'Personal', 'Commercial'),\n    )\n    option_map = {v: oid for v, oid in options}\n    if 'Personal' not in option_map or 'Commercial' not in option_map:\n        return {'result': 'others'}\n    personal_option_id = option_map['Personal']\n    commercial_option_id = option_map['Commercial']\n\n    # 3. Query inventory rules for listing 7720 and variation_id\n    final_rules = safe_query(\n        final_db_path,\n        \"SELECT option_id, max_total_sales FROM listing_inventory_rules WHERE listing_id=? AND variation_id=?\",\n        (7720, variation_id),\n    )\n\n    # 4. Build expected: Only two rules: one for 'Personal', one for 'Commercial' with correct settings\n    correct = {personal_option_id: None, commercial_option_id: 50}\n    seen = {}\n    for option_id, max_sales in final_rules:\n        if option_id == personal_option_id:\n            if max_sales is not None:\n                return {'result': 'others'} # 'Personal' must be unlimited\n            seen['Personal'] = True\n        elif option_id == commercial_option_id:\n            if max_sales != 50:\n                return {'result': 'others'} # 'Commercial' must be capped at 50\n            seen['Commercial'] = True\n        else:\n            # Any other option_id for this variation/rule set is not allowed\n            return {'result': 'others'}\n    # Each must be present once\n    if seen.get('Personal') != True or seen.get('Commercial') != True:\n        return {'result': 'others'}\n    if len(final_rules) != 2:\n        # No extra rules allowed\n        return {'result': 'others'}\n\n    # 5. Confirm these rules were absent or different in initial_db: i.e. at least one was missing or different\n    initial_rules = safe_query(\n        initial_db_path,\n        \"SELECT option_id, max_total_sales FROM listing_inventory_rules WHERE listing_id=? AND variation_id=?\",\n        (7720, variation_id),\n    )\n    found_correct_personal = False\n    found_correct_commercial = False\n    for option_id, max_sales in initial_rules:\n        if option_id == personal_option_id:\n            if max_sales is None:\n                found_correct_personal = True\n        if option_id == commercial_option_id:\n            if max_sales == 50:\n                found_correct_commercial = True\n    # If both rules *already* existed and were correct before, agent did nothing new!\n    if found_correct_personal and found_correct_commercial:\n        return {'result': 'others'}\n    # Otherwise, if at least one rule is new or changed as required, task is complete\n    return {'result': 'complete'}\n", "raw_response": "{\n    \"reasoning\": \"To verify if the agent set inventory rules on listing ID 7720 so that the 'Commercial' license variation is limited to 50 total sales and the 'Personal' license is unlimited, we must check the final database for exact inventory rule records. The rules relate to listing_inventory_rules, listing_variations, and variation_options. We must:\\n1) Ensure for listing_id=7720 and its 'License' variation, there is ONE rule for 'Commercial' with max_total_sales=50 and ONE rule for 'Personal' with max_total_sales=NULL (unlimited).\\n2) Ensure no other inventory limit rules were set for this listing's License variation.\\n3) Changes must be new compared to the initial DB: so, in initial DB, these rules either did not exist or were different. If any ambiguity or surplus rule, reject. No check on final_answer is required.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify the 'License' variation_id in listing_variations for listing_id 7720.\",\n        \"Identify 'Personal' and 'Commercial' option_ids for that variation.\",\n        \"In final DB: For 'Commercial', confirm exactly one listing_inventory_rules row with listing_id=7720, correct variation_id and option_id, max_total_sales=50.\",\n        \"In final DB: For 'Personal', confirm exactly one row as above but max_total_sales IS NULL (unlimited).\",\n        \"No extra listing_inventory_rules for this listing's License variation.\",\n        \"In initial DB: Confirm at least one of these rules was missing or different to ensure agent made the change.\",\n        \"Any failure, ambiguity, or uncertainty, result is 'others'.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely get query results\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            res = cur.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n\\n    # 1. Get License variation_id for listing 7720\\n    lic_var = safe_query(\\n        final_db_path,\\n        \\\"SELECT id FROM listing_variations WHERE listing_id=? AND name=?\\\",\\n        (7720, 'License'),\\n    )\\n    if not lic_var or not isinstance(lic_var[0][0], int):\\n        return {'result': 'others'}\\n    variation_id = lic_var[0][0]\\n\\n    # 2. Get 'Personal' and 'Commercial' option_ids\\n    options = safe_query(\\n        final_db_path,\\n        \\\"SELECT value, id FROM variation_options WHERE variation_id=? AND (value=? OR value=?)\\\",\\n        (variation_id, 'Personal', 'Commercial'),\\n    )\\n    option_map = {v: oid for v, oid in options}\\n    if 'Personal' not in option_map or 'Commercial' not in option_map:\\n        return {'result': 'others'}\\n    personal_option_id = option_map['Personal']\\n    commercial_option_id = option_map['Commercial']\\n\\n    # 3. Query inventory rules for listing 7720 and variation_id\\n    final_rules = safe_query(\\n        final_db_path,\\n        \\\"SELECT option_id, max_total_sales FROM listing_inventory_rules WHERE listing_id=? AND variation_id=?\\\",\\n        (7720, variation_id),\\n    )\\n\\n    # 4. Build expected: Only two rules: one for 'Personal', one for 'Commercial' with correct settings\\n    correct = {personal_option_id: None, commercial_option_id: 50}\\n    seen = {}\\n    for option_id, max_sales in final_rules:\\n        if option_id == personal_option_id:\\n            if max_sales is not None:\\n                return {'result': 'others'} # 'Personal' must be unlimited\\n            seen['Personal'] = True\\n        elif option_id == commercial_option_id:\\n            if max_sales != 50:\\n                return {'result': 'others'} # 'Commercial' must be capped at 50\\n            seen['Commercial'] = True\\n        else:\\n            # Any other option_id for this variation/rule set is not allowed\\n            return {'result': 'others'}\\n    # Each must be present once\\n    if seen.get('Personal') != True or seen.get('Commercial') != True:\\n        return {'result': 'others'}\\n    if len(final_rules) != 2:\\n        # No extra rules allowed\\n        return {'result': 'others'}\\n\\n    # 5. Confirm these rules were absent or different in initial_db: i.e. at least one was missing or different\\n    initial_rules = safe_query(\\n        initial_db_path,\\n        \\\"SELECT option_id, max_total_sales FROM listing_inventory_rules WHERE listing_id=? AND variation_id=?\\\",\\n        (7720, variation_id),\\n    )\\n    found_correct_personal = False\\n    found_correct_commercial = False\\n    for option_id, max_sales in initial_rules:\\n        if option_id == personal_option_id:\\n            if max_sales is None:\\n                found_correct_personal = True\\n        if option_id == commercial_option_id:\\n            if max_sales == 50:\\n                found_correct_commercial = True\\n    # If both rules *already* existed and were correct before, agent did nothing new!\\n    if found_correct_personal and found_correct_commercial:\\n        return {'result': 'others'}\\n    # Otherwise, if at least one rule is new or changed as required, task is complete\\n    return {'result': 'complete'}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 4, "task": "Create a coupon code 'SPRING20' that gives 20% off my entire shop, requires a minimum order subtotal of 15.00 USD, is valid from 2026-03-01 to 2026-03-31, and is limited to 200 redemptions.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper function to safely fetch rows\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    # Coupon details required\n    required_coupon = {\n        \"shop_id\": 101,\n        \"code\": \"SPRING20\",\n        \"discount_type\": \"percent\",\n        \"discount_value\": 20.0,\n        \"minimum_subtotal_amount\": 15.0,\n        \"currency_code\": \"USD\",\n        \"starts_at\": \"2026-03-01 00:00:00\",\n        \"ends_at\": \"2026-03-31 23:59:59\",\n        \"max_redemptions\": 200,\n        \"is_active\": 1\n    }\n    # Select all coupons with code SPRING20 for shop 101\n    coupon_query = \"\"\"\n        SELECT shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active\n        FROM coupons WHERE shop_id=? AND code=?\n    \"\"\"\n    initial_rows = safe_query(initial_db_path, coupon_query, (required_coupon[\"shop_id\"], required_coupon[\"code\"]))\n    final_rows = safe_query(final_db_path, coupon_query, (required_coupon[\"shop_id\"], required_coupon[\"code\"]))\n    # Must be exactly one new row matching all fields\n    # Defensive check: must be exactly one row in final, zero in initial\n    if len(final_rows) != 1:\n        return {\"result\": \"others\"}\n    if len(initial_rows) != 0:\n        return {\"result\": \"others\"}\n    final_row = final_rows[0]\n    # Compare all fields (shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active)\n    def safe_float(val):\n        try:\n            return float(val)\n        except Exception:\n            return None\n    def safe_int(val):\n        try:\n            return int(val)\n        except Exception:\n            return None\n    # Unpack final_row safely\n    (shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active) = final_row\n    # Validate field types and exact values\n    # Note: datetime comparison uses string equality as per DB format\n    checks = [\n        safe_int(shop_id) == required_coupon[\"shop_id\"],\n        str(code) == required_coupon[\"code\"],\n        str(discount_type) == required_coupon[\"discount_type\"],\n        safe_float(discount_value) == required_coupon[\"discount_value\"],\n        safe_float(minimum_subtotal_amount) == required_coupon[\"minimum_subtotal_amount\"],\n        str(currency_code) == required_coupon[\"currency_code\"],\n        str(starts_at) == required_coupon[\"starts_at\"],\n        str(ends_at) == required_coupon[\"ends_at\"],\n        safe_int(max_redemptions) == required_coupon[\"max_redemptions\"],\n        safe_int(is_active) == required_coupon[\"is_active\"]\n    ]\n    if not all(checks):\n        return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify the task 'Create a coupon code SPRING20 that gives 20% off my entire shop, requires a minimum order subtotal of 15.00 USD, is valid from 2026-03-01 to 2026-03-31, and is limited to 200 redemptions', we must ensure that the final database contains a new row in the coupons table for the shop (id=101) with code 'SPRING20', percent discount type, 20.0 discount value, minimum_subtotal_amount 15.00, currency USD, starts_at '2026-03-01 00:00:00', ends_at '2026-03-31 23:59:59', max_redemptions 200, is_active 1, and that this row did not exist in the initial database. We must ensure NO ambiguity: only return 'complete' if ALL details are exactly matched, no extras, and no partial changes. We must handle edge cases where fields are missing, misformatted, or if multiple coupons with code 'SPRING20' exist for the shop. No other action or text response is relevant for this modification task.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Verify that in final_db, coupons table contains exactly one new row (for shop_id=101) with code 'SPRING20', discount_type 'percent', discount_value 20.0, minimum_subtotal_amount 15.0, currency_code 'USD', starts_at '2026-03-01 00:00:00', ends_at '2026-03-31 23:59:59', max_redemptions 200, is_active 1\",\n        \"Ensure this row does NOT exist in initial_db (i.e., new creation)\",\n        \"Ensure no other 'SPRING20' coupons exist for shop_id=101\",\n        \"Validate all critical fields are present and correctly formatted\",\n        \"Handle edge cases: malformed fields, missing fields, duplicate rows\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper function to safely fetch rows\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    # Coupon details required\\n    required_coupon = {\\n        \\\"shop_id\\\": 101,\\n        \\\"code\\\": \\\"SPRING20\\\",\\n        \\\"discount_type\\\": \\\"percent\\\",\\n        \\\"discount_value\\\": 20.0,\\n        \\\"minimum_subtotal_amount\\\": 15.0,\\n        \\\"currency_code\\\": \\\"USD\\\",\\n        \\\"starts_at\\\": \\\"2026-03-01 00:00:00\\\",\\n        \\\"ends_at\\\": \\\"2026-03-31 23:59:59\\\",\\n        \\\"max_redemptions\\\": 200,\\n        \\\"is_active\\\": 1\\n    }\\n    # Select all coupons with code SPRING20 for shop 101\\n    coupon_query = \\\"\\\"\\\"\\n        SELECT shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active\\n        FROM coupons WHERE shop_id=? AND code=?\\n    \\\"\\\"\\\"\\n    initial_rows = safe_query(initial_db_path, coupon_query, (required_coupon[\\\"shop_id\\\"], required_coupon[\\\"code\\\"]))\\n    final_rows = safe_query(final_db_path, coupon_query, (required_coupon[\\\"shop_id\\\"], required_coupon[\\\"code\\\"]))\\n    # Must be exactly one new row matching all fields\\n    # Defensive check: must be exactly one row in final, zero in initial\\n    if len(final_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if len(initial_rows) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    final_row = final_rows[0]\\n    # Compare all fields (shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active)\\n    def safe_float(val):\\n        try:\\n            return float(val)\\n        except Exception:\\n            return None\\n    def safe_int(val):\\n        try:\\n            return int(val)\\n        except Exception:\\n            return None\\n    # Unpack final_row safely\\n    (shop_id, code, discount_type, discount_value, minimum_subtotal_amount, currency_code, starts_at, ends_at, max_redemptions, is_active) = final_row\\n    # Validate field types and exact values\\n    # Note: datetime comparison uses string equality as per DB format\\n    checks = [\\n        safe_int(shop_id) == required_coupon[\\\"shop_id\\\"],\\n        str(code) == required_coupon[\\\"code\\\"],\\n        str(discount_type) == required_coupon[\\\"discount_type\\\"],\\n        safe_float(discount_value) == required_coupon[\\\"discount_value\\\"],\\n        safe_float(minimum_subtotal_amount) == required_coupon[\\\"minimum_subtotal_amount\\\"],\\n        str(currency_code) == required_coupon[\\\"currency_code\\\"],\\n        str(starts_at) == required_coupon[\\\"starts_at\\\"],\\n        str(ends_at) == required_coupon[\\\"ends_at\\\"],\\n        safe_int(max_redemptions) == required_coupon[\\\"max_redemptions\\\"],\\n        safe_int(is_active) == required_coupon[\\\"is_active\\\"]\\n    ]\\n    if not all(checks):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 5, "task": "Put my listing ID 6633 on sale with 30% off for 72 hours starting at 2026-02-20T09:00:00Z, and ensure the sale does not stack with existing coupons.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Values required for verification\n    target_listing_id = 6633\n    expected_discount_type = 'percent'\n    expected_discount_value = 30.0\n    expected_start = '2026-02-20T09:00:00Z'\n    expected_end = '2026-02-23T09:00:00Z'\n    expected_stacking = 0\n    expected_active = 1\n    db_datetime_format = \"%Y-%m-%d %H:%M:%S\"\n    iso_dt_fmt = \"%Y-%m-%dT%H:%M:%SZ\"\n\n    # Convert ISO  DB format\n    def iso_to_db(iso_str):\n        try:\n            dt = datetime.strptime(iso_str, iso_dt_fmt)\n            return dt.strftime(db_datetime_format)\n        except Exception:\n            return None\n    db_expected_start = iso_to_db(expected_start)\n    db_expected_end = iso_to_db(expected_end)\n    if not db_expected_start or not db_expected_end:\n        return {\"result\": \"others\"}\n\n    # Find new sale covering listing 6633\n    initial_sale_listings = safe_query(initial_db_path, \"SELECT sale_id FROM sale_listings WHERE listing_id = ?\", (target_listing_id,))\n    final_sale_listings = safe_query(final_db_path, \"SELECT sale_id FROM sale_listings WHERE listing_id = ?\", (target_listing_id,))\n    initial_sale_ids = set([row[0] for row in initial_sale_listings])\n    final_sale_ids = set([row[0] for row in final_sale_listings])\n    new_sale_ids = final_sale_ids - initial_sale_ids\n    if not new_sale_ids or len(new_sale_ids) != 1:\n        return {\"result\": \"others\"}\n    sale_id = list(new_sale_ids)[0]\n\n    # Check sale parameters in final_db\n    sale_rows = safe_query(final_db_path, \"SELECT discount_type, discount_value, starts_at, ends_at, allow_coupon_stacking, is_active FROM sales WHERE id = ?\", (sale_id,))\n    if len(sale_rows) != 1:\n        return {\"result\": \"others\"}\n    (discount_type, discount_value, starts_at, ends_at, allow_coupon_stacking, is_active) = sale_rows[0]\n\n    # Verify discount type/value\n    try:\n        if discount_type != expected_discount_type:\n            return {\"result\": \"others\"}\n        if abs(float(discount_value) - expected_discount_value) > 1e-3:\n            return {\"result\": \"others\"}\n    except Exception:\n        return {\"result\": \"others\"}\n\n    # Verify dates (db should be UTC, no TZ; match ISO inputs)\n    if starts_at != db_expected_start or ends_at != db_expected_end:\n        return {\"result\": \"others\"}\n    \n    # Verify stacking disabled and sale is active\n    if allow_coupon_stacking != expected_stacking:\n        return {\"result\": \"others\"}\n    if is_active != expected_active:\n        return {\"result\": \"others\"}\n\n    # Ensure sale applies ONLY to 6633 (not other listings added in final_db)\n    sale_listing_rows = safe_query(final_db_path, \"SELECT listing_id FROM sale_listings WHERE sale_id = ?\", (sale_id,))\n    listing_ids_for_sale = set([row[0] for row in sale_listing_rows])\n    if listing_ids_for_sale != {target_listing_id}:\n        return {\"result\": \"others\"}\n\n    # Confirm no ambiguity: sale_id should not appear in initial_db for listing 6633\n    if sale_id in initial_sale_ids:\n        return {\"result\": \"others\"}\n    \n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the task, we need to confirm that listing ID 6633 was put on sale with a 30% discount for exactly 72 hours, starting at 2026-02-20T09:00:00Z. Additionally, coupon stacking must be disabled for the sale, ensuring that no existing coupons can be combined with this sale. This is a modification-based task because we need to check changes in the sales and sale_listings tables in the database. We must ensure no ambiguity: the sale must cover only listing 6633, have correct timing, percentage, stacking, and be active at creation. Edge cases include partial, overlapping, or misconfigured sales. If any requirement is not met or cannot be determined, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Check that listing_id 6633 is associated with a new sale in sale_listings in final_db (not present in initial_db)\",\n        \"Verify the sale in sales table in final_db has discount_type='percent', discount_value=30.0\",\n        \"Verify the sale starts at 2026-02-20T09:00:00Z and ends exactly 72 hours later (2026-02-23T09:00:00Z)\",\n        \"Verify allow_coupon_stacking=0 (no stacking with coupons)\",\n        \"Ensure sale is_active=1 and covers only the expected listing\",\n        \"Check that sale is properly configured (not partial, not ambiguous, not misconfigured)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Values required for verification\\n    target_listing_id = 6633\\n    expected_discount_type = 'percent'\\n    expected_discount_value = 30.0\\n    expected_start = '2026-02-20T09:00:00Z'\\n    expected_end = '2026-02-23T09:00:00Z'\\n    expected_stacking = 0\\n    expected_active = 1\\n    db_datetime_format = \\\"%Y-%m-%d %H:%M:%S\\\"\\n    iso_dt_fmt = \\\"%Y-%m-%dT%H:%M:%SZ\\\"\\n\\n    # Convert ISO  DB format\\n    def iso_to_db(iso_str):\\n        try:\\n            dt = datetime.strptime(iso_str, iso_dt_fmt)\\n            return dt.strftime(db_datetime_format)\\n        except Exception:\\n            return None\\n    db_expected_start = iso_to_db(expected_start)\\n    db_expected_end = iso_to_db(expected_end)\\n    if not db_expected_start or not db_expected_end:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Find new sale covering listing 6633\\n    initial_sale_listings = safe_query(initial_db_path, \\\"SELECT sale_id FROM sale_listings WHERE listing_id = ?\\\", (target_listing_id,))\\n    final_sale_listings = safe_query(final_db_path, \\\"SELECT sale_id FROM sale_listings WHERE listing_id = ?\\\", (target_listing_id,))\\n    initial_sale_ids = set([row[0] for row in initial_sale_listings])\\n    final_sale_ids = set([row[0] for row in final_sale_listings])\\n    new_sale_ids = final_sale_ids - initial_sale_ids\\n    if not new_sale_ids or len(new_sale_ids) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    sale_id = list(new_sale_ids)[0]\\n\\n    # Check sale parameters in final_db\\n    sale_rows = safe_query(final_db_path, \\\"SELECT discount_type, discount_value, starts_at, ends_at, allow_coupon_stacking, is_active FROM sales WHERE id = ?\\\", (sale_id,))\\n    if len(sale_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    (discount_type, discount_value, starts_at, ends_at, allow_coupon_stacking, is_active) = sale_rows[0]\\n\\n    # Verify discount type/value\\n    try:\\n        if discount_type != expected_discount_type:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if abs(float(discount_value) - expected_discount_value) > 1e-3:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Verify dates (db should be UTC, no TZ; match ISO inputs)\\n    if starts_at != db_expected_start or ends_at != db_expected_end:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Verify stacking disabled and sale is active\\n    if allow_coupon_stacking != expected_stacking:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if is_active != expected_active:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Ensure sale applies ONLY to 6633 (not other listings added in final_db)\\n    sale_listing_rows = safe_query(final_db_path, \\\"SELECT listing_id FROM sale_listings WHERE sale_id = ?\\\", (sale_id,))\\n    listing_ids_for_sale = set([row[0] for row in sale_listing_rows])\\n    if listing_ids_for_sale != {target_listing_id}:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Confirm no ambiguity: sale_id should not appear in initial_db for listing 6633\\n    if sale_id in initial_sale_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 7, "task": "For order ID 90517, change fulfillment status from 'manual' to 'fulfilled', add a private note 'Sent custom color variant via message on 2026-02-18', and send the buyer a message saying 'Hi! Your custom color variant is readythanks for your order; please reply if you need any tweaks.'", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    order_id = 90517\n    shop_id = 101\n    expected_private_note = 'Sent custom color variant via message on 2026-02-18'\n    expected_fulfillment_status = 'fulfilled'\n    expected_buyer_user_id = 4\n    expected_message_body = 'Hi! Your custom color variant is readythanks for your order; please reply if you need any tweaks.'\n\n    # --- 1. Check orders table update ---\n    initial_order = safe_query(\n        initial_db_path,\n        'SELECT id, shop_id, buyer_user_id, status, fulfillment_status, private_note FROM orders WHERE id = ?',\n        (order_id,)\n    )\n    final_order = safe_query(\n        final_db_path,\n        'SELECT id, shop_id, buyer_user_id, status, fulfillment_status, private_note FROM orders WHERE id = ?',\n        (order_id,)\n    )\n    if not initial_order or not final_order:\n        return {\"result\": \"others\"}\n    initial_order = initial_order[0]\n    final_order = final_order[0]\n    # Key field indices: 0-id, 1-shop_id, 2-buyer_user_id, 3-status, 4-fulfillment_status, 5-private_note\n    # Status must remain 'placed', fulfillment_status must change to 'fulfilled', private_note to exact string\n    if (\n        initial_order[4] != 'manual' or  # Initial must be 'manual'\n        initial_order[3] != 'placed' or  # Status must be placed at start\n        final_order[3] != 'placed'      # Status must stay 'placed'\n    ):\n        return {\"result\": \"others\"}\n    # Check fulfillment_status updated\n    if final_order[4] != expected_fulfillment_status:\n        return {\"result\": \"others\"}\n    # Check private_note updated exactly\n    if final_order[5] != expected_private_note:\n        return {\"result\": \"others\"}\n\n    # --- 2. Check message sent to buyer ---\n    # Get all initial messages for order 90517\n    initial_msgs = safe_query(\n        initial_db_path,\n        'SELECT id, order_id, shop_id, sender_user_id, recipient_user_id, body, is_private FROM messages WHERE order_id = ?',\n        (order_id,)\n    )\n    initial_msg_ids = set([row[0] for row in initial_msgs])\n    # Find all NEW messages on order 90517 in final_db\n    final_msgs = safe_query(\n        final_db_path,\n        'SELECT id, order_id, shop_id, sender_user_id, recipient_user_id, body, is_private FROM messages WHERE order_id = ?',\n        (order_id,)\n    )\n    new_msgs = [row for row in final_msgs if row[0] not in initial_msg_ids]\n    # There must be exactly one such new message, with exact match\n    matching_new_msgs = [row for row in new_msgs\n                         if row[2] == shop_id  # shop_id correct\n                         and row[4] == expected_buyer_user_id  # recipient_user_id correct\n                         and row[5] == expected_message_body  # body exact match\n                         and row[6] == 0  # is_private == 0 (not private)\n                        ]\n    if len(matching_new_msgs) != 1:\n        return {\"result\": \"others\"}\n\n    # --- 3. Ensure no duplicate message bodies are present (i.e., did not send multiple identical messages in this context)\n    # (There should be only one new matching message added with this body)\n    body_count = sum(1 for row in new_msgs if row[5] == expected_message_body)\n    if body_count != 1:\n        return {\"result\": \"others\"}\n\n    # --- 4. Defensive: Ensure all the above changes are ONLY for order 90517 (no unrelated extra field tampering in order record)\n    # The fields: status, buyer_user_id, shop_id, etc. must stay unchanged except fulfillment_status and private_note\n    for i, val in enumerate(initial_order):\n        if i in [4,5]:  # fulfillment_status, private_note\n            continue\n        if val != final_order[i]:\n            return {\"result\": \"others\"}\n    # (Other fields can be managed by platform, so only check these key ones)\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task requires updating a specific order (ID 90517) in three ways: (1) Change fulfillment status from 'manual' to 'fulfilled'. (2) Add a precise private note: 'Sent custom color variant via message on 2026-02-18'. (3) Send a message to the 'buyer' with a specific message body: 'Hi! Your custom color variant is readythanks for your order; please reply if you need any tweaks.'\\n\\nTo assert task completion, the final database state must contain ONLY these specific changes for order 90517 (compared to initial), and the values must be exact (case-sensitive, punctuation and spacing must match). The message must be sent to the correct recipient, referencing the correct order and from the shop (seller). All other fields must remain unchanged for this order (e.g., order status must not be changed or canceled, message must not be private, etc.). This is a modification-based verification, as no query information in final_answer is required.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Order 90517's fulfillment_status is changed from 'manual' to 'fulfilled'\",\n        \"Order 90517's private_note is exactly 'Sent custom color variant via message on 2026-02-18'\",\n        \"A new message linked to order 90517 exists (in final but not initial) with body 'Hi! Your custom color variant is readythanks for your order; please reply if you need any tweaks.'\",\n        \"The new message is not private (is_private == 0), and is sent from the seller (shop_id 101) to the buyer_user_id (user id 4)\",\n        \"No other changes were made to order 90517's key fields (status remains 'placed', fulfilled_at is okay to be set by platform)\",\n        \"No extra/unrelated modifications (no duplicate messages, only one matching message sent)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    order_id = 90517\\n    shop_id = 101\\n    expected_private_note = 'Sent custom color variant via message on 2026-02-18'\\n    expected_fulfillment_status = 'fulfilled'\\n    expected_buyer_user_id = 4\\n    expected_message_body = 'Hi! Your custom color variant is readythanks for your order; please reply if you need any tweaks.'\\n\\n    # --- 1. Check orders table update ---\\n    initial_order = safe_query(\\n        initial_db_path,\\n        'SELECT id, shop_id, buyer_user_id, status, fulfillment_status, private_note FROM orders WHERE id = ?',\\n        (order_id,)\\n    )\\n    final_order = safe_query(\\n        final_db_path,\\n        'SELECT id, shop_id, buyer_user_id, status, fulfillment_status, private_note FROM orders WHERE id = ?',\\n        (order_id,)\\n    )\\n    if not initial_order or not final_order:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_order = initial_order[0]\\n    final_order = final_order[0]\\n    # Key field indices: 0-id, 1-shop_id, 2-buyer_user_id, 3-status, 4-fulfillment_status, 5-private_note\\n    # Status must remain 'placed', fulfillment_status must change to 'fulfilled', private_note to exact string\\n    if (\\n        initial_order[4] != 'manual' or  # Initial must be 'manual'\\n        initial_order[3] != 'placed' or  # Status must be placed at start\\n        final_order[3] != 'placed'      # Status must stay 'placed'\\n    ):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check fulfillment_status updated\\n    if final_order[4] != expected_fulfillment_status:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check private_note updated exactly\\n    if final_order[5] != expected_private_note:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 2. Check message sent to buyer ---\\n    # Get all initial messages for order 90517\\n    initial_msgs = safe_query(\\n        initial_db_path,\\n        'SELECT id, order_id, shop_id, sender_user_id, recipient_user_id, body, is_private FROM messages WHERE order_id = ?',\\n        (order_id,)\\n    )\\n    initial_msg_ids = set([row[0] for row in initial_msgs])\\n    # Find all NEW messages on order 90517 in final_db\\n    final_msgs = safe_query(\\n        final_db_path,\\n        'SELECT id, order_id, shop_id, sender_user_id, recipient_user_id, body, is_private FROM messages WHERE order_id = ?',\\n        (order_id,)\\n    )\\n    new_msgs = [row for row in final_msgs if row[0] not in initial_msg_ids]\\n    # There must be exactly one such new message, with exact match\\n    matching_new_msgs = [row for row in new_msgs\\n                         if row[2] == shop_id  # shop_id correct\\n                         and row[4] == expected_buyer_user_id  # recipient_user_id correct\\n                         and row[5] == expected_message_body  # body exact match\\n                         and row[6] == 0  # is_private == 0 (not private)\\n                        ]\\n    if len(matching_new_msgs) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 3. Ensure no duplicate message bodies are present (i.e., did not send multiple identical messages in this context)\\n    # (There should be only one new matching message added with this body)\\n    body_count = sum(1 for row in new_msgs if row[5] == expected_message_body)\\n    if body_count != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 4. Defensive: Ensure all the above changes are ONLY for order 90517 (no unrelated extra field tampering in order record)\\n    # The fields: status, buyer_user_id, shop_id, etc. must stay unchanged except fulfillment_status and private_note\\n    for i, val in enumerate(initial_order):\\n        if i in [4,5]:  # fulfillment_status, private_note\\n            continue\\n        if val != final_order[i]:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # (Other fields can be managed by platform, so only check these key ones)\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 8, "task": "Issue a partial refund of 6.00 USD on order ID 89110 with reason 'File duplicated in bundle', and record the platform fee adjustment if applicable.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    TASK_ORDER_ID = 89110\n    TASK_AMOUNT = 6.0\n    TASK_REASON_EXPECTED = 'File duplicated in bundle'\n    TASK_CURRENCY = 'USD'\n\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Helper: Find related refund records\n    def find_refunds(db_path):\n        rows = safe_query(\n            db_path,\n            \"SELECT id, order_id, amount, currency_code, reason, platform_fee_adjustment_amount FROM refunds WHERE order_id=?\",\n            (TASK_ORDER_ID,)\n        )\n        refund_records = []\n        for r in rows:\n            refund_id, order_id, amount, currency_code, reason, platform_fee_adj = r\n            # Defensive: all fields must be present and non-NULL\n            if (\n                refund_id is not None and\n                order_id is not None and\n                amount is not None and\n                currency_code is not None and\n                reason is not None and\n                platform_fee_adj is not None\n            ):\n                refund_records.append({\n                    \"id\": refund_id,\n                    \"order_id\": order_id,\n                    \"amount\": amount,\n                    \"currency_code\": currency_code,\n                    \"reason\": reason,\n                    \"platform_fee_adjustment_amount\": platform_fee_adj\n                })\n        return refund_records\n\n    # 1. Check initial state: No matching refund exists\n    initial_refunds = find_refunds(initial_db_path)\n    for r in initial_refunds:\n        if (\n            abs(r[\"amount\"] - TASK_AMOUNT) < 0.0001 and\n            r[\"currency_code\"] == TASK_CURRENCY and\n            TASK_REASON_EXPECTED.lower() in (r[\"reason\"] or '').lower()\n        ):\n            return {\"result\": \"others\"}\n\n    # 2. Check final state: Must have a new matching refund\n    final_refunds = find_refunds(final_db_path)\n    matching_final = []\n    for r in final_refunds:\n        if (\n            abs(r[\"amount\"] - TASK_AMOUNT) < 0.0001 and\n            r[\"currency_code\"] == TASK_CURRENCY and\n            TASK_REASON_EXPECTED.lower() in (r[\"reason\"] or '').lower()\n        ):\n            matching_final.append(r)\n    # Must be exactly one new matching refund\n    if len(matching_final) != 1:\n        return {\"result\": \"others\"}\n    refund_row = matching_final[0]\n    # Defensive: platform_fee_adjustment_amount must be present (may be zero or any value)\n    if refund_row[\"platform_fee_adjustment_amount\"] is None:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The task requires issuing a partial refund of 6.00 USD on order ID 89110 with the reason 'File duplicated in bundle', and recording any platform fee adjustment. Therefore, we must verify: (1) The initial database did NOT have such a refund on this order, (2) The final database has a new refund record for order_id=89110, amount=6.0, currency_code='USD', reason='File duplicated in bundle' (exact, case-insensitive), AND (3) If the platform fee was adjusted due to the refund, the platform_fee_adjustment_amount field should show a nonzero value (if applicable). All these checks are purely modification-based since no query or answer is required from final_answer.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Check that initial_db has NO refund for order_id=89110, amount=6.0, reason containing 'File duplicated in bundle'\",\n        \"Check that final_db has a refund for order_id=89110, amount=6.0, currency_code='USD', reason containing 'File duplicated in bundle' (case-insensitive match)\",\n        \"Check that platform_fee_adjustment_amount is recorded (zero or more, as applicable)\",\n        \"Check for exactly one such new refund record\",\n        \"Validate no ambiguity (e.g., multiple refunds matching criteria)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    TASK_ORDER_ID = 89110\\n    TASK_AMOUNT = 6.0\\n    TASK_REASON_EXPECTED = 'File duplicated in bundle'\\n    TASK_CURRENCY = 'USD'\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Helper: Find related refund records\\n    def find_refunds(db_path):\\n        rows = safe_query(\\n            db_path,\\n            \\\"SELECT id, order_id, amount, currency_code, reason, platform_fee_adjustment_amount FROM refunds WHERE order_id=?\\\",\\n            (TASK_ORDER_ID,)\\n        )\\n        refund_records = []\\n        for r in rows:\\n            refund_id, order_id, amount, currency_code, reason, platform_fee_adj = r\\n            # Defensive: all fields must be present and non-NULL\\n            if (\\n                refund_id is not None and\\n                order_id is not None and\\n                amount is not None and\\n                currency_code is not None and\\n                reason is not None and\\n                platform_fee_adj is not None\\n            ):\\n                refund_records.append({\\n                    \\\"id\\\": refund_id,\\n                    \\\"order_id\\\": order_id,\\n                    \\\"amount\\\": amount,\\n                    \\\"currency_code\\\": currency_code,\\n                    \\\"reason\\\": reason,\\n                    \\\"platform_fee_adjustment_amount\\\": platform_fee_adj\\n                })\\n        return refund_records\\n\\n    # 1. Check initial state: No matching refund exists\\n    initial_refunds = find_refunds(initial_db_path)\\n    for r in initial_refunds:\\n        if (\\n            abs(r[\\\"amount\\\"] - TASK_AMOUNT) < 0.0001 and\\n            r[\\\"currency_code\\\"] == TASK_CURRENCY and\\n            TASK_REASON_EXPECTED.lower() in (r[\\\"reason\\\"] or '').lower()\\n        ):\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Check final state: Must have a new matching refund\\n    final_refunds = find_refunds(final_db_path)\\n    matching_final = []\\n    for r in final_refunds:\\n        if (\\n            abs(r[\\\"amount\\\"] - TASK_AMOUNT) < 0.0001 and\\n            r[\\\"currency_code\\\"] == TASK_CURRENCY and\\n            TASK_REASON_EXPECTED.lower() in (r[\\\"reason\\\"] or '').lower()\\n        ):\\n            matching_final.append(r)\\n    # Must be exactly one new matching refund\\n    if len(matching_final) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    refund_row = matching_final[0]\\n    # Defensive: platform_fee_adjustment_amount must be present (may be zero or any value)\\n    if refund_row[\\\"platform_fee_adjustment_amount\\\"] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 9, "task": "As an admin action, take down listing ID 7001 for 'Policy: trademark infringement', notify the seller with the message 'Your listing was removed due to trademarked terms in the title; please edit and resubmit without brand names.', and set the seller verification status to 'review required'.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Values as per the task\n    ADMIN_USER_ID = 2\n    SELLER_USER_ID = 1\n    LISTING_ID = 7001\n    REMOVE_REASON = 'Policy: trademark infringement'\n    NOTIFY_MSG = 'Your listing was removed due to trademarked terms in the title; please edit and resubmit without brand names.'\n    REVIEW_STATUS = 'review_required'\n    PREV_STATUS = 'verified'\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Check listing 7001 status/state\n    listing_initial = safe_query(initial_db_path, \"SELECT status, removed_reason, removed_by_user_id, removed_at FROM listings WHERE id = ?\", (LISTING_ID,))\n    listing_final = safe_query(final_db_path, \"SELECT status, removed_reason, removed_by_user_id, removed_at FROM listings WHERE id = ?\", (LISTING_ID,))\n    if not listing_initial or not listing_final:\n        return {\"result\": \"others\"}\n    # Must be changed to removed w/ correct meta\n    f_status, f_reason, f_by, f_at = listing_final[0]\n    if (\n        f_status != 'removed' or\n        (f_reason or '').strip() != REMOVE_REASON or\n        f_by != ADMIN_USER_ID or\n        not f_at\n    ):\n        return {\"result\": \"others\"}\n    # Initial state must have been 'active' and not removed\n    i_status, i_reason, i_by, i_at = listing_initial[0]\n    if i_status != 'active':\n        return {\"result\": \"others\"}\n    \n    # 2. admin_actions for takedown_listing\n    aa_td_final = safe_query(\n        final_db_path,\n        \"\"\"\n        SELECT id, actor_user_id, action_type, target_type, target_id, reason, message_to_seller FROM admin_actions\n        WHERE actor_user_id = ? AND action_type = 'takedown_listing' AND target_type = 'listing' AND target_id = ?\n        \"\"\",\n        (ADMIN_USER_ID, LISTING_ID)\n    )\n    # Allow only a single matching entry (if more, not safe/deterministic)\n    aa_td_final = [row for row in aa_td_final if (row[5] or '').strip() == REMOVE_REASON]\n    if len(aa_td_final) != 1:\n        return {\"result\": \"others\"}\n    # Message to seller must match (ignore extra whitespace at ends)\n    if (aa_td_final[0][6] or '').strip() != NOTIFY_MSG:\n        return {\"result\": \"others\"}\n\n    # There should be no such takedown_listing action in the initial (it should be a new action)\n    aa_td_initial = safe_query(\n        initial_db_path,\n        \"\"\"\n        SELECT id FROM admin_actions WHERE actor_user_id=? AND action_type='takedown_listing' AND target_type='listing' AND target_id=? AND reason=?\n        \"\"\", (ADMIN_USER_ID, LISTING_ID, REMOVE_REASON)\n    )\n    if aa_td_initial:\n        return {\"result\": \"others\"}\n\n    # 3. users.id=1 verification_status should change from verified to review_required\n    user_initial = safe_query(initial_db_path, \"SELECT verification_status FROM users WHERE id=?\", (SELLER_USER_ID,))\n    user_final = safe_query(final_db_path, \"SELECT verification_status FROM users WHERE id=?\", (SELLER_USER_ID,))\n    if not user_initial or not user_final:\n        return {\"result\": \"others\"}\n    if user_initial[0][0] != PREV_STATUS:\n        return {\"result\": \"others\"}\n    if user_final[0][0] != REVIEW_STATUS:\n        return {\"result\": \"others\"}\n\n    # 4. admin_actions for set_seller_verification_status for user 1, referencing review required\n    aa_verif_final = safe_query(\n        final_db_path,\n        \"\"\"\n        SELECT id, actor_user_id, action_type, target_type, target_id FROM admin_actions\n        WHERE actor_user_id=? AND action_type='set_seller_verification_status' AND target_type='user' AND target_id=?\n        \"\"\",\n        (ADMIN_USER_ID, SELLER_USER_ID)\n    )\n    if not aa_verif_final:\n        return {\"result\": \"others\"}\n    # It must be a new entry vs initial\n    aa_verif_initial = safe_query(\n        initial_db_path,\n        \"\"\"\n        SELECT id FROM admin_actions WHERE actor_user_id=? AND action_type='set_seller_verification_status' AND target_type='user' AND target_id=?\n        \"\"\",\n        (ADMIN_USER_ID, SELLER_USER_ID)\n    )\n    # New action required (action(s) in final not in initial)\n    aa_ids_initial = set(row[0] for row in aa_verif_initial)\n    aa_ids_final = set(row[0] for row in aa_verif_final)\n    new_ids = aa_ids_final - aa_ids_initial\n    if not new_ids:\n        return {\"result\": \"others\"}\n\n    # (Optional: for max determinism, try to check if any new set_seller_verification_status action refers to \"review required\" in reason/message)\n    # Fetch those rows and check detail\n    for new_id in new_ids:\n        new_row = safe_query(final_db_path, \"SELECT reason, message_to_seller FROM admin_actions WHERE id=?\", (new_id,))\n        if not new_row:\n            continue\n        reason_val = (new_row[0][0] or '').lower()\n        msg_val = (new_row[0][1] or '').lower()\n        if 'review' in reason_val or 'review' in msg_val:\n            break\n    else:\n        return {\"result\": \"others\"}\n\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task requires multiple exact admin actions as follows: (1) The listing with ID 7001 must be taken down for 'Policy: trademark infringement'. This means the 'listings' table should show status='removed', removed_reason matching, removed_by_user_id set to the admin's user id (2), and removed_at is not null. (2) An admin_actions row should exist, actor_user_id=2, action_type='takedown_listing', target_type='listing', target_id=7001, reason='Policy: trademark infringement', and the correct notification message to seller must be present. (3) The seller (user_id=1) verification_status in 'users' table must be updated from 'verified' to 'review required'. (4) An admin_actions row should exist, actor_user_id=2, action_type='set_seller_verification_status', target_type='user', target_id=1, and status/reason indicate 'review required'. (5) All changes must not affect unrelated fields. All conditions must be met exactly for the task to be considered complete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"listing id 7001 status is changed to 'removed' with removed_reason 'Policy: trademark infringement', removed_by_user_id=2, removed_at is not null\",\n        \"admin_actions has new row: actor_user_id=2, action_type='takedown_listing', target_type='listing', target_id=7001, reason matching 'Policy: trademark infringement', message_to_seller is the expected string\",\n        \"users.id=1 verification_status changed from 'verified' in initial db to 'review_required' in final db\",\n        \"admin_actions has new row: actor_user_id=2, action_type='set_seller_verification_status', target_type='user', target_id=1, referencing 'review required'\",\n        \"No unrelated data is modified; removed_at and removed_by_user_id for listing are not null; all primary requirements are met exactly\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Values as per the task\\n    ADMIN_USER_ID = 2\\n    SELLER_USER_ID = 1\\n    LISTING_ID = 7001\\n    REMOVE_REASON = 'Policy: trademark infringement'\\n    NOTIFY_MSG = 'Your listing was removed due to trademarked terms in the title; please edit and resubmit without brand names.'\\n    REVIEW_STATUS = 'review_required'\\n    PREV_STATUS = 'verified'\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Check listing 7001 status/state\\n    listing_initial = safe_query(initial_db_path, \\\"SELECT status, removed_reason, removed_by_user_id, removed_at FROM listings WHERE id = ?\\\", (LISTING_ID,))\\n    listing_final = safe_query(final_db_path, \\\"SELECT status, removed_reason, removed_by_user_id, removed_at FROM listings WHERE id = ?\\\", (LISTING_ID,))\\n    if not listing_initial or not listing_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Must be changed to removed w/ correct meta\\n    f_status, f_reason, f_by, f_at = listing_final[0]\\n    if (\\n        f_status != 'removed' or\\n        (f_reason or '').strip() != REMOVE_REASON or\\n        f_by != ADMIN_USER_ID or\\n        not f_at\\n    ):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Initial state must have been 'active' and not removed\\n    i_status, i_reason, i_by, i_at = listing_initial[0]\\n    if i_status != 'active':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # 2. admin_actions for takedown_listing\\n    aa_td_final = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id, actor_user_id, action_type, target_type, target_id, reason, message_to_seller FROM admin_actions\\n        WHERE actor_user_id = ? AND action_type = 'takedown_listing' AND target_type = 'listing' AND target_id = ?\\n        \\\"\\\"\\\",\\n        (ADMIN_USER_ID, LISTING_ID)\\n    )\\n    # Allow only a single matching entry (if more, not safe/deterministic)\\n    aa_td_final = [row for row in aa_td_final if (row[5] or '').strip() == REMOVE_REASON]\\n    if len(aa_td_final) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Message to seller must match (ignore extra whitespace at ends)\\n    if (aa_td_final[0][6] or '').strip() != NOTIFY_MSG:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # There should be no such takedown_listing action in the initial (it should be a new action)\\n    aa_td_initial = safe_query(\\n        initial_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id FROM admin_actions WHERE actor_user_id=? AND action_type='takedown_listing' AND target_type='listing' AND target_id=? AND reason=?\\n        \\\"\\\"\\\", (ADMIN_USER_ID, LISTING_ID, REMOVE_REASON)\\n    )\\n    if aa_td_initial:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. users.id=1 verification_status should change from verified to review_required\\n    user_initial = safe_query(initial_db_path, \\\"SELECT verification_status FROM users WHERE id=?\\\", (SELLER_USER_ID,))\\n    user_final = safe_query(final_db_path, \\\"SELECT verification_status FROM users WHERE id=?\\\", (SELLER_USER_ID,))\\n    if not user_initial or not user_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if user_initial[0][0] != PREV_STATUS:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if user_final[0][0] != REVIEW_STATUS:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. admin_actions for set_seller_verification_status for user 1, referencing review required\\n    aa_verif_final = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id, actor_user_id, action_type, target_type, target_id FROM admin_actions\\n        WHERE actor_user_id=? AND action_type='set_seller_verification_status' AND target_type='user' AND target_id=?\\n        \\\"\\\"\\\",\\n        (ADMIN_USER_ID, SELLER_USER_ID)\\n    )\\n    if not aa_verif_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # It must be a new entry vs initial\\n    aa_verif_initial = safe_query(\\n        initial_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id FROM admin_actions WHERE actor_user_id=? AND action_type='set_seller_verification_status' AND target_type='user' AND target_id=?\\n        \\\"\\\"\\\",\\n        (ADMIN_USER_ID, SELLER_USER_ID)\\n    )\\n    # New action required (action(s) in final not in initial)\\n    aa_ids_initial = set(row[0] for row in aa_verif_initial)\\n    aa_ids_final = set(row[0] for row in aa_verif_final)\\n    new_ids = aa_ids_final - aa_ids_initial\\n    if not new_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # (Optional: for max determinism, try to check if any new set_seller_verification_status action refers to \\\"review required\\\" in reason/message)\\n    # Fetch those rows and check detail\\n    for new_id in new_ids:\\n        new_row = safe_query(final_db_path, \\\"SELECT reason, message_to_seller FROM admin_actions WHERE id=?\\\", (new_id,))\\n        if not new_row:\\n            continue\\n        reason_val = (new_row[0][0] or '').lower()\\n        msg_val = (new_row[0][1] or '').lower()\\n        if 'review' in reason_val or 'review' in msg_val:\\n            break\\n    else:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 0, "task": "Add a new pet record for my dog named \"Milo\" (Golden Retriever, male, 3 years old) including rabies vaccine date 2025-01-10, DHPP vaccine date 2024-11-02, behavior notes \"friendly with dogs, nervous around fireworks\", and emergency contact \"Sara Kim, +1-415-555-0139\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            conn.row_factory = sqlite3.Row\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return [dict(row) for row in rows]\n        except Exception:\n            return []\n\n    # Helper: Normalize behavior_notes for comparison\n    def normalize_text(txt):\n        if txt is None:\n            return None\n        # Remove extra whitespace, lowercase\n        return re.sub(r'\\s+', ' ', txt.strip()).lower()\n\n    # Get owner_user_id of main user (assume 'sam_owner', id=1)\n    initial_owners = safe_query(initial_db_path, \"SELECT id, username FROM users WHERE username = ?\", ('sam_owner',))\n    if not initial_owners:\n        return {\"result\": \"others\"}\n    owner_user_id = initial_owners[0]['id']\n\n    # Check for pet named 'Milo', owner=1 in initial DB\n    initial_pets = safe_query(\n        initial_db_path,\n        \"SELECT * FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\",\n        (owner_user_id, 'milo')\n    )\n    if initial_pets:\n        # Milo already existed! Can't be new\n        return {\"result\": \"others\"}\n\n    # Now, get all pets named 'Milo' for this owner in final DB\n    final_pets = safe_query(\n        final_db_path,\n        \"SELECT * FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\",\n        (owner_user_id, 'milo')\n    )\n    if not final_pets:\n        # No Milo found, task not complete\n        return {\"result\": \"others\"}\n\n    # Check for properties (we only succeed if there is EXACTLY ONE Milo with 100% matching info)\n    matched_pet = None\n    required_notes_norm = normalize_text(\"friendly with dogs, nervous around fireworks\")\n    for pet in final_pets:\n        # strict checks\n        # breed, sex, age_years, species, behavior_notes, emergency contact name/phone\n        pet_notes = normalize_text(pet.get('behavior_notes',''))\n        notes_match = (pet_notes == required_notes_norm)\n        # Accept birth_date == None or mismatch, as user only specified 3 years old\n        if (\n            (pet.get('species','').lower() == 'dog') and\n            (pet.get('breed','').strip().lower() == 'golden retriever') and\n            (pet.get('sex','').lower() == 'male') and\n            (pet.get('age_years') == 3) and\n            notes_match and\n            (pet.get('emergency_contact_name','').strip() == 'Sara Kim') and\n            (pet.get('emergency_contact_phone','').strip() == '+1-415-555-0139')\n        ):\n            matched_pet = pet\n            break\n    if matched_pet is None:\n        return {\"result\": \"others\"}\n    pet_id = matched_pet.get('id')\n    if not isinstance(pet_id, int):\n        return {\"result\": \"others\"}\n\n    # Now ensure BOTH vaccinations exist for this pet\n    # Get all initial pet_vaccinations for any Milo dog for this owner (should be none, but for robust check)\n    initial_vax_pet_ids = [p[\"id\"] for p in safe_query(initial_db_path, \"SELECT id FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\", (owner_user_id, 'milo'))]\n    if len(initial_vax_pet_ids) > 0:\n        # Should not be possible, but fail defensively\n        return {\"result\": \"others\"}\n    # Get vaccination records for this pet in final\n    final_vaxs = safe_query(\n        final_db_path,\n        \"SELECT vaccine_type, administered_on FROM pet_vaccinations WHERE pet_id = ?\",\n        (pet_id,)\n    )\n    vax_required = {\n        ('rabies', '2025-01-10'),\n        ('dhpp', '2024-11-02')\n    }\n    vax_final = set()\n    for vrow in final_vaxs:\n        vt = vrow.get('vaccine_type','').lower()\n        ad = vrow.get('administered_on','')\n        if not (vt and ad):\n            continue\n        # Accept only strict matches\n        vax_final.add((vt, ad))\n    if vax_required != vax_final:\n        return {\"result\": \"others\"}\n    # Check that both these are new records (pet_id is not in initial db)\n    # (We already ensured no Milo in initial DB. So any vax for this pet is new.)\n\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must prove that a NEW pet record for a dog named 'Milo' (Golden Retriever, male, 3 years old) with all specified attributes (behavior notes, emergency contact) was added to the database, and that BOTH the rabies and DHPP vaccine records were also created for this pet with the exact administered_on dates required. The following attributes must be strictly checked for correctness: name, species, breed, sex, age_years, behavior_notes, emergency_contact_name, emergency_contact_phone, AND the presence of two vaccine records for this pet ('rabies' on 2025-01-10, 'dhpp' on 2024-11-02). Make sure that Milo is a new record (not present in the initial DB for the same owner). Any deviation or missing detail means the task is not complete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find the owner_user_id for 'sam_owner' (since user task is phrased as 'my dog' and matches emergency contact pattern)\",\n        \"Ensure NO pet named 'Milo' for this owner existed in the initial DB\",\n        \"In the final DB, check for a NEW pet for this owner with name 'Milo', species 'dog', breed 'Golden Retriever', sex 'male', age_years 3\",\n        \"Check behavior_notes matches 'friendly with dogs, nervous around fireworks' (allowing for whitespace normalization)\",\n        \"Check emergency contact name is 'Sara Kim' (full match) and emergency contact phone is '+1-415-555-0139'\",\n        \"Find this new pet's id, confirm exactly two new pet_vaccinations for it: ('rabies', 2025-01-10) and ('dhpp', 2024-11-02)\",\n        \"No extraneous data changes are required; fail if any critical detail is missing or mismatched\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            conn.row_factory = sqlite3.Row\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return [dict(row) for row in rows]\\n        except Exception:\\n            return []\\n\\n    # Helper: Normalize behavior_notes for comparison\\n    def normalize_text(txt):\\n        if txt is None:\\n            return None\\n        # Remove extra whitespace, lowercase\\n        return re.sub(r'\\\\s+', ' ', txt.strip()).lower()\\n\\n    # Get owner_user_id of main user (assume 'sam_owner', id=1)\\n    initial_owners = safe_query(initial_db_path, \\\"SELECT id, username FROM users WHERE username = ?\\\", ('sam_owner',))\\n    if not initial_owners:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    owner_user_id = initial_owners[0]['id']\\n\\n    # Check for pet named 'Milo', owner=1 in initial DB\\n    initial_pets = safe_query(\\n        initial_db_path,\\n        \\\"SELECT * FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\\\",\\n        (owner_user_id, 'milo')\\n    )\\n    if initial_pets:\\n        # Milo already existed! Can't be new\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Now, get all pets named 'Milo' for this owner in final DB\\n    final_pets = safe_query(\\n        final_db_path,\\n        \\\"SELECT * FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\\\",\\n        (owner_user_id, 'milo')\\n    )\\n    if not final_pets:\\n        # No Milo found, task not complete\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check for properties (we only succeed if there is EXACTLY ONE Milo with 100% matching info)\\n    matched_pet = None\\n    required_notes_norm = normalize_text(\\\"friendly with dogs, nervous around fireworks\\\")\\n    for pet in final_pets:\\n        # strict checks\\n        # breed, sex, age_years, species, behavior_notes, emergency contact name/phone\\n        pet_notes = normalize_text(pet.get('behavior_notes',''))\\n        notes_match = (pet_notes == required_notes_norm)\\n        # Accept birth_date == None or mismatch, as user only specified 3 years old\\n        if (\\n            (pet.get('species','').lower() == 'dog') and\\n            (pet.get('breed','').strip().lower() == 'golden retriever') and\\n            (pet.get('sex','').lower() == 'male') and\\n            (pet.get('age_years') == 3) and\\n            notes_match and\\n            (pet.get('emergency_contact_name','').strip() == 'Sara Kim') and\\n            (pet.get('emergency_contact_phone','').strip() == '+1-415-555-0139')\\n        ):\\n            matched_pet = pet\\n            break\\n    if matched_pet is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    pet_id = matched_pet.get('id')\\n    if not isinstance(pet_id, int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Now ensure BOTH vaccinations exist for this pet\\n    # Get all initial pet_vaccinations for any Milo dog for this owner (should be none, but for robust check)\\n    initial_vax_pet_ids = [p[\\\"id\\\"] for p in safe_query(initial_db_path, \\\"SELECT id FROM pets WHERE owner_user_id = ? AND LOWER(name) = ?\\\", (owner_user_id, 'milo'))]\\n    if len(initial_vax_pet_ids) > 0:\\n        # Should not be possible, but fail defensively\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Get vaccination records for this pet in final\\n    final_vaxs = safe_query(\\n        final_db_path,\\n        \\\"SELECT vaccine_type, administered_on FROM pet_vaccinations WHERE pet_id = ?\\\",\\n        (pet_id,)\\n    )\\n    vax_required = {\\n        ('rabies', '2025-01-10'),\\n        ('dhpp', '2024-11-02')\\n    }\\n    vax_final = set()\\n    for vrow in final_vaxs:\\n        vt = vrow.get('vaccine_type','').lower()\\n        ad = vrow.get('administered_on','')\\n        if not (vt and ad):\\n            continue\\n        # Accept only strict matches\\n        vax_final.add((vt, ad))\\n    if vax_required != vax_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check that both these are new records (pet_id is not in initial db)\\n    # (We already ensured no Milo in initial DB. So any vax for this pet is new.)\\n\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 1, "task": "Search for dog walkers within 2 miles of 94107 available on 2026-03-05 between 6:00 PM and 7:00 PM for a 30-minute walk and return the top 3 results sorted by lowest price with their per-walk rate and average rating.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n    # Helper for safe database querying\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            ans = cursor.fetchall()\n            conn.close()\n            return ans\n        except Exception:\n            return []\n\n    # Step 1: Compute the correct top 3 service listings\n    # Date/time requirements\n    query_date = '2026-03-05'  # Thursday\n    day_of_week = datetime.strptime(query_date, '%Y-%m-%d').weekday()  # Python: Monday=0, so Thursday=3/4\n    walk_start = datetime.strptime(query_date + ' 18:00:00', '%Y-%m-%d %H:%M:%S')\n    walk_end = walk_start + timedelta(minutes=30)\n    walk_time_str = '18:00'\n    walk_duration = 30\n    def list_available_walk_services(db_path):\n        # Pull all listings satisfying location, type, unit, active, radius\n        listings = safe_query(\n            db_path,\n            \"SELECT id, sitter_user_id, title, price_amount, price_unit FROM service_listings \"\n            \"WHERE service_type='walk' AND base_postal_code='94107' AND active=1 AND service_radius_miles<=2.0 AND price_unit='per_walk'\"\n        )\n        results = []\n        for lid, sitter_id, title, price_amt, price_unit in listings:\n            # Find matching Thursday service_availability_rules\n            rules = safe_query(\n                db_path,\n                \"SELECT start_time, end_time FROM service_availability_rules \"\n                \"WHERE service_listing_id=? AND day_of_week=? AND start_date<=?\",\n                (lid, day_of_week, query_date)\n            )\n            # Is service_blackout overlapping?\n            blackouts = safe_query(\n                db_path,\n                \"SELECT start_datetime, end_datetime FROM service_blackouts WHERE service_listing_id=?\",\n                (lid,)\n            )\n            # We need availability between 18:00 and 19:00, for 30min\n            slot_ok = False\n            for start_time, end_time in rules:\n                # Ensure rule covers 18:00-18:30\n                try:\n                    start_rule = datetime.strptime(query_date + ' ' + start_time, '%Y-%m-%d %H:%M')\n                    end_rule = datetime.strptime(query_date + ' ' + end_time, '%Y-%m-%d %H:%M')\n                except:\n                    continue\n                if start_rule <= walk_start and end_rule >= walk_end:\n                    slot_ok = True\n                    break\n            if not slot_ok:\n                continue\n            # Blackout check\n            overlap = False\n            for start_b, end_b in blackouts:\n                try:\n                    bstart = datetime.strptime(start_b, '%Y-%m-%d %H:%M:%S')\n                    bend = datetime.strptime(end_b, '%Y-%m-%d %H:%M:%S')\n                except:\n                    continue\n                # If requested slot overlaps blackout\n                if not (walk_end <= bstart or walk_start >= bend):\n                    overlap = True\n                    break\n            if overlap:\n                continue\n            # Find avg_rating as of 2026-03-05\n            metric = safe_query(\n                db_path,\n                \"SELECT avg_rating, rating_count FROM sitter_daily_metrics WHERE sitter_user_id=? AND metric_date=?\",\n                (sitter_id, query_date)\n            )\n            avg_rating = metric[0][0] if metric and metric[0][0] is not None else None\n            # Find sitter name\n            sitter_info = safe_query(\n                db_path,\n                \"SELECT full_name FROM users WHERE id=?\",\n                (sitter_id,)\n            )\n            sitter_name = sitter_info[0][0] if sitter_info and sitter_info[0][0] else None\n            results.append({\"id\": lid, \"sitter_name\": sitter_name, \"title\": title, \"price\": price_amt, \"rating\": avg_rating})\n        # Sort by price ascending, then listing id for determinism\n        results_sorted = sorted(results, key=lambda x: (x[\"price\"], x[\"id\"]))\n        return results_sorted[:3]\n\n    correct_top3 = list_available_walk_services(final_db_path)\n    if len(correct_top3) < 3:\n        return {\"result\": \"others\"}\n\n    # Step 2: Extract top 3 results from final_answer\n    # Accept multiple possible formats, but require each result to have sitter/listing, price and rating.\n    if not final_answer or not isinstance(final_answer, str) or len(final_answer.strip()) < 20:\n        return {\"result\": \"others\"}\n\n    # Find all blocks with sitter or title, price, and rating\n    PATTERN = re.compile(\n        r\"(?:1|2|3)[\\).\\s-]*([A-Za-z0-9 \\-']+)[\\,\\s]*\"\n        r\".*?(?:\\$|USD\\s?)([0-9]+(?:\\.[0-9]{1,2})?)\"\n        r\".*?(?:avg(?:\\.|erage)?\\s*rating|rating)[\\s:\\,]*([0-9]+(?:\\.[0-9]{1,2})?)\",\n        re.IGNORECASE | re.DOTALL\n    )\n    entries = PATTERN.findall(final_answer)\n    # If not exactly 3 structured matches, try fallback line-by-line\n    if len(entries) != 3:\n        # Accept formats like\n        # \"1. Jordan Lee - $20 per walk (Average Rating: 4.8)\"\n        alt_pattern = re.compile(\n            r\"(?:1|2|3)[\\).\\s-]*([A-Za-z0-9 \\-']+)[\\s\\-,]*[^\\$]*(\\$([0-9]+(?:\\.[0-9]{1,2})?))[^\\)]*\\(.*?(\\d+(?:\\.\\d+)?)\\s*\\)\",\n            re.IGNORECASE | re.DOTALL\n        )\n        entries = alt_pattern.findall(final_answer)\n    parsed_results = []\n    for ent in entries:\n        # Accept either (name/title, price, rating) or (name/title, $, price, rating)\n        if len(ent) == 4:\n            name_or_title, _, price_str, rating_str = ent\n        elif len(ent) == 3:\n            name_or_title, price_str, rating_str = ent\n        else:\n            continue\n        try:\n            price_amt = float(price_str)\n            rating = float(rating_str)\n        except:\n            continue\n        parsed_results.append({\"name_or_title\": name_or_title.strip(), \"price\": price_amt, \"rating\": rating})\n    if len(parsed_results) != 3:\n        return {\"result\": \"others\"}\n\n    # Step 3: Cross-match extracted results to correct_top3, verify order and details\n    # Build all possible names/titles for lookup\n    def normalize(s):\n        return s.lower().strip()\n    def matches_db(parsed, db):\n        # Accept match by listing title OR sitter name (exact, case-insensitive)\n        ptitle = normalize(parsed[\"name_or_title\"])\n        return (\n            normalize(db[\"sitter_name\"]) == ptitle\n            or normalize(db[\"title\"]) == ptitle\n            or ptitle in normalize(db[\"sitter_name\"])\n            or ptitle in normalize(db[\"title\"])\n        ) and abs(parsed[\"price\"] - db[\"price\"]) < 0.01 and abs(parsed[\"rating\"] - db[\"rating\"]) < 0.05\n\n    matched_flags = [False] * 3\n    for i, pres in enumerate(parsed_results):\n        found = False\n        for j, dbres in enumerate(correct_top3):\n            if matches_db(pres, dbres):\n                if j == i:  # order must match (sorted by price)\n                    matched_flags[i] = True\n                found = True\n                break\n        if not found:\n            return {\"result\": \"others\"}\n    if not all(matched_flags):\n        return {\"result\": \"others\"}\n\n    # Check sorting in final_answer (ascending price order), defenders: must match DB\n    fprices = [res[\"price\"] for res in parsed_results]\n    dbprices = [res[\"price\"] for res in correct_top3]\n    if fprices != dbprices:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, which is a pure query (read/search) task, the final_answer must directly present the top 3 dog walker listings that meet ALL the following criteria: 1) service_type = 'walk'; 2) base_postal_code = '94107'; 3) active = 1; 4) service_radius_miles <= 2.0; 5) price_unit = 'per_walk'; 6) Available on 2026-03-05 (Thursday) between 18:00 and 19:00 for a 30-minute walk (check both 'service_availability_rules' and that no overlap with 'service_blackouts'); 7) Results are sorted by lowest price; 8) Each returned result must clearly show per-walk rate (price_amount), and average rating as of 2026-03-05 (from 'sitter_daily_metrics'). The verification checks must: a) extract structured results from final_answer; b) cross-validate all extracted entries against the database for exact match, correct filtering, sorting, and presence of required fields; c) ensure there are no extraneous, missing, or incorrectly sorted items. If ANY criteria cannot be definitively validated, or if the final_answer is missing or malformed, return {'result': 'others'}.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Extract top 3 results from final_answer: must show sitter name or listing title, per-walk rate, and average rating as of 2026-03-05\",\n        \"Cross-match results to service_listings: service_type='walk', base_postal_code='94107', active=1, service_radius_miles <=2.0, price_unit='per_walk'\",\n        \"Validate each listing's availability on Thursday (day_of_week=4), 2026-03-05, between 18:00 and 19:00 for 30 minutes, no blackouts overlap\",\n        \"Ensure only 3 results, and they are sorted by lowest price_amount\",\n        \"Check that per-walk rate and average rating match database values (as of 2026-03-05, from sitter_daily_metrics)\",\n        \"If any result does not match exactly, or format is ambiguous, return {'result': 'others'}\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n    # Helper for safe database querying\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            ans = cursor.fetchall()\\n            conn.close()\\n            return ans\\n        except Exception:\\n            return []\\n\\n    # Step 1: Compute the correct top 3 service listings\\n    # Date/time requirements\\n    query_date = '2026-03-05'  # Thursday\\n    day_of_week = datetime.strptime(query_date, '%Y-%m-%d').weekday()  # Python: Monday=0, so Thursday=3/4\\n    walk_start = datetime.strptime(query_date + ' 18:00:00', '%Y-%m-%d %H:%M:%S')\\n    walk_end = walk_start + timedelta(minutes=30)\\n    walk_time_str = '18:00'\\n    walk_duration = 30\\n    def list_available_walk_services(db_path):\\n        # Pull all listings satisfying location, type, unit, active, radius\\n        listings = safe_query(\\n            db_path,\\n            \\\"SELECT id, sitter_user_id, title, price_amount, price_unit FROM service_listings \\\"\\n            \\\"WHERE service_type='walk' AND base_postal_code='94107' AND active=1 AND service_radius_miles<=2.0 AND price_unit='per_walk'\\\"\\n        )\\n        results = []\\n        for lid, sitter_id, title, price_amt, price_unit in listings:\\n            # Find matching Thursday service_availability_rules\\n            rules = safe_query(\\n                db_path,\\n                \\\"SELECT start_time, end_time FROM service_availability_rules \\\"\\n                \\\"WHERE service_listing_id=? AND day_of_week=? AND start_date<=?\\\",\\n                (lid, day_of_week, query_date)\\n            )\\n            # Is service_blackout overlapping?\\n            blackouts = safe_query(\\n                db_path,\\n                \\\"SELECT start_datetime, end_datetime FROM service_blackouts WHERE service_listing_id=?\\\",\\n                (lid,)\\n            )\\n            # We need availability between 18:00 and 19:00, for 30min\\n            slot_ok = False\\n            for start_time, end_time in rules:\\n                # Ensure rule covers 18:00-18:30\\n                try:\\n                    start_rule = datetime.strptime(query_date + ' ' + start_time, '%Y-%m-%d %H:%M')\\n                    end_rule = datetime.strptime(query_date + ' ' + end_time, '%Y-%m-%d %H:%M')\\n                except:\\n                    continue\\n                if start_rule <= walk_start and end_rule >= walk_end:\\n                    slot_ok = True\\n                    break\\n            if not slot_ok:\\n                continue\\n            # Blackout check\\n            overlap = False\\n            for start_b, end_b in blackouts:\\n                try:\\n                    bstart = datetime.strptime(start_b, '%Y-%m-%d %H:%M:%S')\\n                    bend = datetime.strptime(end_b, '%Y-%m-%d %H:%M:%S')\\n                except:\\n                    continue\\n                # If requested slot overlaps blackout\\n                if not (walk_end <= bstart or walk_start >= bend):\\n                    overlap = True\\n                    break\\n            if overlap:\\n                continue\\n            # Find avg_rating as of 2026-03-05\\n            metric = safe_query(\\n                db_path,\\n                \\\"SELECT avg_rating, rating_count FROM sitter_daily_metrics WHERE sitter_user_id=? AND metric_date=?\\\",\\n                (sitter_id, query_date)\\n            )\\n            avg_rating = metric[0][0] if metric and metric[0][0] is not None else None\\n            # Find sitter name\\n            sitter_info = safe_query(\\n                db_path,\\n                \\\"SELECT full_name FROM users WHERE id=?\\\",\\n                (sitter_id,)\\n            )\\n            sitter_name = sitter_info[0][0] if sitter_info and sitter_info[0][0] else None\\n            results.append({\\\"id\\\": lid, \\\"sitter_name\\\": sitter_name, \\\"title\\\": title, \\\"price\\\": price_amt, \\\"rating\\\": avg_rating})\\n        # Sort by price ascending, then listing id for determinism\\n        results_sorted = sorted(results, key=lambda x: (x[\\\"price\\\"], x[\\\"id\\\"]))\\n        return results_sorted[:3]\\n\\n    correct_top3 = list_available_walk_services(final_db_path)\\n    if len(correct_top3) < 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 2: Extract top 3 results from final_answer\\n    # Accept multiple possible formats, but require each result to have sitter/listing, price and rating.\\n    if not final_answer or not isinstance(final_answer, str) or len(final_answer.strip()) < 20:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Find all blocks with sitter or title, price, and rating\\n    PATTERN = re.compile(\\n        r\\\"(?:1|2|3)[\\\\).\\\\s-]*([A-Za-z0-9 \\\\-']+)[\\\\,\\\\s]*\\\"\\n        r\\\".*?(?:\\\\$|USD\\\\s?)([0-9]+(?:\\\\.[0-9]{1,2})?)\\\"\\n        r\\\".*?(?:avg(?:\\\\.|erage)?\\\\s*rating|rating)[\\\\s:\\\\,]*([0-9]+(?:\\\\.[0-9]{1,2})?)\\\",\\n        re.IGNORECASE | re.DOTALL\\n    )\\n    entries = PATTERN.findall(final_answer)\\n    # If not exactly 3 structured matches, try fallback line-by-line\\n    if len(entries) != 3:\\n        # Accept formats like\\n        # \\\"1. Jordan Lee - $20 per walk (Average Rating: 4.8)\\\"\\n        alt_pattern = re.compile(\\n            r\\\"(?:1|2|3)[\\\\).\\\\s-]*([A-Za-z0-9 \\\\-']+)[\\\\s\\\\-,]*[^\\\\$]*(\\\\$([0-9]+(?:\\\\.[0-9]{1,2})?))[^\\\\)]*\\\\(.*?(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*\\\\)\\\",\\n            re.IGNORECASE | re.DOTALL\\n        )\\n        entries = alt_pattern.findall(final_answer)\\n    parsed_results = []\\n    for ent in entries:\\n        # Accept either (name/title, price, rating) or (name/title, $, price, rating)\\n        if len(ent) == 4:\\n            name_or_title, _, price_str, rating_str = ent\\n        elif len(ent) == 3:\\n            name_or_title, price_str, rating_str = ent\\n        else:\\n            continue\\n        try:\\n            price_amt = float(price_str)\\n            rating = float(rating_str)\\n        except:\\n            continue\\n        parsed_results.append({\\\"name_or_title\\\": name_or_title.strip(), \\\"price\\\": price_amt, \\\"rating\\\": rating})\\n    if len(parsed_results) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Cross-match extracted results to correct_top3, verify order and details\\n    # Build all possible names/titles for lookup\\n    def normalize(s):\\n        return s.lower().strip()\\n    def matches_db(parsed, db):\\n        # Accept match by listing title OR sitter name (exact, case-insensitive)\\n        ptitle = normalize(parsed[\\\"name_or_title\\\"])\\n        return (\\n            normalize(db[\\\"sitter_name\\\"]) == ptitle\\n            or normalize(db[\\\"title\\\"]) == ptitle\\n            or ptitle in normalize(db[\\\"sitter_name\\\"])\\n            or ptitle in normalize(db[\\\"title\\\"])\\n        ) and abs(parsed[\\\"price\\\"] - db[\\\"price\\\"]) < 0.01 and abs(parsed[\\\"rating\\\"] - db[\\\"rating\\\"]) < 0.05\\n\\n    matched_flags = [False] * 3\\n    for i, pres in enumerate(parsed_results):\\n        found = False\\n        for j, dbres in enumerate(correct_top3):\\n            if matches_db(pres, dbres):\\n                if j == i:  # order must match (sorted by price)\\n                    matched_flags[i] = True\\n                found = True\\n                break\\n        if not found:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    if not all(matched_flags):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check sorting in final_answer (ascending price order), defenders: must match DB\\n    fprices = [res[\\\"price\\\"] for res in parsed_results]\\n    dbprices = [res[\\\"price\\\"] for res in correct_top3]\\n    if fprices != dbprices:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 2, "task": "Request a booking for a 30-minute walk with the cheapest available sitter from the previous search for \"Milo\" on 2026-03-05 at 6:15 PM, including the message \"Please use the lobby entrance and avoid the construction zone on 3rd St.\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    from datetime import datetime, timedelta\n    import re\n\n    # Helper to query database safely\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            conn.row_factory = sqlite3.Row\n            cur = conn.cursor()\n            cur.execute(query, params)\n            results = cur.fetchall()\n            conn.close()\n            return [dict(row) for row in results]\n        except Exception:\n            return []\n\n    # Find Milo's pet_id and owner_user_id\n    milo_pet = safe_query(final_db_path, \"SELECT id, owner_user_id FROM pets WHERE name=? COLLATE NOCASE\", (\"Milo\",))\n    if not milo_pet or 'id' not in milo_pet[0]:\n        return {\"result\": \"others\"}\n    milo_pet_id = milo_pet[0]['id']\n    milo_owner_user_id = milo_pet[0]['owner_user_id']\n\n    # Time window for booking\n    start_dt_str = \"2026-03-05 18:15:00\"\n    try:\n        start_dt = datetime.strptime(start_dt_str, \"%Y-%m-%d %H:%M:%S\")\n        end_dt = start_dt + timedelta(minutes=30)\n    except Exception:\n        return {\"result\": \"others\"}\n\n    # All active walk services\n    walk_listings = safe_query(final_db_path, \"SELECT * FROM service_listings WHERE service_type='walk' AND active=1\")\n    if not walk_listings:\n        return {\"result\": \"others\"}\n    # Figure out which listings are available/cheapest for this time\n    available_listing_ids = []\n    for l in walk_listings:\n        # Check availability for Thursday (day_of_week=3, Monday=0)\n        rules = safe_query(final_db_path, \"SELECT * FROM service_availability_rules WHERE service_listing_id = ? AND day_of_week = 3\", (l['id'],))\n        if not rules:\n            continue\n        # Confirm any rule covers 18:15-18:45\n        possible = False\n        for r in rules:\n            try:\n                st = datetime.strptime(r['start_time'], \"%H:%M\").time()\n                et = datetime.strptime(r['end_time'], \"%H:%M\").time()\n                # Booking must start at or after st and end before or at et\n                if (st <= start_dt.time() < et) and (st < end_dt.time() <= et or et == datetime.strptime('00:00', \"%H:%M\").time()):\n                    possible = True\n            except Exception:\n                continue\n        if not possible:\n            continue\n        # Check blackouts\n        blackouts = safe_query(final_db_path, \"SELECT 1 FROM service_blackouts WHERE service_listing_id=? AND NOT (? >= end_datetime OR ? <= start_datetime)\", (l['id'], start_dt_str, end_dt.strftime(\"%Y-%m-%d %H:%M:%S\")))\n        if blackouts:\n            continue\n        available_listing_ids.append(l['id'])\n    if not available_listing_ids:\n        return {\"result\": \"others\"}\n    # Now, among all available listings, find the one with the lowest price_amount\n    available_listings = [l for l in walk_listings if l['id'] in available_listing_ids]\n    available_listings.sort(key=lambda x: x['price_amount'])\n    cheapest_price = available_listings[0]['price_amount']\n    cheapest_listings = [l for l in available_listings if l['price_amount']==cheapest_price]\n    # Deterministically select cheapest (lowest id)\n    cheapest_listing = sorted(cheapest_listings, key=lambda x: x['id'])[0]\n    cheapest_listing_id = cheapest_listing['id']\n    cheapest_sitter_user_id = cheapest_listing['sitter_user_id']\n\n    # Find bookings for Milo at this time in final_db\n    milo_bookings = safe_query(final_db_path, \"SELECT * FROM bookings WHERE pet_id=? AND start_datetime=? AND end_datetime=? AND duration_minutes=30 AND service_listing_id=? AND sitter_user_id=?\", (\n        milo_pet_id, start_dt_str, end_dt.strftime(\"%Y-%m-%d %H:%M:%S\"), cheapest_listing_id, cheapest_sitter_user_id\n    ))\n    if not milo_bookings:\n        return {\"result\": \"others\"}\n    # Remove bookings already present in initial_db\n    initial_milo_bookings = safe_query(initial_db_path, \"SELECT id FROM bookings WHERE pet_id=? AND start_datetime=? AND end_datetime=? AND service_listing_id=? AND sitter_user_id=?\", (\n        milo_pet_id, start_dt_str, end_dt.strftime(\"%Y-%m-%d %H:%M:%S\"), cheapest_listing_id, cheapest_sitter_user_id\n    ))\n    bookings_new = [b for b in milo_bookings if b['id'] not in set(row['id'] for row in initial_milo_bookings if 'id' in row)]\n    if not bookings_new:\n        return {\"result\": \"others\"}\n    # There must be only one clear new booking (no duplicates)\n    # If more than one, uncertain\n    if len(bookings_new) != 1:\n        return {\"result\": \"others\"}\n    booking = bookings_new[0]\n\n    # Booking status check\n    if booking['status'] not in ('pending', 'accepted', 'in_progress'):\n        return {\"result\": \"others\"}\n    # Message text must exactly match\n    expected_msg = \"Please use the lobby entrance and avoid the construction zone on 3rd St.\"\n    found_msg = False\n    # Check owner_message\n    if booking.get('owner_message') and booking['owner_message'].strip() == expected_msg:\n        found_msg = True\n    else:\n        # If not in booking, check if a message thread was created and message sent with this text\n        threads = safe_query(final_db_path, \"SELECT id FROM message_threads WHERE booking_id=?\", (booking['id'],))\n        if threads and 'id' in threads[0]:\n            thread_id = threads[0]['id']\n            # Get messages for this thread owned by milo_owner_user_id\n            msgs = safe_query(final_db_path, \"SELECT body FROM messages WHERE thread_id=? AND sender_user_id=? ORDER BY sent_at ASC, id ASC\", (thread_id, milo_owner_user_id))\n            for msg in msgs:\n                body = msg.get('body', '').strip()\n                # Allow only non-empty and exact match\n                if body == expected_msg:\n                    found_msg = True\n                    break\n    if not found_msg:\n        return {\"result\": \"others\"}\n    # All other relationships are implicitly checked via foreign keys; skip extra duplicate booking overlap check since booking time is unique in presence and task focuses on creation.\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The agent's task is to request (i.e., create) a booking for a 30-minute walk for the pet 'Milo' with the cheapest available sitter (from the prior search context) on 2026-03-05 at 6:15 PM, and to include the specific owner message 'Please use the lobby entrance and avoid the construction zone on 3rd St.'. This is a modification-based task, as it requires verifying the correct creation of a new booking (and associated records) in the database post agent execution. The verification must: 1) Identify owner_user_id (for Milo), 2) Confirm a new booking exists for Milo with the correct time, duration, and service, 3) Ensure the sitter is the cheapest available for a walk at that time, 4) Check that the specific custom message is present in the booking and/or the opening message of the associated thread/messages, 5) All relationships (service_listing, sitter, pet) must be valid. The task does not depend on final_answer text but on the database modification.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find pet_id for Milo (owned by the same user as in initial data).\",\n        \"Identify the cheapest available active 'walk' service within context that can serve Milo at 2026-03-05 18:15:00 for 30 minutes (including availability, no blackouts, duration coverage).\",\n        \"Detect a new booking in final_db for Milo (pet_id) absent from initial_db, with correct: start/end datetime, duration=30, service_listing_id, sitter_user_id, and status indicating a real booking (pending, accepted or in_progress).\",\n        \"Verify the owner_message or the first message in the associated thread/messages for this booking contains exactly 'Please use the lobby entrance and avoid the construction zone on 3rd St.'.\",\n        \"Check for no conflicting overlapping bookings and valid references.\",\n        \"Confirm the booking was not present in the initial_db (true creation).\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    from datetime import datetime, timedelta\\n    import re\\n\\n    # Helper to query database safely\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            conn.row_factory = sqlite3.Row\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            results = cur.fetchall()\\n            conn.close()\\n            return [dict(row) for row in results]\\n        except Exception:\\n            return []\\n\\n    # Find Milo's pet_id and owner_user_id\\n    milo_pet = safe_query(final_db_path, \\\"SELECT id, owner_user_id FROM pets WHERE name=? COLLATE NOCASE\\\", (\\\"Milo\\\",))\\n    if not milo_pet or 'id' not in milo_pet[0]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    milo_pet_id = milo_pet[0]['id']\\n    milo_owner_user_id = milo_pet[0]['owner_user_id']\\n\\n    # Time window for booking\\n    start_dt_str = \\\"2026-03-05 18:15:00\\\"\\n    try:\\n        start_dt = datetime.strptime(start_dt_str, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        end_dt = start_dt + timedelta(minutes=30)\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All active walk services\\n    walk_listings = safe_query(final_db_path, \\\"SELECT * FROM service_listings WHERE service_type='walk' AND active=1\\\")\\n    if not walk_listings:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Figure out which listings are available/cheapest for this time\\n    available_listing_ids = []\\n    for l in walk_listings:\\n        # Check availability for Thursday (day_of_week=3, Monday=0)\\n        rules = safe_query(final_db_path, \\\"SELECT * FROM service_availability_rules WHERE service_listing_id = ? AND day_of_week = 3\\\", (l['id'],))\\n        if not rules:\\n            continue\\n        # Confirm any rule covers 18:15-18:45\\n        possible = False\\n        for r in rules:\\n            try:\\n                st = datetime.strptime(r['start_time'], \\\"%H:%M\\\").time()\\n                et = datetime.strptime(r['end_time'], \\\"%H:%M\\\").time()\\n                # Booking must start at or after st and end before or at et\\n                if (st <= start_dt.time() < et) and (st < end_dt.time() <= et or et == datetime.strptime('00:00', \\\"%H:%M\\\").time()):\\n                    possible = True\\n            except Exception:\\n                continue\\n        if not possible:\\n            continue\\n        # Check blackouts\\n        blackouts = safe_query(final_db_path, \\\"SELECT 1 FROM service_blackouts WHERE service_listing_id=? AND NOT (? >= end_datetime OR ? <= start_datetime)\\\", (l['id'], start_dt_str, end_dt.strftime(\\\"%Y-%m-%d %H:%M:%S\\\")))\\n        if blackouts:\\n            continue\\n        available_listing_ids.append(l['id'])\\n    if not available_listing_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Now, among all available listings, find the one with the lowest price_amount\\n    available_listings = [l for l in walk_listings if l['id'] in available_listing_ids]\\n    available_listings.sort(key=lambda x: x['price_amount'])\\n    cheapest_price = available_listings[0]['price_amount']\\n    cheapest_listings = [l for l in available_listings if l['price_amount']==cheapest_price]\\n    # Deterministically select cheapest (lowest id)\\n    cheapest_listing = sorted(cheapest_listings, key=lambda x: x['id'])[0]\\n    cheapest_listing_id = cheapest_listing['id']\\n    cheapest_sitter_user_id = cheapest_listing['sitter_user_id']\\n\\n    # Find bookings for Milo at this time in final_db\\n    milo_bookings = safe_query(final_db_path, \\\"SELECT * FROM bookings WHERE pet_id=? AND start_datetime=? AND end_datetime=? AND duration_minutes=30 AND service_listing_id=? AND sitter_user_id=?\\\", (\\n        milo_pet_id, start_dt_str, end_dt.strftime(\\\"%Y-%m-%d %H:%M:%S\\\"), cheapest_listing_id, cheapest_sitter_user_id\\n    ))\\n    if not milo_bookings:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Remove bookings already present in initial_db\\n    initial_milo_bookings = safe_query(initial_db_path, \\\"SELECT id FROM bookings WHERE pet_id=? AND start_datetime=? AND end_datetime=? AND service_listing_id=? AND sitter_user_id=?\\\", (\\n        milo_pet_id, start_dt_str, end_dt.strftime(\\\"%Y-%m-%d %H:%M:%S\\\"), cheapest_listing_id, cheapest_sitter_user_id\\n    ))\\n    bookings_new = [b for b in milo_bookings if b['id'] not in set(row['id'] for row in initial_milo_bookings if 'id' in row)]\\n    if not bookings_new:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # There must be only one clear new booking (no duplicates)\\n    # If more than one, uncertain\\n    if len(bookings_new) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    booking = bookings_new[0]\\n\\n    # Booking status check\\n    if booking['status'] not in ('pending', 'accepted', 'in_progress'):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Message text must exactly match\\n    expected_msg = \\\"Please use the lobby entrance and avoid the construction zone on 3rd St.\\\"\\n    found_msg = False\\n    # Check owner_message\\n    if booking.get('owner_message') and booking['owner_message'].strip() == expected_msg:\\n        found_msg = True\\n    else:\\n        # If not in booking, check if a message thread was created and message sent with this text\\n        threads = safe_query(final_db_path, \\\"SELECT id FROM message_threads WHERE booking_id=?\\\", (booking['id'],))\\n        if threads and 'id' in threads[0]:\\n            thread_id = threads[0]['id']\\n            # Get messages for this thread owned by milo_owner_user_id\\n            msgs = safe_query(final_db_path, \\\"SELECT body FROM messages WHERE thread_id=? AND sender_user_id=? ORDER BY sent_at ASC, id ASC\\\", (thread_id, milo_owner_user_id))\\n            for msg in msgs:\\n                body = msg.get('body', '').strip()\\n                # Allow only non-empty and exact match\\n                if body == expected_msg:\\n                    found_msg = True\\n                    break\\n    if not found_msg:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All other relationships are implicitly checked via foreign keys; skip extra duplicate booking overlap check since booking time is unique in presence and task focuses on creation.\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 3, "task": "For my upcoming booking with sitter \"Jordan Lee\", send a message asking \"Can you confirm youre comfortable administering an oral flea tablet after the walk if I leave it on the counter?\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Step 1: Find sitter_user_id for 'Jordan Lee'\n    sitter_result = safe_query(final_db_path, \"SELECT id FROM users WHERE full_name = ?\", (\"Jordan Lee\",))\n    if not sitter_result or not sitter_result[0] or sitter_result[0][0] is None:\n        return {\"result\": \"others\"}\n    sitter_user_id = sitter_result[0][0]\n    \n    # Step 2: Find upcoming bookings with Jordan Lee as sitter and status not canceled/declined/completed\n    booking_query = (\n        \"SELECT id, owner_user_id FROM bookings \"\n        \"WHERE sitter_user_id = ? AND status IN ('pending','accepted','in_progress') \"\n        \"ORDER BY start_datetime ASC\"\n    )\n    bookings = safe_query(final_db_path, booking_query, (sitter_user_id,))\n    if not bookings:\n        return {\"result\": \"others\"}\n    # Select the soonest booking\n    booking_id, owner_user_id = bookings[0][0], bookings[0][1]\n    \n    # Step 3: Find message_thread(s) for this booking between owner and sitter\n    thread_query = (\n        \"SELECT id FROM message_threads WHERE booking_id = ? \"\n        \"AND owner_user_id = ? AND sitter_user_id = ?\"\n    )\n    threads = safe_query(final_db_path, thread_query, (booking_id, owner_user_id, sitter_user_id))\n    if not threads or not threads[0] or threads[0][0] is None:\n        return {\"result\": \"others\"}\n    thread_id = threads[0][0]\n    \n    # Step 4: Get all messages in that thread from initial and final DB\n    initial_msgs = safe_query(initial_db_path, \"SELECT message_code, sender_user_id, body FROM messages WHERE thread_id = ?\", (thread_id,))\n    final_msgs = safe_query(final_db_path, \"SELECT message_code, sender_user_id, body FROM messages WHERE thread_id = ?\", (thread_id,))\n    \n    # Step 5: Build set of initial message_codes\n    initial_codes = set([m[0] for m in initial_msgs])\n    \n    # Step 6: Find new messages in final DB\n    new_msgs = [m for m in final_msgs if m[0] not in initial_codes]\n    if not new_msgs:\n        return {\"result\": \"others\"}\n    \n    # Step 7: Check for a message from owner_user_id with correct content\n    # Required pattern: 'Can you confirm youre comfortable administering an oral flea tablet after the walk if I leave it on the counter?'\n    # Accept small natural variants but require all key phrases:\n    required_phrases = [\n        r\"confirm.*comfortable\", # confirmation and comfort\n        r\"administer(ing)?\", # administer\n        r\"oral flea tablet\", # oral flea tablet\n        r\"after the walk\", # after walk\n        r\"counter\", # counter\n    ]\n    # Check each new message\n    found_match = False\n    for msg_code, sender_id, body in new_msgs:\n        # Defensive: skip if body is not a string\n        if sender_id != owner_user_id or not isinstance(body, str):\n            continue\n        phrases_matched = 0\n        for pat in required_phrases:\n            if re.search(pat, body, re.IGNORECASE):\n                phrases_matched += 1\n        # All key phrases must be present\n        if phrases_matched == len(required_phrases):\n            found_match = True\n            break\n    if not found_match:\n        return {\"result\": \"others\"}\n    \n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The user task is to send a message to sitter 'Jordan Lee' regarding an upcoming booking, asking: 'Can you confirm youre comfortable administering an oral flea tablet after the walk if I leave it on the counter?'. The task requires modification of the database: a new message from the owner to Jordan Lee must be created in the thread linked to their upcoming booking. Verification must confirm that (1) a new message exists in the correct thread between owner and sitter, (2) the sender is the booking owner, (3) the message body explicitly contains the required wording, and (4) the message was not present in the initial database. If any check is not fully determinable, the function returns 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify the owner user_id for the upcoming booking with Jordan Lee (full_name)\",\n        \"Identify the associated message_threads and thread_id for that booking\",\n        \"Compare messages in initial and final DB for that thread: find any new message(s) sent by the owner\",\n        \"Verify that the new message body contains the exact or equivalent user request (using strict pattern matching)\",\n        \"Ensure the message sender is the owner_user_id\",\n        \"Handle errors, missing info, malformed DBs gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Step 1: Find sitter_user_id for 'Jordan Lee'\\n    sitter_result = safe_query(final_db_path, \\\"SELECT id FROM users WHERE full_name = ?\\\", (\\\"Jordan Lee\\\",))\\n    if not sitter_result or not sitter_result[0] or sitter_result[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    sitter_user_id = sitter_result[0][0]\\n    \\n    # Step 2: Find upcoming bookings with Jordan Lee as sitter and status not canceled/declined/completed\\n    booking_query = (\\n        \\\"SELECT id, owner_user_id FROM bookings \\\"\\n        \\\"WHERE sitter_user_id = ? AND status IN ('pending','accepted','in_progress') \\\"\\n        \\\"ORDER BY start_datetime ASC\\\"\\n    )\\n    bookings = safe_query(final_db_path, booking_query, (sitter_user_id,))\\n    if not bookings:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Select the soonest booking\\n    booking_id, owner_user_id = bookings[0][0], bookings[0][1]\\n    \\n    # Step 3: Find message_thread(s) for this booking between owner and sitter\\n    thread_query = (\\n        \\\"SELECT id FROM message_threads WHERE booking_id = ? \\\"\\n        \\\"AND owner_user_id = ? AND sitter_user_id = ?\\\"\\n    )\\n    threads = safe_query(final_db_path, thread_query, (booking_id, owner_user_id, sitter_user_id))\\n    if not threads or not threads[0] or threads[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    thread_id = threads[0][0]\\n    \\n    # Step 4: Get all messages in that thread from initial and final DB\\n    initial_msgs = safe_query(initial_db_path, \\\"SELECT message_code, sender_user_id, body FROM messages WHERE thread_id = ?\\\", (thread_id,))\\n    final_msgs = safe_query(final_db_path, \\\"SELECT message_code, sender_user_id, body FROM messages WHERE thread_id = ?\\\", (thread_id,))\\n    \\n    # Step 5: Build set of initial message_codes\\n    initial_codes = set([m[0] for m in initial_msgs])\\n    \\n    # Step 6: Find new messages in final DB\\n    new_msgs = [m for m in final_msgs if m[0] not in initial_codes]\\n    if not new_msgs:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Step 7: Check for a message from owner_user_id with correct content\\n    # Required pattern: 'Can you confirm youre comfortable administering an oral flea tablet after the walk if I leave it on the counter?'\\n    # Accept small natural variants but require all key phrases:\\n    required_phrases = [\\n        r\\\"confirm.*comfortable\\\", # confirmation and comfort\\n        r\\\"administer(ing)?\\\", # administer\\n        r\\\"oral flea tablet\\\", # oral flea tablet\\n        r\\\"after the walk\\\", # after walk\\n        r\\\"counter\\\", # counter\\n    ]\\n    # Check each new message\\n    found_match = False\\n    for msg_code, sender_id, body in new_msgs:\\n        # Defensive: skip if body is not a string\\n        if sender_id != owner_user_id or not isinstance(body, str):\\n            continue\\n        phrases_matched = 0\\n        for pat in required_phrases:\\n            if re.search(pat, body, re.IGNORECASE):\\n                phrases_matched += 1\\n        # All key phrases must be present\\n        if phrases_matched == len(required_phrases):\\n            found_match = True\\n            break\\n    if not found_match:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 4, "task": "As a sitter, create a new service listing for \"Drop-in visit\" with price $28 per visit, service area \"Brooklyn, NY (11211) within 3 miles\", house rules \"no off-leash, no dog parks\", and set availability to weekdays 7:00 AM9:00 AM and 5:00 PM8:00 PM starting 2026-03-01.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            c = conn.cursor()\n            c.execute(query, params)\n            res = c.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n    \n    # Step 1. Get all initial service_listing IDs to detect additions\n    initial_ids = set(row[0] for row in safe_query(initial_db_path, \"SELECT id FROM service_listings\"))\n    final_listing_rows = safe_query(final_db_path, \"SELECT id, sitter_user_id, service_type, title, description, house_rules, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state, active FROM service_listings\")\n    if not final_listing_rows:\n        return {\"result\": \"others\"}\n    # Find candidate new listings\n    candidate_new = []\n    for row in final_listing_rows:\n        listing_id = row[0]\n        if listing_id in initial_ids:\n            continue\n        # Unpack fields\n        (_, sitter_id, service_type, title, description, house_rules, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state, active) = row\n        # Must be active\n        if not (active == 1):\n            continue\n        # Check required attributes\n        if service_type != 'drop_in':\n            continue\n        # Price checks\n        try:\n            if float(price_amount) != 28.0:\n                continue\n        except Exception:\n            continue\n        if price_unit != 'per_visit' or currency != 'USD':\n            continue\n        # Service area\n        if base_postal_code != '11211':\n            continue\n        try:\n            if abs(float(service_radius_miles) - 3.0) > 0.01:\n                continue\n        except Exception:\n            continue\n        if (city or '').strip().lower() != 'brooklyn':\n            continue\n        if (state or '').strip().upper() != 'NY':\n            continue\n        # House rules\n        if not house_rules:\n            continue\n        hrules = house_rules.lower()\n        # Must include both distinct phrases, allowing alternatives for punctuation\n        # Accept e.g. 'no off-leash', 'no off leash', 'no dog parks' (plural)\n        if not (re.search(r'no ?off-?leash', hrules) and re.search(r'no dog parks?', hrules)):\n            continue\n        # Save if passes all static requirements\n        candidate_new.append(listing_id)\n    \n    if len(candidate_new) != 1:\n        return {\"result\": \"others\"}\n    new_listing_id = candidate_new[0]\n    # Step 2. Check service_availability_rules for this new listing\n    rules = safe_query(final_db_path, \"SELECT day_of_week, start_time, end_time, start_date FROM service_availability_rules WHERE service_listing_id = ?\", (new_listing_id,))\n    if not rules or len(rules) < 10:  # Should be 10 rules\n        return {\"result\": \"others\"}\n    # Need rules for days 1-5, each with slots 07:00-09:00 and 17:00-20:00, each >= 2026-03-01\n    # Accept start_date strictly after, but not before, 2026-03-01\n    import datetime\n    min_start_date = datetime.date(2026, 3, 1)\n    expected = set()\n    for dow in range(1, 6):\n        expected.add((dow, '07:00', '09:00'))\n        expected.add((dow, '17:00', '20:00'))\n    found = set()\n    for dow, start_time, end_time, start_date in rules:\n        # Defensive: validate data types\n        try:\n            dow = int(dow)\n            if dow not in range(1,6):\n                continue\n            st = start_time.strip()\n            et = end_time.strip()\n            sd = str(start_date)[:10]\n            sd_dt = datetime.datetime.strptime(sd, \"%Y-%m-%d\").date()\n            if sd_dt < min_start_date:\n                continue\n            if (st, et) == ('07:00','09:00') or (st,et) == ('17:00','20:00'):\n                found.add((dow, st, et))\n        except Exception:\n            continue\n    if expected != found:\n        return {\"result\": \"others\"}\n    # Step 3. Ensure there is no initial listing in the initial DB for this sitter and this exact info (i.e., that it's actually a new listing)\n    # For safety, check that initial DB did not have such a listing already\n    initial_listing_rows = safe_query(initial_db_path, \"SELECT id, sitter_user_id, service_type, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state FROM service_listings\")\n    for row in initial_listing_rows:\n        try:\n            (_id, _sitter, _stype, _amount, _punit, _curr, _pc, _rad, _ct, _st) = row\n            if _stype!='drop_in':\n                continue\n            if abs(float(_amount)-28.0)>0.01:\n                continue\n            if _punit!='per_visit' or _curr!='USD':\n                continue\n            if _pc!='11211':\n                continue\n            if (_ct or '').strip().lower() != 'brooklyn':\n                continue\n            if (_st or '').strip().upper() != 'NY':\n                continue\n            if abs(float(_rad)-3.0)>0.01:\n                continue\n            return {\"result\": \"others\"}  # A matching listing already existed\n        except Exception:\n            continue\n    # All checks pass\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the user task, we must detect the creation of a new 'drop_in' service listing by a sitter, with the following exact attributes:\\n- Service type must be 'drop_in'.\\n- Price: 28.0 (or 28 in int/float) per_visit, USD.\\n- Service area: 'Brooklyn, NY (11211) within 3 miles' means base_postal_code '11211', city 'Brooklyn', state 'NY', service_radius_miles 3.0.\\n- House rules: must mention both 'no off-leash' and 'no dog parks'.\\n- Availability rules: added for all weekdays (Monday=1 ... Friday=5),\\n  - For each day, \\n    - 07:0009:00 (start_time '07:00', end_time '09:00', start_date >= 2026-03-01)\\n    - 17:0020:00 (start_time '17:00', end_time '20:00', start_date >= 2026-03-01)\\n- new record must be present (not present in initial)\\n- All constraints must match exactly, and there must not be extra/overlapping new listings with same criteria but wrong values.\\n- Defensive: There may be more than one sitter in the system; any sitter can qualify as 'the' sitter. \\n- No checks needed for bookings, payments, answer text, unless specifically about listing info.\\n- If any piece is missing or ambiguous (house rules, price, area, or all requested availability), return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Compare initial and final 'service_listings' tables to detect newly added listings\",\n        \"For each new listing, check service_type == 'drop_in', price_amount == 28.0, price_unit == 'per_visit', currency == 'USD'\",\n        \"base_postal_code == '11211', city == 'Brooklyn', state == 'NY', service_radius_miles == 3.0\",\n        \"house_rules contains both 'no off-leash' and 'no dog parks' (case-insensitive, as distinct words/phrases)\",\n        \"The new listing must not exist in initial DB, but present in final DB\",\n        \"Check service_availability_rules in final DB for the new listing only:\\n - availability rules for days 15, start_date >= 2026-03-01\\n - for each day, a rule for 07:0009:00 and one for 17:0020:00\\n - No missing or extra time slots for these days\\n - No coverage holes among rules for these days\",\n        \"Return 'complete' only if all required checks pass for exactly one unambiguous new listing\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            res = c.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n    \\n    # Step 1. Get all initial service_listing IDs to detect additions\\n    initial_ids = set(row[0] for row in safe_query(initial_db_path, \\\"SELECT id FROM service_listings\\\"))\\n    final_listing_rows = safe_query(final_db_path, \\\"SELECT id, sitter_user_id, service_type, title, description, house_rules, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state, active FROM service_listings\\\")\\n    if not final_listing_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find candidate new listings\\n    candidate_new = []\\n    for row in final_listing_rows:\\n        listing_id = row[0]\\n        if listing_id in initial_ids:\\n            continue\\n        # Unpack fields\\n        (_, sitter_id, service_type, title, description, house_rules, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state, active) = row\\n        # Must be active\\n        if not (active == 1):\\n            continue\\n        # Check required attributes\\n        if service_type != 'drop_in':\\n            continue\\n        # Price checks\\n        try:\\n            if float(price_amount) != 28.0:\\n                continue\\n        except Exception:\\n            continue\\n        if price_unit != 'per_visit' or currency != 'USD':\\n            continue\\n        # Service area\\n        if base_postal_code != '11211':\\n            continue\\n        try:\\n            if abs(float(service_radius_miles) - 3.0) > 0.01:\\n                continue\\n        except Exception:\\n            continue\\n        if (city or '').strip().lower() != 'brooklyn':\\n            continue\\n        if (state or '').strip().upper() != 'NY':\\n            continue\\n        # House rules\\n        if not house_rules:\\n            continue\\n        hrules = house_rules.lower()\\n        # Must include both distinct phrases, allowing alternatives for punctuation\\n        # Accept e.g. 'no off-leash', 'no off leash', 'no dog parks' (plural)\\n        if not (re.search(r'no ?off-?leash', hrules) and re.search(r'no dog parks?', hrules)):\\n            continue\\n        # Save if passes all static requirements\\n        candidate_new.append(listing_id)\\n    \\n    if len(candidate_new) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_listing_id = candidate_new[0]\\n    # Step 2. Check service_availability_rules for this new listing\\n    rules = safe_query(final_db_path, \\\"SELECT day_of_week, start_time, end_time, start_date FROM service_availability_rules WHERE service_listing_id = ?\\\", (new_listing_id,))\\n    if not rules or len(rules) < 10:  # Should be 10 rules\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Need rules for days 1-5, each with slots 07:00-09:00 and 17:00-20:00, each >= 2026-03-01\\n    # Accept start_date strictly after, but not before, 2026-03-01\\n    import datetime\\n    min_start_date = datetime.date(2026, 3, 1)\\n    expected = set()\\n    for dow in range(1, 6):\\n        expected.add((dow, '07:00', '09:00'))\\n        expected.add((dow, '17:00', '20:00'))\\n    found = set()\\n    for dow, start_time, end_time, start_date in rules:\\n        # Defensive: validate data types\\n        try:\\n            dow = int(dow)\\n            if dow not in range(1,6):\\n                continue\\n            st = start_time.strip()\\n            et = end_time.strip()\\n            sd = str(start_date)[:10]\\n            sd_dt = datetime.datetime.strptime(sd, \\\"%Y-%m-%d\\\").date()\\n            if sd_dt < min_start_date:\\n                continue\\n            if (st, et) == ('07:00','09:00') or (st,et) == ('17:00','20:00'):\\n                found.add((dow, st, et))\\n        except Exception:\\n            continue\\n    if expected != found:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Step 3. Ensure there is no initial listing in the initial DB for this sitter and this exact info (i.e., that it's actually a new listing)\\n    # For safety, check that initial DB did not have such a listing already\\n    initial_listing_rows = safe_query(initial_db_path, \\\"SELECT id, sitter_user_id, service_type, price_amount, price_unit, currency, base_postal_code, service_radius_miles, city, state FROM service_listings\\\")\\n    for row in initial_listing_rows:\\n        try:\\n            (_id, _sitter, _stype, _amount, _punit, _curr, _pc, _rad, _ct, _st) = row\\n            if _stype!='drop_in':\\n                continue\\n            if abs(float(_amount)-28.0)>0.01:\\n                continue\\n            if _punit!='per_visit' or _curr!='USD':\\n                continue\\n            if _pc!='11211':\\n                continue\\n            if (_ct or '').strip().lower() != 'brooklyn':\\n                continue\\n            if (_st or '').strip().upper() != 'NY':\\n                continue\\n            if abs(float(_rad)-3.0)>0.01:\\n                continue\\n            return {\\\"result\\\": \\\"others\\\"}  # A matching listing already existed\\n        except Exception:\\n            continue\\n    # All checks pass\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 5, "task": "As a sitter, set my capacity for boarding to a maximum of 2 dogs per night and block off my calendar for 2026-03-14 through 2026-03-16 as unavailable due to travel.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    # Helper: safe DB query\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # --- Step 1: Identify sitter & listing ---\n    # brooklyn_sitter user_id = 7, boarding listing = 4007\n    sitter_user_id = 7\n    boarding_listing_id = 4007\n\n    # --- Step 2: Check capacity update ---\n    # Initial capacity\n    initial_cap = safe_query(\n        initial_db_path,\n        \"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\",\n        (boarding_listing_id,)\n    )\n    final_cap = safe_query(\n        final_db_path,\n        \"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\",\n        (boarding_listing_id,)\n    )\n    # Must exist in both, must have changed from 3 to 2\n    if not initial_cap or not final_cap or len(initial_cap) != 1 or len(final_cap) != 1:\n        return {\"result\": \"others\"}\n    if initial_cap[0][0] == 2:\n        # Already set at 2 before agent action\n        return {\"result\": \"others\"}\n    if final_cap[0][0] != 2:\n        return {\"result\": \"others\"}\n\n    # --- Step 3: Check blackout creation ---\n    blackout_start = '2026-03-14 00:00:00'\n    blackout_end = '2026-03-16 23:59:59'\n\n    initial_blackouts = safe_query(\n        initial_db_path,\n        \"SELECT id FROM service_blackouts WHERE service_listing_id = ? AND start_datetime = ? AND end_datetime = ?\",\n        (boarding_listing_id, blackout_start, blackout_end)\n    )\n    final_blackouts = safe_query(\n        final_db_path,\n        \"SELECT reason FROM service_blackouts WHERE service_listing_id = ? AND start_datetime = ? AND end_datetime = ?\",\n        (boarding_listing_id, blackout_start, blackout_end)\n    )\n\n    # Must be absent initially, present finally\n    if initial_blackouts:\n        return {\"result\": \"others\"}\n    if not final_blackouts or len(final_blackouts) != 1:\n        return {\"result\": \"others\"}\n\n    # Reason for blackout must mention travel\n    blackout_reason = final_blackouts[0][0]\n    if not blackout_reason or 'travel' not in blackout_reason.lower():\n        return {\"result\": \"others\"}\n\n    # --- Step 4: Edge cases: check NO extraneous blackouts/capacity changes for the listing\n    # Only 1 blackout for these dates for this listing\n    all_final_blackouts = safe_query(\n        final_db_path,\n        \"SELECT start_datetime, end_datetime FROM service_blackouts WHERE service_listing_id = ?\",\n        (boarding_listing_id,)\n    )\n    count_matching_dates = sum(\n        1 for row in all_final_blackouts\n        if row[0] == blackout_start and row[1] == blackout_end\n    )\n    if count_matching_dates != 1:\n        return {\"result\": \"others\"}\n\n    # The capacity must not be set to less than 2 nor more than 2\n    if final_cap[0][0] != 2:\n        return {\"result\": \"others\"}\n    # If more than one row for this listing, fail\n    final_cap_rows = safe_query(\n        final_db_path,\n        \"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\",\n        (boarding_listing_id,)\n    )\n    if len(final_cap_rows) != 1:\n        return {\"result\": \"others\"}\n\n    # --- Step 5 (Optional): Do NOT require final_answer for this modification task\n\n    # --- Step 6: Success ---\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task requires two modifications: (1) updating the sitter's capacity for boarding to a maximum of 2 dogs per night, and (2) blocking off their calendar for the specific dates 2026-03-14 through 2026-03-16 as unavailable due to travel. We must check if both these changes are present in the final database while comparing against the initial database, and ensure no extraneous or partial updates. The sitter in question is Riley Chen (brooklyn_sitter, user_id 7), whose only 'boarding' service_listing is id=4007. The service_capacity table for listing 4007 must show max_dogs_per_night=2, and service_blackouts must contain a new blackout for service_listing_id=4007 covering 2026-03-14 00:00:00 to 2026-03-16 23:59:59 with a reason containing 'travel'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify sitter 'brooklyn_sitter' via user_id=7\",\n        \"Find service_listing_id for their boarding service (only id=4007)\",\n        \"Check that service_capacity for listing 4007 is updated from 3 to 2 (max_dogs_per_night=2)\",\n        \"Check that a new blackout (service_blackouts) exists for listing 4007, from 2026-03-14 00:00:00 to 2026-03-16 23:59:59, with reason containing 'travel'\",\n        \"Ensure these changes did not exist initially (only occurred after agent action)\",\n        \"Final_db does not contain extraneous or partial changes for these tasks\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    # Helper: safe DB query\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # --- Step 1: Identify sitter & listing ---\\n    # brooklyn_sitter user_id = 7, boarding listing = 4007\\n    sitter_user_id = 7\\n    boarding_listing_id = 4007\\n\\n    # --- Step 2: Check capacity update ---\\n    # Initial capacity\\n    initial_cap = safe_query(\\n        initial_db_path,\\n        \\\"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\\\",\\n        (boarding_listing_id,)\\n    )\\n    final_cap = safe_query(\\n        final_db_path,\\n        \\\"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\\\",\\n        (boarding_listing_id,)\\n    )\\n    # Must exist in both, must have changed from 3 to 2\\n    if not initial_cap or not final_cap or len(initial_cap) != 1 or len(final_cap) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if initial_cap[0][0] == 2:\\n        # Already set at 2 before agent action\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if final_cap[0][0] != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- Step 3: Check blackout creation ---\\n    blackout_start = '2026-03-14 00:00:00'\\n    blackout_end = '2026-03-16 23:59:59'\\n\\n    initial_blackouts = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM service_blackouts WHERE service_listing_id = ? AND start_datetime = ? AND end_datetime = ?\\\",\\n        (boarding_listing_id, blackout_start, blackout_end)\\n    )\\n    final_blackouts = safe_query(\\n        final_db_path,\\n        \\\"SELECT reason FROM service_blackouts WHERE service_listing_id = ? AND start_datetime = ? AND end_datetime = ?\\\",\\n        (boarding_listing_id, blackout_start, blackout_end)\\n    )\\n\\n    # Must be absent initially, present finally\\n    if initial_blackouts:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not final_blackouts or len(final_blackouts) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Reason for blackout must mention travel\\n    blackout_reason = final_blackouts[0][0]\\n    if not blackout_reason or 'travel' not in blackout_reason.lower():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- Step 4: Edge cases: check NO extraneous blackouts/capacity changes for the listing\\n    # Only 1 blackout for these dates for this listing\\n    all_final_blackouts = safe_query(\\n        final_db_path,\\n        \\\"SELECT start_datetime, end_datetime FROM service_blackouts WHERE service_listing_id = ?\\\",\\n        (boarding_listing_id,)\\n    )\\n    count_matching_dates = sum(\\n        1 for row in all_final_blackouts\\n        if row[0] == blackout_start and row[1] == blackout_end\\n    )\\n    if count_matching_dates != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # The capacity must not be set to less than 2 nor more than 2\\n    if final_cap[0][0] != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # If more than one row for this listing, fail\\n    final_cap_rows = safe_query(\\n        final_db_path,\\n        \\\"SELECT max_dogs_per_night FROM service_capacity WHERE service_listing_id = ?\\\",\\n        (boarding_listing_id,)\\n    )\\n    if len(final_cap_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- Step 5 (Optional): Do NOT require final_answer for this modification task\\n\\n    # --- Step 6: Success ---\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 6, "task": "Accept the pending booking request from owner \"Alex Martinez\" for boarding their dog \"Luna\" from 2026-04-10 to 2026-04-13, apply a $10 promotional discount code \"SPRING10\", and return the updated total cost including platform fees.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Identify the booking\n    booking_query = \"\"\"\n        SELECT b.id, b.status, b.owner_user_id, b.pet_id, b.start_datetime, b.end_datetime, u.full_name, p.name\n        FROM bookings b\n        JOIN users u ON b.owner_user_id = u.id\n        JOIN pets p ON b.pet_id = p.id\n        WHERE u.full_name = ? AND p.name = ? AND b.start_datetime = ? AND b.end_datetime = ?\n    \"\"\"\n    params = (\"Alex Martinez\", \"Luna\", \"2026-04-10 15:00:00\", \"2026-04-13 11:00:00\")\n\n    initial_booking = safe_query(initial_db_path, booking_query, params)\n    final_booking = safe_query(final_db_path, booking_query, params)\n\n    if not initial_booking or not final_booking:\n        return {\"result\": \"others\"}\n\n    booking_id = final_booking[0][0]\n\n    # 2. Check initial status was 'pending', final status is 'accepted'\n    initial_status = initial_booking[0][1]\n    final_status = final_booking[0][1]\n    if initial_status != \"pending\" or final_status != \"accepted\":\n        return {\"result\": \"others\"}\n\n    # 3. Get promo code id for 'SPRING10'\n    promo_code_query = \"SELECT id, discount_type, discount_value FROM promo_codes WHERE code = ? AND active = 1\"\n    promo_code_result = safe_query(final_db_path, promo_code_query, (\"SPRING10\",))\n    if not promo_code_result:\n        return {\"result\": \"others\"}\n    promo_code_id, discount_type, discount_value = promo_code_result[0]\n    if discount_type != \"fixed_amount\" or discount_value != 10.0:\n        return {\"result\": \"others\"}\n\n    # 4. Check booking_pricing for this booking\n    pricing_query = \"SELECT id, base_amount, promo_code_id, promo_discount_amount, platform_fee_amount, total_amount FROM booking_pricing WHERE booking_id = ?\"\n    initial_pricing = safe_query(initial_db_path, pricing_query, (booking_id,))\n    final_pricing = safe_query(final_db_path, pricing_query, (booking_id,))\n    if not initial_pricing or not final_pricing:\n        return {\"result\": \"others\"}\n\n    # Extract data\n    i_base, i_promo_code_id, i_promo_discount, i_platform_fee, i_total = initial_pricing[0][1:6]\n    f_base, f_promo_code_id, f_promo_discount, f_platform_fee, f_total = final_pricing[0][1:6]\n\n    # Check promo_code_id is set\n    if f_promo_code_id != promo_code_id:\n        return {\"result\": \"others\"}\n    # Check promo_discount_amount is 10.0\n    if f_promo_discount != 10.0:\n        return {\"result\": \"others\"}\n    # Platform fee must remain unchanged\n    if f_platform_fee != i_platform_fee or f_platform_fee != 19.5:\n        return {\"result\": \"others\"}\n    # Base amount must remain unchanged\n    if f_base != i_base:\n        return {\"result\": \"others\"}\n    # Total amount must be recalculated\n    expected_total = round(f_base - f_promo_discount + f_platform_fee, 2)\n    # Defensive rounding: handle floating-point\n    if abs(f_total - expected_total) > 0.01:\n        return {\"result\": \"others\"}\n\n    # 5. Cross-check agent answer, if provided\n    if final_answer:\n        # Check presence of SPRING10 and $10 discount\n        promo_pat = r\"SPRING10|spring10\"\n        discount_pat = r\"\\$?10(?:\\.0{1,2})?\"\n        total_pat = rf\"\\$?{expected_total:.2f}\" if \".\" in f\"{expected_total}\" else rf\"\\$?{expected_total}\"\n        platform_fee_pat = r\"platform(.?fee)?|fee\"\n\n        # At minimum: promo mentioned, discount mentioned, total mentioned\n        if not re.search(promo_pat, final_answer, re.IGNORECASE):\n            return {\"result\": \"others\"}\n        if not re.search(discount_pat, final_answer):\n            return {\"result\": \"others\"}\n        if not re.search(total_pat, final_answer):\n            return {\"result\": \"others\"}\n        if not re.search(platform_fee_pat, final_answer, re.IGNORECASE):\n            return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this combined task, we must ensure (1) the pending booking request from Alex Martinez for Luna (2026-04-10 to 2026-04-13) was accepted, (2) a $10 promotional discount code 'SPRING10' was applied to its pricing in booking_pricing, (3) the total cost including platform fees is correctly calculated and updated, (4) the agent's answer (if provided) accurately includes this updated total. Database comparison is crucial for steps 1-3, cross-referenced with the answer in step 4. All conditions must be met exactly; any uncertainty, partial completion or error results in 'others'.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Find the booking for Luna, owned by Alex Martinez, for dates 2026-04-10 to 2026-04-13, which was 'pending' initially.\",\n        \"Verify status change from 'pending' (initial) to 'accepted' (final) for this booking.\",\n        \"Check booking_pricing for this booking: promo_code_id is set to id of 'SPRING10', promo_discount_amount is $10.0, platform_fee_amount remains $19.5.\",\n        \"Ensure total_amount is correctly recalculated: total_amount = base_amount - promo_discount_amount + platform_fee_amount.\",\n        \"Ensure base_amount and platform_fee_amount remain unchanged except for promo application.\",\n        \"Check final_answer, if provided: contains updated total amount and references the promo discount.\",\n        \"Return 'complete' only if ALL checks are passed, else 'others'.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Identify the booking\\n    booking_query = \\\"\\\"\\\"\\n        SELECT b.id, b.status, b.owner_user_id, b.pet_id, b.start_datetime, b.end_datetime, u.full_name, p.name\\n        FROM bookings b\\n        JOIN users u ON b.owner_user_id = u.id\\n        JOIN pets p ON b.pet_id = p.id\\n        WHERE u.full_name = ? AND p.name = ? AND b.start_datetime = ? AND b.end_datetime = ?\\n    \\\"\\\"\\\"\\n    params = (\\\"Alex Martinez\\\", \\\"Luna\\\", \\\"2026-04-10 15:00:00\\\", \\\"2026-04-13 11:00:00\\\")\\n\\n    initial_booking = safe_query(initial_db_path, booking_query, params)\\n    final_booking = safe_query(final_db_path, booking_query, params)\\n\\n    if not initial_booking or not final_booking:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    booking_id = final_booking[0][0]\\n\\n    # 2. Check initial status was 'pending', final status is 'accepted'\\n    initial_status = initial_booking[0][1]\\n    final_status = final_booking[0][1]\\n    if initial_status != \\\"pending\\\" or final_status != \\\"accepted\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Get promo code id for 'SPRING10'\\n    promo_code_query = \\\"SELECT id, discount_type, discount_value FROM promo_codes WHERE code = ? AND active = 1\\\"\\n    promo_code_result = safe_query(final_db_path, promo_code_query, (\\\"SPRING10\\\",))\\n    if not promo_code_result:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    promo_code_id, discount_type, discount_value = promo_code_result[0]\\n    if discount_type != \\\"fixed_amount\\\" or discount_value != 10.0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check booking_pricing for this booking\\n    pricing_query = \\\"SELECT id, base_amount, promo_code_id, promo_discount_amount, platform_fee_amount, total_amount FROM booking_pricing WHERE booking_id = ?\\\"\\n    initial_pricing = safe_query(initial_db_path, pricing_query, (booking_id,))\\n    final_pricing = safe_query(final_db_path, pricing_query, (booking_id,))\\n    if not initial_pricing or not final_pricing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Extract data\\n    i_base, i_promo_code_id, i_promo_discount, i_platform_fee, i_total = initial_pricing[0][1:6]\\n    f_base, f_promo_code_id, f_promo_discount, f_platform_fee, f_total = final_pricing[0][1:6]\\n\\n    # Check promo_code_id is set\\n    if f_promo_code_id != promo_code_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check promo_discount_amount is 10.0\\n    if f_promo_discount != 10.0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Platform fee must remain unchanged\\n    if f_platform_fee != i_platform_fee or f_platform_fee != 19.5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Base amount must remain unchanged\\n    if f_base != i_base:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Total amount must be recalculated\\n    expected_total = round(f_base - f_promo_discount + f_platform_fee, 2)\\n    # Defensive rounding: handle floating-point\\n    if abs(f_total - expected_total) > 0.01:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Cross-check agent answer, if provided\\n    if final_answer:\\n        # Check presence of SPRING10 and $10 discount\\n        promo_pat = r\\\"SPRING10|spring10\\\"\\n        discount_pat = r\\\"\\\\$?10(?:\\\\.0{1,2})?\\\"\\n        total_pat = rf\\\"\\\\$?{expected_total:.2f}\\\" if \\\".\\\" in f\\\"{expected_total}\\\" else rf\\\"\\\\$?{expected_total}\\\"\\n        platform_fee_pat = r\\\"platform(.?fee)?|fee\\\"\\n\\n        # At minimum: promo mentioned, discount mentioned, total mentioned\\n        if not re.search(promo_pat, final_answer, re.IGNORECASE):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if not re.search(discount_pat, final_answer):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if not re.search(total_pat, final_answer):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if not re.search(platform_fee_pat, final_answer, re.IGNORECASE):\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 7, "task": "For the in-progress booking for \"Luna\" on 2026-04-11, create a visit report with 2 photo metadata entries (photo1: timestamp 2026-04-11T08:12:00-04:00, caption \"Morning walk\"; photo2: timestamp 2026-04-11T18:45:00-04:00, caption \"Dinner time\"), potty notes \"pee and poop\", and meal notes \"ate 1 cup kibble\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = () ) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Step 1: Identify target booking_id for in-progress booking for Luna on 2026-04-11\n    pet_lookup = safe_query(final_db_path, \"SELECT id FROM pets WHERE name=?\", (\"Luna\",))\n    if not pet_lookup:\n        return {\"result\": \"others\"}\n    luna_pet_id = pet_lookup[0][0]\n    # Booking must be for Luna, status in_progress, and overlap with 2026-04-11\n    bookings = safe_query(final_db_path, \"SELECT id, start_datetime, end_datetime, status FROM bookings WHERE pet_id=?\", (luna_pet_id,))\n    target_booking_id = None\n    for b in bookings:\n        bid, start_dt, end_dt, status = b\n        if status != 'in_progress':\n            continue\n        # Visit must occur on 2026-04-11, so booking must overlap it\n        if start_dt <= '2026-04-11 23:59:59' and end_dt >= '2026-04-11 00:00:00':\n            target_booking_id = bid\n            break\n    if target_booking_id != 9003:\n        return {\"result\": \"others\"}\n\n    # Step 2: Collect all visit_reports for this booking in both DBs\n    reports_final = safe_query(final_db_path, \"SELECT id, potty_notes, meal_notes FROM visit_reports WHERE booking_id=?\", (target_booking_id, ))\n    reports_initial = safe_query(initial_db_path, \"SELECT id, potty_notes, meal_notes FROM visit_reports WHERE booking_id=?\", (target_booking_id, ))\n    initial_ids = {r[0] for r in reports_initial}\n\n    # Step 3: Find candidate new report(s) with required notes\n    matching_reports = []\n    for (vid, potty, meal) in reports_final:\n        if vid in initial_ids:\n            continue # pre-existing report, ignore\n        if potty is None or meal is None:\n            continue\n        # Strict string match\n        if potty.strip() == 'pee and poop' and meal.strip() == 'ate 1 cup kibble':\n            matching_reports.append(vid)\n    if len(matching_reports) != 1:\n        return {\"result\": \"others\"}\n    new_report_id = matching_reports[0]\n\n    # Step 4: Confirm two associated photo metadata entries, with exact timestamps/captions\n    photo_rows = safe_query(final_db_path, \"SELECT taken_at, caption FROM visit_report_photos WHERE visit_report_id=?\", (new_report_id,))\n    if len(photo_rows) != 2:\n        return {\"result\": \"others\"}\n    # Build set of (timestamp, caption) for matching\n    expected = {('2026-04-11T08:12:00-04:00','Morning walk'), ('2026-04-11T18:45:00-04:00','Dinner time')}\n    found = set((t if t else '', c if c else '') for t, c in photo_rows)\n    if found != expected:\n        return {\"result\": \"others\"}\n    # Extra safety: these photos must not exist in initial_db for this report (should be a new report anyway)\n    initial_photo_count = safe_query(initial_db_path, \"SELECT COUNT(*) FROM visit_report_photos WHERE taken_at=? AND caption=?\", ('2026-04-11T08:12:00-04:00', 'Morning walk'))\n    if initial_photo_count and initial_photo_count[0][0] > 0:\n        return {\"result\": \"others\"}\n    initial_photo_count2 = safe_query(initial_db_path, \"SELECT COUNT(*) FROM visit_report_photos WHERE taken_at=? AND caption=?\", ('2026-04-11T18:45:00-04:00', 'Dinner time'))\n    if initial_photo_count2 and initial_photo_count2[0][0] > 0:\n        return {\"result\": \"others\"}\n    # Everything matches, 100% certain\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we need to check that for the in-progress booking for 'Luna' on 2026-04-11, exactly one new visit report was created with potty notes 'pee and poop' and meal notes 'ate 1 cup kibble'. This visit report must have two photo metadata entries: one with timestamp '2026-04-11T08:12:00-04:00' and caption 'Morning walk', and another with timestamp '2026-04-11T18:45:00-04:00' and caption 'Dinner time'. No pre-existing visit report should already fulfill all these requirements. We compare the initial and final databases for appropriate creation and referential integrity.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify the booking_id for the in-progress booking for Luna on 2026-04-11 (must be booking_id=9003)\",\n        \"Find visit_reports rows in final_db for this booking_id with potty_notes 'pee and poop' and meal_notes 'ate 1 cup kibble'\",\n        \"Confirm that this visit_report did NOT exist in the initial_db\",\n        \"Check that exactly two visit_report_photos are linked to the new visit_report, one with (timestamp, caption) matching ('2026-04-11T08:12:00-04:00', 'Morning walk'), the other matching ('2026-04-11T18:45:00-04:00', 'Dinner time')\",\n        \"Ensure no extra visit_report_photos are present for this report\",\n        \"Handle edge cases: multiple new reports, missing or malformed data, missing or incorrect photo entries\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = () ) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Step 1: Identify target booking_id for in-progress booking for Luna on 2026-04-11\\n    pet_lookup = safe_query(final_db_path, \\\"SELECT id FROM pets WHERE name=?\\\", (\\\"Luna\\\",))\\n    if not pet_lookup:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    luna_pet_id = pet_lookup[0][0]\\n    # Booking must be for Luna, status in_progress, and overlap with 2026-04-11\\n    bookings = safe_query(final_db_path, \\\"SELECT id, start_datetime, end_datetime, status FROM bookings WHERE pet_id=?\\\", (luna_pet_id,))\\n    target_booking_id = None\\n    for b in bookings:\\n        bid, start_dt, end_dt, status = b\\n        if status != 'in_progress':\\n            continue\\n        # Visit must occur on 2026-04-11, so booking must overlap it\\n        if start_dt <= '2026-04-11 23:59:59' and end_dt >= '2026-04-11 00:00:00':\\n            target_booking_id = bid\\n            break\\n    if target_booking_id != 9003:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 2: Collect all visit_reports for this booking in both DBs\\n    reports_final = safe_query(final_db_path, \\\"SELECT id, potty_notes, meal_notes FROM visit_reports WHERE booking_id=?\\\", (target_booking_id, ))\\n    reports_initial = safe_query(initial_db_path, \\\"SELECT id, potty_notes, meal_notes FROM visit_reports WHERE booking_id=?\\\", (target_booking_id, ))\\n    initial_ids = {r[0] for r in reports_initial}\\n\\n    # Step 3: Find candidate new report(s) with required notes\\n    matching_reports = []\\n    for (vid, potty, meal) in reports_final:\\n        if vid in initial_ids:\\n            continue # pre-existing report, ignore\\n        if potty is None or meal is None:\\n            continue\\n        # Strict string match\\n        if potty.strip() == 'pee and poop' and meal.strip() == 'ate 1 cup kibble':\\n            matching_reports.append(vid)\\n    if len(matching_reports) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_report_id = matching_reports[0]\\n\\n    # Step 4: Confirm two associated photo metadata entries, with exact timestamps/captions\\n    photo_rows = safe_query(final_db_path, \\\"SELECT taken_at, caption FROM visit_report_photos WHERE visit_report_id=?\\\", (new_report_id,))\\n    if len(photo_rows) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Build set of (timestamp, caption) for matching\\n    expected = {('2026-04-11T08:12:00-04:00','Morning walk'), ('2026-04-11T18:45:00-04:00','Dinner time')}\\n    found = set((t if t else '', c if c else '') for t, c in photo_rows)\\n    if found != expected:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Extra safety: these photos must not exist in initial_db for this report (should be a new report anyway)\\n    initial_photo_count = safe_query(initial_db_path, \\\"SELECT COUNT(*) FROM visit_report_photos WHERE taken_at=? AND caption=?\\\", ('2026-04-11T08:12:00-04:00', 'Morning walk'))\\n    if initial_photo_count and initial_photo_count[0][0] > 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_photo_count2 = safe_query(initial_db_path, \\\"SELECT COUNT(*) FROM visit_report_photos WHERE taken_at=? AND caption=?\\\", ('2026-04-11T18:45:00-04:00', 'Dinner time'))\\n    if initial_photo_count2 and initial_photo_count2[0][0] > 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Everything matches, 100% certain\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 8, "task": "Cancel my reservation for daycare with sitter \"Priya Shah\" scheduled on 2026-03-20, select cancellation reason \"pet illness\", and request a refund to the original payment method if eligible.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            out = cursor.fetchall()\n            conn.close()\n            return out\n        except Exception:\n            return []\n    # Step 1: Identify booking (Sam Owner, Priya Shah, daycare, 2026-03-20)\n    # Map user full name to user_id\n    users = safe_query(final_db_path, \"SELECT id, full_name FROM users\")\n    owner_id = None\n    sitter_id = None\n    for uid, name in users:\n        if name == \"Sam Owner\":\n            owner_id = uid\n        if name == \"Priya Shah\":\n            sitter_id = uid\n    if owner_id is None or sitter_id is None:\n        return {\"result\": \"others\"}\n    # Find daycare service_listings for Priya Shah\n    listings = safe_query(final_db_path, \"SELECT id FROM service_listings WHERE sitter_user_id=? AND service_type='daycare'\", (sitter_id,))\n    if not listings:\n        return {\"result\": \"others\"}\n    listing_ids = {lid for (lid,) in listings}\n    # Find booking for correct date and users\n    bookings = safe_query(final_db_path, \"SELECT id, status, cancellation_reason_code, service_listing_id, start_datetime FROM bookings WHERE owner_user_id=? AND sitter_user_id=?\", (owner_id, sitter_id))\n    target_booking = None\n    for b in bookings:\n        b_id, b_status, b_cancel_reason, b_service_listing_id, b_start_datetime = b[0], b[1], b[2], b[3], b[4]\n        # Accept dates of form '2026-03-20 09:00:00', check only date part\n        if b_service_listing_id in listing_ids and b_start_datetime and b_start_datetime.startswith('2026-03-20'):\n            target_booking = {\n                'id': b_id,\n                'status': b_status,\n                'cancel_reason': b_cancel_reason\n            }\n            break\n    if not target_booking:\n        return {\"result\": \"others\"}\n    # Check status and cancel reason\n    if target_booking['status'] != 'canceled':\n        return {\"result\": \"others\"}\n    if target_booking['cancel_reason'] != 'pet_illness':\n        return {\"result\": \"others\"}\n    # Refund eligibility check\n    # Find booking_pricing for this booking\n    pricing = safe_query(final_db_path, \"SELECT id FROM booking_pricing WHERE booking_id=?\", (target_booking['id'],))\n    if not pricing:\n        return {\"result\": \"others\"}\n    # Find existing payment (must be made by owner_id)\n    payment = safe_query(final_db_path, \"SELECT id FROM payments WHERE booking_id=? AND payer_user_id=?\", (target_booking['id'], owner_id))\n    payment_id = payment[0][0] if payment else None\n    # Check for refund request (if eligible)\n    refund_reqs = safe_query(final_db_path, \"SELECT refund_to_original_method, status, payment_id FROM refund_requests WHERE booking_id=?\", (target_booking['id'],))\n    # If there was payment, there must be a refund request to the original method\n    if payment_id:\n        found_valid_refund = False\n        for refund in refund_reqs:\n            refund_to_method, refund_status, refund_payment_id = refund\n            # Must be to original and refer to the original payment\n            if refund_to_method == 1 and refund_payment_id == payment_id and refund_status in (\"requested\",\"approved\",\"processed\"):\n                found_valid_refund = True\n                break\n        if not found_valid_refund:\n            return {\"result\": \"others\"}\n    # If no payment was present, ignore refund requirement\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To definitively verify completion, we need to ensure: (1) The user's daycare reservation with sitter Priya Shah scheduled for 2026-03-20 is canceled in the bookings table, (2) The cancellation reason is set as 'pet_illness', (3) The reservation is indeed for daycare and Priya Shah (user_id mapping, listing type check), and (4) If a refund is eligible, a refund request exists in refund_requests for this booking, to the original payment method. We do not rely on final_answer, as this is an action/modification task.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find the booking: user is Sam Owner (user_id 1), sitter is Priya Shah (id 3), service_type is daycare, scheduled for 2026-03-20\",\n        \"Verify in the final DB: booking is marked canceled (status == 'canceled'), cancellation_reason_code == 'pet_illness'\",\n        \"If eligible for refund, verify refund_requests exists for that booking, refund_to_original_method == 1, status in ('requested','approved','processed'), and payment_id refers to a payment made by user_id 1 (payer)\",\n        \"Handle missing/incomplete/corrupted data gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            out = cursor.fetchall()\\n            conn.close()\\n            return out\\n        except Exception:\\n            return []\\n    # Step 1: Identify booking (Sam Owner, Priya Shah, daycare, 2026-03-20)\\n    # Map user full name to user_id\\n    users = safe_query(final_db_path, \\\"SELECT id, full_name FROM users\\\")\\n    owner_id = None\\n    sitter_id = None\\n    for uid, name in users:\\n        if name == \\\"Sam Owner\\\":\\n            owner_id = uid\\n        if name == \\\"Priya Shah\\\":\\n            sitter_id = uid\\n    if owner_id is None or sitter_id is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find daycare service_listings for Priya Shah\\n    listings = safe_query(final_db_path, \\\"SELECT id FROM service_listings WHERE sitter_user_id=? AND service_type='daycare'\\\", (sitter_id,))\\n    if not listings:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    listing_ids = {lid for (lid,) in listings}\\n    # Find booking for correct date and users\\n    bookings = safe_query(final_db_path, \\\"SELECT id, status, cancellation_reason_code, service_listing_id, start_datetime FROM bookings WHERE owner_user_id=? AND sitter_user_id=?\\\", (owner_id, sitter_id))\\n    target_booking = None\\n    for b in bookings:\\n        b_id, b_status, b_cancel_reason, b_service_listing_id, b_start_datetime = b[0], b[1], b[2], b[3], b[4]\\n        # Accept dates of form '2026-03-20 09:00:00', check only date part\\n        if b_service_listing_id in listing_ids and b_start_datetime and b_start_datetime.startswith('2026-03-20'):\\n            target_booking = {\\n                'id': b_id,\\n                'status': b_status,\\n                'cancel_reason': b_cancel_reason\\n            }\\n            break\\n    if not target_booking:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check status and cancel reason\\n    if target_booking['status'] != 'canceled':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if target_booking['cancel_reason'] != 'pet_illness':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Refund eligibility check\\n    # Find booking_pricing for this booking\\n    pricing = safe_query(final_db_path, \\\"SELECT id FROM booking_pricing WHERE booking_id=?\\\", (target_booking['id'],))\\n    if not pricing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find existing payment (must be made by owner_id)\\n    payment = safe_query(final_db_path, \\\"SELECT id FROM payments WHERE booking_id=? AND payer_user_id=?\\\", (target_booking['id'], owner_id))\\n    payment_id = payment[0][0] if payment else None\\n    # Check for refund request (if eligible)\\n    refund_reqs = safe_query(final_db_path, \\\"SELECT refund_to_original_method, status, payment_id FROM refund_requests WHERE booking_id=?\\\", (target_booking['id'],))\\n    # If there was payment, there must be a refund request to the original method\\n    if payment_id:\\n        found_valid_refund = False\\n        for refund in refund_reqs:\\n            refund_to_method, refund_status, refund_payment_id = refund\\n            # Must be to original and refer to the original payment\\n            if refund_to_method == 1 and refund_payment_id == payment_id and refund_status in (\\\"requested\\\",\\\"approved\\\",\\\"processed\\\"):\\n                found_valid_refund = True\\n                break\\n        if not found_valid_refund:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # If no payment was present, ignore refund requirement\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "rover", "task_idx": 9, "task": "Open a support ticket disputing a $15 late-cancellation fee on booking ID \"BK-10492\" with the description \"Sitter canceled 2 hours before start; I was still charged a late fee\" and attach the related message thread ID \"MSG-88310\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query a database and return list of dicts\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            conn.row_factory = sqlite3.Row\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return [dict(row) for row in rows]\n        except Exception:\n            return []\n    \n    # Get booking info\n    booking = safe_query(\n        initial_db_path,\n        \"SELECT id FROM bookings WHERE booking_code = ?\",\n        (\"BK-10492\",)\n    )\n    if not booking or 'id' not in booking[0]:\n        return {\"result\": \"others\"}\n    booking_id = booking[0]['id']\n    \n    # Owner user id is 1 (from users table, sam_owner is the only owner of Buddy)\n    owner_user_id = 1\n    \n    # Get thread ID for MSG-88310\n    thread = safe_query(\n        initial_db_path,\n        \"SELECT id FROM message_threads WHERE thread_code = ?\",\n        (\"MSG-88310\",)\n    )\n    if not thread or 'id' not in thread[0]:\n        return {\"result\": \"others\"}\n    thread_id = thread[0]['id']\n    \n    # Task-specific required substrings for description\n    desc_substrings = [\n        \"sitter canceled 2 hours before start\",\n        \"still charged a late fee\"\n    ]\n    \n    # Utility: Case-insensitive substring match for all required parts\n    def description_matches(desc: str):\n        if desc is None:\n            return False\n        desc_lc = desc.lower()\n        return all(s.lower() in desc_lc for s in desc_substrings)\n    \n    # Get all fee_dispute tickets for this booking/thread/owner in initial db\n    initial_tickets = safe_query(\n        initial_db_path,\n        \"SELECT id, description, created_by_user_id, booking_id, category, related_thread_id FROM support_tickets WHERE booking_id = ? AND category = 'fee_dispute'\",\n        (booking_id,)\n    )\n    for t in initial_tickets:\n        if (\n            t.get('created_by_user_id') == owner_user_id and\n            t.get('related_thread_id') == thread_id and\n            description_matches(t.get('description',''))\n        ):\n            # Already existed in initial DB, agent cannot complete the task again.\n            return {\"result\": \"others\"}\n    \n    # Get all such tickets in final db\n    final_tickets = safe_query(\n        final_db_path,\n        \"SELECT * FROM support_tickets WHERE booking_id = ? AND category = 'fee_dispute'\",\n        (booking_id,)\n    )\n    # Find all that match *ALL* required attributes\n    matching_final_tickets = []\n    for t in final_tickets:\n        if (\n            t.get('created_by_user_id') == owner_user_id and\n            t.get('related_thread_id') == thread_id and\n            description_matches(t.get('description',''))\n        ):\n            # Confirm at least status, subject, ticket_code are present\n            # Confirm that status is valid\n            status = t.get('status','')\n            if status not in ('open','in_review','resolved','closed'):\n                continue\n            matching_final_tickets.append(t)\n    # There must be exactly 1 new such ticket\n    if len(matching_final_tickets) != 1:\n        return {\"result\": \"others\"}\n    # Confirm that this ticket is truly new (not present in initial)\n    # Defensive: handle untracked changes\n    initial_ticket_ids = set(t.get('id') for t in initial_tickets)\n    new_ticket = matching_final_tickets[0]\n    if new_ticket.get('id') in initial_ticket_ids:\n        return {\"result\": \"others\"}\n    # All conditions satisfied\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The task is to open a support ticket disputing a $15 late-cancellation fee on booking ID 'BK-10492' with a specific description and attach the message thread ID 'MSG-88310'. To verify completion, we must confirm that a new support_tickets row was added (since before the agent act, there was no such ticket for BK-10492/booking_id=9005 and the given description/thread), with: (1) created_by_user_id=1 (the owner), (2) booking_id=9005 (BK-10492), (3) category='fee_dispute', (4) description matching (or containing) the required text (allowing for minor text variations but must have \\\"sitter canceled 2 hours before start\\\" and \\\"still charged a late fee\\\"), (5) related_thread_id matching MSG-88310's thread row (id=9502), and (6) reasonableness on subject (optional). The ticket must be new (was not present in initial DB), and no unexpected over-creation. This is a modification-based verification, because only the database determines task success, not the final_answer.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify owner_user_id=1 and get booking_id of BK-10492 (should be 9005)\",\n        \"Locate message_thread with thread_code='MSG-88310' and get its id (should be 9502)\",\n        \"Check that in initial_db, support_tickets table does NOT have any ticket for booking_id=9005 with category='fee_dispute', description containing both task-required fragments, and related_thread_id=9502\",\n        \"In final_db, a NEW support_tickets row exists with:\",\n        \"- created_by_user_id=1\",\n        \"- booking_id=9005\",\n        \"- category='fee_dispute'\",\n        \"- related_thread_id=9502\",\n        \"- description contains both required task text fragments: 'sitter canceled 2 hours before start' and 'still charged a late fee' (case-insensitive, substring match)\",\n        \"- optionally, subject is any\",\n        \"- status is one of ('open','in_review','resolved','closed')\",\n        \"There should be only one such ticket created (no duplicates for same booking/category/desc/thread/creator combo)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query a database and return list of dicts\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            conn.row_factory = sqlite3.Row\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return [dict(row) for row in rows]\\n        except Exception:\\n            return []\\n    \\n    # Get booking info\\n    booking = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM bookings WHERE booking_code = ?\\\",\\n        (\\\"BK-10492\\\",)\\n    )\\n    if not booking or 'id' not in booking[0]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    booking_id = booking[0]['id']\\n    \\n    # Owner user id is 1 (from users table, sam_owner is the only owner of Buddy)\\n    owner_user_id = 1\\n    \\n    # Get thread ID for MSG-88310\\n    thread = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM message_threads WHERE thread_code = ?\\\",\\n        (\\\"MSG-88310\\\",)\\n    )\\n    if not thread or 'id' not in thread[0]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    thread_id = thread[0]['id']\\n    \\n    # Task-specific required substrings for description\\n    desc_substrings = [\\n        \\\"sitter canceled 2 hours before start\\\",\\n        \\\"still charged a late fee\\\"\\n    ]\\n    \\n    # Utility: Case-insensitive substring match for all required parts\\n    def description_matches(desc: str):\\n        if desc is None:\\n            return False\\n        desc_lc = desc.lower()\\n        return all(s.lower() in desc_lc for s in desc_substrings)\\n    \\n    # Get all fee_dispute tickets for this booking/thread/owner in initial db\\n    initial_tickets = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id, description, created_by_user_id, booking_id, category, related_thread_id FROM support_tickets WHERE booking_id = ? AND category = 'fee_dispute'\\\",\\n        (booking_id,)\\n    )\\n    for t in initial_tickets:\\n        if (\\n            t.get('created_by_user_id') == owner_user_id and\\n            t.get('related_thread_id') == thread_id and\\n            description_matches(t.get('description',''))\\n        ):\\n            # Already existed in initial DB, agent cannot complete the task again.\\n            return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Get all such tickets in final db\\n    final_tickets = safe_query(\\n        final_db_path,\\n        \\\"SELECT * FROM support_tickets WHERE booking_id = ? AND category = 'fee_dispute'\\\",\\n        (booking_id,)\\n    )\\n    # Find all that match *ALL* required attributes\\n    matching_final_tickets = []\\n    for t in final_tickets:\\n        if (\\n            t.get('created_by_user_id') == owner_user_id and\\n            t.get('related_thread_id') == thread_id and\\n            description_matches(t.get('description',''))\\n        ):\\n            # Confirm at least status, subject, ticket_code are present\\n            # Confirm that status is valid\\n            status = t.get('status','')\\n            if status not in ('open','in_review','resolved','closed'):\\n                continue\\n            matching_final_tickets.append(t)\\n    # There must be exactly 1 new such ticket\\n    if len(matching_final_tickets) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Confirm that this ticket is truly new (not present in initial)\\n    # Defensive: handle untracked changes\\n    initial_ticket_ids = set(t.get('id') for t in initial_tickets)\\n    new_ticket = matching_final_tickets[0]\\n    if new_ticket.get('id') in initial_ticket_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All conditions satisfied\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 0, "task": "Create a new fundraising campaign titled \"Help Mayas Recovery\" in the \"Medical\" category with a goal amount of 12000 USD, beneficiary \"Maya Hernandez\", location \"Austin, TX\", and image metadata [{\"filename\":\"maya-hospital.jpg\",\"alt\":\"Maya smiling in a hospital bed\"},{\"filename\":\"family.jpg\",\"alt\":\"Maya with her family at home\"}].", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()):        \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # 1. Get all campaigns in initial and final DBs with the relevant columns\n    campaign_columns = (\"id, owner_user_id, category_id, title, beneficiary_name, location_city, \"\n                        \"location_region, location_country, goal_amount_cents, currency_code\")\n    initial_camps = safe_query(\n        initial_db_path,\n        f\"SELECT {campaign_columns} FROM campaigns\"\n    )\n    final_camps = safe_query(\n        final_db_path,\n        f\"SELECT {campaign_columns} FROM campaigns\"\n    )\n    if not final_camps or not isinstance(final_camps, list):\n        return {\"result\": \"others\"}\n    # 2. Build set of keys of existing campaigns in the initial DB (by tuple of all identifying details)\n    initial_camp_keys = set(\n        (\n            r[1], # owner_user_id\n            r[2], # category_id\n            r[3], # title\n            r[4], # beneficiary_name\n            r[5], # location_city\n            r[6], # location_region\n            r[7], # location_country\n            r[8], # goal_amount_cents\n            r[9], # currency_code\n        ) for r in initial_camps\n    )\n    # 3. Get categories from the final DB so we can lookup category_id for 'Medical'\n    categories = safe_query(final_db_path, \"SELECT id, name FROM categories\")\n    cat_id_by_name = {row[1]: row[0] for row in categories}\n    med_cat_id = cat_id_by_name.get(\"Medical\")\n    if med_cat_id is None:\n        return {\"result\": \"others\"}\n    \n    # 4. Look for a campaign in the final DB that matches ALL the requirements,\n    #    but is NOT present (via unique-tuple) in the initial DB\n    TARGET = {\n        'title': \"Help Mayas Recovery\",\n        'category_id': med_cat_id,\n        'beneficiary_name': \"Maya Hernandez\",\n        'location_city': \"Austin\",\n        'location_region': \"TX\",\n        'location_country': \"US\",\n        'goal_amount_cents': 1200000,\n        'currency_code': \"USD\",\n    }\n    matching_final_camps = []\n    for row in final_camps:\n        (\n            cid, owner_user_id, category_id, title, beneficiary_name,\n            location_city, location_region, location_country, goal_amount_cents, currency_code\n        ) = row\n        tuple_key = (\n            owner_user_id, category_id, title, beneficiary_name,\n            location_city, location_region, location_country, goal_amount_cents, currency_code\n        )\n        # Must NOT already exist in initial DB\n        if tuple_key in initial_camp_keys:\n            continue\n        # Match all target fields exactly\n        if (\n            title == TARGET['title']\n            and category_id == TARGET['category_id']\n            and beneficiary_name == TARGET['beneficiary_name']\n            and location_city == TARGET['location_city']\n            and location_region == TARGET['location_region']\n            and (location_country or \"US\") == TARGET['location_country'] # fallback to default\n            and goal_amount_cents == TARGET['goal_amount_cents']\n            and currency_code == TARGET['currency_code']\n        ):\n            matching_final_camps.append( (cid, owner_user_id) ) # Save id, owner_user_id\n    # There must be exactly one such new campaign\n    if len(matching_final_camps) != 1:\n        return {\"result\": \"others\"}\n    new_campaign_id, owner_user_id = matching_final_camps[0]\n    # 5. Check new media: there must be exactly the 2 image metadata for this campaign\n    media_rows = safe_query(\n        final_db_path,\n        \"SELECT filename, alt_text, sort_order FROM campaign_media WHERE campaign_id = ? ORDER BY sort_order ASC, id ASC\",\n        (new_campaign_id,)\n    )\n    if len(media_rows) != 2:\n        return {\"result\": \"others\"}\n    # Media spec:\n    expected_media = [\n        (\"maya-hospital.jpg\", \"Maya smiling in a hospital bed\", 1),\n        (\"family.jpg\", \"Maya with her family at home\", 2)\n    ]\n    # Must match exactly in content and order\n    for (filename, alt_text, sort_order), (ef, eat, eo) in zip(media_rows, expected_media):\n        if filename != ef or alt_text != eat or sort_order != eo:\n            return {\"result\": \"others\"}\n    # 6. Defensive check: make sure these media did NOT already exist for any campaign with this data in the initial DB. (Rustic defense: ensure no campaign_media rows for these files tied to this new campaign id)\n    initial_media_q = safe_query(\n        initial_db_path,\n        \"SELECT campaign_id, filename FROM campaign_media WHERE campaign_id = ? AND (filename = ? OR filename = ?)\",\n        (\n            new_campaign_id,\n            \"maya-hospital.jpg\",\n            \"family.jpg\"\n        )\n    )\n    if initial_media_q:\n        # Media for this campaign id existed earlier (should not)\n        return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the task 'Create a new fundraising campaign titled \\\"Help Mayas Recovery\\\" in the \\\"Medical\\\" category with a goal amount of 12000 USD, beneficiary \\\"Maya Hernandez\\\", location \\\"Austin, TX\\\", and image metadata ...', we must confirm, using only database state before and after, that the agent has created a new campaign record with these exact attributes, links it to the correct category and beneficiary, adds it with the correct title and location, and that the specified image metadata (filenames and alt texts) is created and associated with the new campaign. Since this is a creation task, and only database changes are required, we compare the initial and final databases for (a) a new campaign with exactly these details, and (b) exactly two matching new media entries linked to that campaign. All other situations (if campaign did not exist before, or media is missing/wrong, or too many extra records, or values don't match exactly, etc.) yield 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find a campaign in the final DB not present in the initial DB with all requested field values (title, category, goal, beneficiary, location, currency, etc.)\",\n        \"Match the campaign's category to 'Medical' via category_id\",\n        \"Goal amount must be 12000 USD (check for 1200000 cents, currency_code 'USD')\",\n        \"Beneficiary name must be 'Maya Hernandez', location_city 'Austin', location_region 'TX', location_country 'US'\",\n        \"Campaign title must be exactly 'Help Mayas Recovery'\",\n        \"Exactly two new associated media records must be present in campaign_media for the new campaign ID, with\",\n        \"Media 1: filename='maya-hospital.jpg', alt='Maya smiling in a hospital bed', sort_order=1\",\n        \"Media 2: filename='family.jpg', alt='Maya with her family at home', sort_order=2\",\n        \"No duplicate campaigns with the same details already existed in the initial database (must genuinely be newly created)\"\n    ],\n    \"python_code\":\n\"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()):        \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # 1. Get all campaigns in initial and final DBs with the relevant columns\\n    campaign_columns = (\\\"id, owner_user_id, category_id, title, beneficiary_name, location_city, \\\"\\n                        \\\"location_region, location_country, goal_amount_cents, currency_code\\\")\\n    initial_camps = safe_query(\\n        initial_db_path,\\n        f\\\"SELECT {campaign_columns} FROM campaigns\\\"\\n    )\\n    final_camps = safe_query(\\n        final_db_path,\\n        f\\\"SELECT {campaign_columns} FROM campaigns\\\"\\n    )\\n    if not final_camps or not isinstance(final_camps, list):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 2. Build set of keys of existing campaigns in the initial DB (by tuple of all identifying details)\\n    initial_camp_keys = set(\\n        (\\n            r[1], # owner_user_id\\n            r[2], # category_id\\n            r[3], # title\\n            r[4], # beneficiary_name\\n            r[5], # location_city\\n            r[6], # location_region\\n            r[7], # location_country\\n            r[8], # goal_amount_cents\\n            r[9], # currency_code\\n        ) for r in initial_camps\\n    )\\n    # 3. Get categories from the final DB so we can lookup category_id for 'Medical'\\n    categories = safe_query(final_db_path, \\\"SELECT id, name FROM categories\\\")\\n    cat_id_by_name = {row[1]: row[0] for row in categories}\\n    med_cat_id = cat_id_by_name.get(\\\"Medical\\\")\\n    if med_cat_id is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # 4. Look for a campaign in the final DB that matches ALL the requirements,\\n    #    but is NOT present (via unique-tuple) in the initial DB\\n    TARGET = {\\n        'title': \\\"Help Mayas Recovery\\\",\\n        'category_id': med_cat_id,\\n        'beneficiary_name': \\\"Maya Hernandez\\\",\\n        'location_city': \\\"Austin\\\",\\n        'location_region': \\\"TX\\\",\\n        'location_country': \\\"US\\\",\\n        'goal_amount_cents': 1200000,\\n        'currency_code': \\\"USD\\\",\\n    }\\n    matching_final_camps = []\\n    for row in final_camps:\\n        (\\n            cid, owner_user_id, category_id, title, beneficiary_name,\\n            location_city, location_region, location_country, goal_amount_cents, currency_code\\n        ) = row\\n        tuple_key = (\\n            owner_user_id, category_id, title, beneficiary_name,\\n            location_city, location_region, location_country, goal_amount_cents, currency_code\\n        )\\n        # Must NOT already exist in initial DB\\n        if tuple_key in initial_camp_keys:\\n            continue\\n        # Match all target fields exactly\\n        if (\\n            title == TARGET['title']\\n            and category_id == TARGET['category_id']\\n            and beneficiary_name == TARGET['beneficiary_name']\\n            and location_city == TARGET['location_city']\\n            and location_region == TARGET['location_region']\\n            and (location_country or \\\"US\\\") == TARGET['location_country'] # fallback to default\\n            and goal_amount_cents == TARGET['goal_amount_cents']\\n            and currency_code == TARGET['currency_code']\\n        ):\\n            matching_final_camps.append( (cid, owner_user_id) ) # Save id, owner_user_id\\n    # There must be exactly one such new campaign\\n    if len(matching_final_camps) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_campaign_id, owner_user_id = matching_final_camps[0]\\n    # 5. Check new media: there must be exactly the 2 image metadata for this campaign\\n    media_rows = safe_query(\\n        final_db_path,\\n        \\\"SELECT filename, alt_text, sort_order FROM campaign_media WHERE campaign_id = ? ORDER BY sort_order ASC, id ASC\\\",\\n        (new_campaign_id,)\\n    )\\n    if len(media_rows) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Media spec:\\n    expected_media = [\\n        (\\\"maya-hospital.jpg\\\", \\\"Maya smiling in a hospital bed\\\", 1),\\n        (\\\"family.jpg\\\", \\\"Maya with her family at home\\\", 2)\\n    ]\\n    # Must match exactly in content and order\\n    for (filename, alt_text, sort_order), (ef, eat, eo) in zip(media_rows, expected_media):\\n        if filename != ef or alt_text != eat or sort_order != eo:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # 6. Defensive check: make sure these media did NOT already exist for any campaign with this data in the initial DB. (Rustic defense: ensure no campaign_media rows for these files tied to this new campaign id)\\n    initial_media_q = safe_query(\\n        initial_db_path,\\n        \\\"SELECT campaign_id, filename FROM campaign_media WHERE campaign_id = ? AND (filename = ? OR filename = ?)\\\",\\n        (\\n            new_campaign_id,\\n            \\\"maya-hospital.jpg\\\",\\n            \\\"family.jpg\\\"\\n        )\\n    )\\n    if initial_media_q:\\n        # Media for this campaign id existed earlier (should not)\\n        return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 1, "task": "Update my campaign \"Help Mayas Recovery\" by changing the goal amount to 15000 USD and updating the location to \"Round Rock, TX\" while keeping the category as \"Medical\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to fetch one or none\n    def fetch_one(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            res = cursor.fetchone()\n            conn.close()\n            return res\n        except Exception:\n            return None\n    # Helper to fetch all\n    def fetch_all(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            res = cursor.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n    # Get the campaign(s) with the correct title\n    title = 'Help Mayas Recovery'\n    # 1. Confirm the campaign exists initially and finally (no duplicates, same owner)\n    init_rows = fetch_all(initial_db_path, \"SELECT id, owner_user_id, category_id, goal_amount_cents, currency_code, location_city, location_region FROM campaigns WHERE title = ?\", (title,))\n    final_rows = fetch_all(final_db_path, \"SELECT id, owner_user_id, category_id, goal_amount_cents, currency_code, location_city, location_region FROM campaigns WHERE title = ?\", (title,))\n    if len(init_rows) != 1 or len(final_rows) != 1:\n        return {\"result\": \"others\"}\n    # 2. Category must remain the same, check what category_id means 'Medical'\n    med_cat_init = fetch_one(initial_db_path, \"SELECT id FROM categories WHERE name = 'Medical'\")\n    med_cat_final = fetch_one(final_db_path, \"SELECT id FROM categories WHERE name = 'Medical'\")\n    if not med_cat_final or not med_cat_init or not isinstance(med_cat_final[0], int):\n        return {\"result\": \"others\"}\n    med_cat_id_final = med_cat_final[0]\n    med_cat_id_init = med_cat_init[0]\n    # 3. Compare all fields\n    (init_id, init_owner, init_cat, init_goal, init_ccy, init_city, init_region) = init_rows[0]\n    (final_id, final_owner, final_cat, final_goal, final_ccy, final_city, final_region) = final_rows[0]\n    # Record must be the same campaign and same owner\n    if init_id != final_id or init_owner != final_owner:\n        return {\"result\": \"others\"}\n    # 4. Check only the expected fields changed\n    # (a) goal_amount_cents became 1500000 (15,000 x 100)\n    # (b) location is ('Round Rock', 'TX')\n    # (c) category must remain the same and be 'Medical'\n    # (d) currency_code must remain 'USD'\n    # (e) All other fields unchanged\n    if final_goal != 1500000 or final_ccy != 'USD' or final_city != 'Round Rock' or final_region != 'TX' or final_cat != med_cat_id_final:\n        return {\"result\": \"others\"}\n    if init_cat != final_cat:\n        return {\"result\": \"others\"} # category must not be changed to something else\n    # Confirm that prior to change, at least one field was different:\n    if init_goal == final_goal and init_city == final_city and init_region == final_region and init_cat == final_cat:\n        # If initial matches final (i.e., no update actually done)\n        return {\"result\": \"others\"}\n    # Make sure that no duplicate or extra campaign was inserted (should only update)\n    # (No new id with same owner and title)\n    if init_id != final_id:\n        return {\"result\": \"others\"}\n    # Edge case: Check no other campaigns exist for this owner with title 'Help Mayas Recovery'.\n    dups_final = fetch_all(final_db_path, \"SELECT id FROM campaigns WHERE owner_user_id = ? AND title = ?\", (final_owner, title))\n    if len(dups_final) != 1 or dups_final[0][0] != final_id:\n        return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The user requires the campaign \\\"Help Mayas Recovery\\\" to be updated so that the goal amount is changed to exactly 15000 USD, the location is updated to 'Round Rock, TX', and the category remains 'Medical'. To verify this, check that: (1) In the initial state, the campaign exists and its fields differ from the requested changes. (2) In the final state, exactly one campaign has title 'Help Mayas Recovery' and its fields ('goal_amount_cents', 'currency_code', 'location_city', 'location_region', and category via category_id) match the requirements. (3) No duplicate campaigns with this title are created for the same owner; only an update, not insert, happened. There should be no unintended side effects (such as wrongly changed category or currency). Edge cases (missing data, extra rows, malformed schemas, wrong category) are handled by returning 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Confirm campaign 'Help Mayas Recovery' exists for the same owner in both initial and final DB.\",\n        \"Check only one such campaign exists in both DBs (no duplicates inserted).\",\n        \"In initial DB, retrieve id, owner_user_id, category_id for the campaign.\",\n        \"Verify in initial DB the goal_amount_cents is NOT 1500000, location_city is not 'Round Rock' and location_region is not 'TX', or category_id does not point to 'Medical' (so an update is actually needed).\",\n        \"In final DB, verify campaign row has goal_amount_cents=1500000, currency_code='USD', location_city='Round Rock', location_region='TX', category_id points to 'Medical'.\",\n        \"Category is checked via cross-reference with categories table (name == 'Medical') to obtain its id.\",\n        \"All other campaign fields for this record remain unchanged except those requested.\",\n        \"Handle missing/extra records, data mismatch, or schema errors defensively.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to fetch one or none\\n    def fetch_one(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            res = cursor.fetchone()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return None\\n    # Helper to fetch all\\n    def fetch_all(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            res = cursor.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n    # Get the campaign(s) with the correct title\\n    title = 'Help Mayas Recovery'\\n    # 1. Confirm the campaign exists initially and finally (no duplicates, same owner)\\n    init_rows = fetch_all(initial_db_path, \\\"SELECT id, owner_user_id, category_id, goal_amount_cents, currency_code, location_city, location_region FROM campaigns WHERE title = ?\\\", (title,))\\n    final_rows = fetch_all(final_db_path, \\\"SELECT id, owner_user_id, category_id, goal_amount_cents, currency_code, location_city, location_region FROM campaigns WHERE title = ?\\\", (title,))\\n    if len(init_rows) != 1 or len(final_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 2. Category must remain the same, check what category_id means 'Medical'\\n    med_cat_init = fetch_one(initial_db_path, \\\"SELECT id FROM categories WHERE name = 'Medical'\\\")\\n    med_cat_final = fetch_one(final_db_path, \\\"SELECT id FROM categories WHERE name = 'Medical'\\\")\\n    if not med_cat_final or not med_cat_init or not isinstance(med_cat_final[0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    med_cat_id_final = med_cat_final[0]\\n    med_cat_id_init = med_cat_init[0]\\n    # 3. Compare all fields\\n    (init_id, init_owner, init_cat, init_goal, init_ccy, init_city, init_region) = init_rows[0]\\n    (final_id, final_owner, final_cat, final_goal, final_ccy, final_city, final_region) = final_rows[0]\\n    # Record must be the same campaign and same owner\\n    if init_id != final_id or init_owner != final_owner:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 4. Check only the expected fields changed\\n    # (a) goal_amount_cents became 1500000 (15,000 x 100)\\n    # (b) location is ('Round Rock', 'TX')\\n    # (c) category must remain the same and be 'Medical'\\n    # (d) currency_code must remain 'USD'\\n    # (e) All other fields unchanged\\n    if final_goal != 1500000 or final_ccy != 'USD' or final_city != 'Round Rock' or final_region != 'TX' or final_cat != med_cat_id_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if init_cat != final_cat:\\n        return {\\\"result\\\": \\\"others\\\"} # category must not be changed to something else\\n    # Confirm that prior to change, at least one field was different:\\n    if init_goal == final_goal and init_city == final_city and init_region == final_region and init_cat == final_cat:\\n        # If initial matches final (i.e., no update actually done)\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Make sure that no duplicate or extra campaign was inserted (should only update)\\n    # (No new id with same owner and title)\\n    if init_id != final_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Edge case: Check no other campaigns exist for this owner with title 'Help Mayas Recovery'.\\n    dups_final = fetch_all(final_db_path, \\\"SELECT id FROM campaigns WHERE owner_user_id = ? AND title = ?\\\", (final_owner, title))\\n    if len(dups_final) != 1 or dups_final[0][0] != final_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 2, "task": "Post a campaign update on \"Help Mayas Recovery\" with the title \"Surgery scheduled\" and the body \"Mayas surgery is scheduled for March 5th; thank you for the supportyour donations are covering pre-op tests and travel.\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    TARGET_CAMPAIGN_TITLE = \"Help Mayas Recovery\"\n    TARGET_UPDATE_TITLE = \"Surgery scheduled\"\n    TARGET_UPDATE_BODY = \"Mayas surgery is scheduled for March 5th; thank you for the supportyour donations are covering pre-op tests and travel.\"\n    \n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            conn.row_factory = sqlite3.Row\n            c = conn.cursor()\n            c.execute(query, params)\n            rows = c.fetchall()\n            conn.close()\n            return [dict(row) for row in rows]\n        except Exception:\n            return []\n\n    # Step 1: Find the campaign_id for the target campaign in BOTH DBs\n    initial_campaigns = safe_query(initial_db_path, \"SELECT id FROM campaigns WHERE title = ?\", (TARGET_CAMPAIGN_TITLE,))\n    final_campaigns = safe_query(final_db_path, \"SELECT id FROM campaigns WHERE title = ?\", (TARGET_CAMPAIGN_TITLE,))\n    if not initial_campaigns or not final_campaigns:\n        return {\"result\": \"others\"}\n    initial_campaign_id = initial_campaigns[0][\"id\"]\n    final_campaign_id = final_campaigns[0][\"id\"]\n    # Cancel if not consistent\n    if initial_campaign_id != final_campaign_id:\n        return {\"result\": \"others\"}\n    campaign_id = initial_campaign_id\n\n    # Step 2: Confirm this campaign update did NOT exist in the initial database\n    initial_matches = safe_query(\n        initial_db_path,\n        \"SELECT 1 FROM campaign_updates WHERE campaign_id = ? AND title = ? AND body = ? LIMIT 1\",\n        (campaign_id, TARGET_UPDATE_TITLE, TARGET_UPDATE_BODY)\n    )\n    if initial_matches:\n        # If an update with exact title+body ALREADY existed, don't consider task complete\n        return {\"result\": \"others\"}\n\n    # Step 3: Confirm an update exists in the final database with exact title and body\n    final_matches = safe_query(\n        final_db_path,\n        \"SELECT 1 FROM campaign_updates WHERE campaign_id = ? AND title = ? AND body = ? LIMIT 1\",\n        (campaign_id, TARGET_UPDATE_TITLE, TARGET_UPDATE_BODY)\n    )\n    if not final_matches:\n        return {\"result\": \"others\"}\n\n    # Extra (defensive): Confirm the campaign_updates table still exists\n    test_final_table = safe_query(\n        final_db_path,\n        \"SELECT name FROM sqlite_master WHERE type='table' AND name='campaign_updates'\"\n    )\n    if not test_final_table:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure the agent has posted a new campaign update (a row in 'campaign_updates') on the campaign titled 'Help Mayas Recovery' (which has id=101), with an EXACT title 'Surgery scheduled' and an EXACT body 'Mayas surgery is scheduled for March 5th; thank you for the supportyour donations are covering pre-op tests and travel.'. The row must NOT have existed in the initial DB. No other aspect is required (no constraint on final_answer, author, timestamps, etc). We must be absolutely certain the UPDATE was posted exactly as instructed, and that this is a change from the initial state.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Obtain the campaign id for 'Help Mayas Recovery' (id=101) from the campaigns table.\",\n        \"Confirm that in the initial database, there is NO row in campaign_updates for campaign_id=101 with title 'Surgery scheduled' and the required body.\",\n        \"Confirm in the final database, there EXISTS a row in campaign_updates for campaign_id=101 with EXACT title and body as required.\",\n        \"No extraneous logic (i.e., changes to other fields, author_user_id, timestamps, etc. do not affect pass/fail). All required fields must match exactly.\",\n        \"Handle DB connection failures or missing tables/fields gracefully (return 'others' in these cases).\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    TARGET_CAMPAIGN_TITLE = \\\"Help Mayas Recovery\\\"\\n    TARGET_UPDATE_TITLE = \\\"Surgery scheduled\\\"\\n    TARGET_UPDATE_BODY = \\\"Mayas surgery is scheduled for March 5th; thank you for the supportyour donations are covering pre-op tests and travel.\\\"\\n    \\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            conn.row_factory = sqlite3.Row\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            rows = c.fetchall()\\n            conn.close()\\n            return [dict(row) for row in rows]\\n        except Exception:\\n            return []\\n\\n    # Step 1: Find the campaign_id for the target campaign in BOTH DBs\\n    initial_campaigns = safe_query(initial_db_path, \\\"SELECT id FROM campaigns WHERE title = ?\\\", (TARGET_CAMPAIGN_TITLE,))\\n    final_campaigns = safe_query(final_db_path, \\\"SELECT id FROM campaigns WHERE title = ?\\\", (TARGET_CAMPAIGN_TITLE,))\\n    if not initial_campaigns or not final_campaigns:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_campaign_id = initial_campaigns[0][\\\"id\\\"]\\n    final_campaign_id = final_campaigns[0][\\\"id\\\"]\\n    # Cancel if not consistent\\n    if initial_campaign_id != final_campaign_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    campaign_id = initial_campaign_id\\n\\n    # Step 2: Confirm this campaign update did NOT exist in the initial database\\n    initial_matches = safe_query(\\n        initial_db_path,\\n        \\\"SELECT 1 FROM campaign_updates WHERE campaign_id = ? AND title = ? AND body = ? LIMIT 1\\\",\\n        (campaign_id, TARGET_UPDATE_TITLE, TARGET_UPDATE_BODY)\\n    )\\n    if initial_matches:\\n        # If an update with exact title+body ALREADY existed, don't consider task complete\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Confirm an update exists in the final database with exact title and body\\n    final_matches = safe_query(\\n        final_db_path,\\n        \\\"SELECT 1 FROM campaign_updates WHERE campaign_id = ? AND title = ? AND body = ? LIMIT 1\\\",\\n        (campaign_id, TARGET_UPDATE_TITLE, TARGET_UPDATE_BODY)\\n    )\\n    if not final_matches:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Extra (defensive): Confirm the campaign_updates table still exists\\n    test_final_table = safe_query(\\n        final_db_path,\\n        \\\"SELECT name FROM sqlite_master WHERE type='table' AND name='campaign_updates'\\\"\\n    )\\n    if not test_final_table:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 3, "task": "Search for campaigns in the \"Animals\" category located in \"Seattle, WA\" and return the top 5 results sorted by highest amount raised.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Step 1: Get 'Animals' category id\n    categories = safe_query(initial_db_path, \"SELECT id FROM categories WHERE name = ?\", (\"Animals\",))\n    if not categories or not categories[0] or not isinstance(categories[0][0], int):\n        return {\"result\": \"others\"}\n    animals_cat_id = categories[0][0]\n    \n    # Step 2: Get eligible campaigns in 'Seattle, WA', status active\n    campaigns = safe_query(initial_db_path, \"\"\"\n        SELECT id, title \n        FROM campaigns \n        WHERE category_id = ? AND location_city = ? AND location_region = ? AND status = 'active' \n    \"\"\", (animals_cat_id, \"Seattle\", \"WA\"))\n    if not campaigns:\n        return {\"result\": \"others\"}\n    \n    campaign_ids = [row[0] for row in campaigns]\n    campaign_titles = {row[0]: row[1] for row in campaigns}\n    \n    # Step 3: For each campaign, sum amount_cents donated\n    campaign_amounts = {}\n    for camp_id in campaign_ids:\n        # get all donations for this campaign in final_db (since agent should not modify donations, initial or final works; use final for RL safety)\n        total = safe_query(final_db_path, \"SELECT SUM(amount_cents) FROM donations WHERE campaign_id = ?\", (camp_id,))\n        amount = total[0][0] if total and total[0][0] is not None else 0\n        campaign_amounts[camp_id] = amount\n\n    # Step 4: Sort by total raised descending, select top 5\n    sorted_campaigns = sorted([(camp_id, campaign_titles[camp_id], campaign_amounts[camp_id]) for camp_id in campaign_ids], key=lambda x: (-x[2], x[1]))\n    top5 = sorted_campaigns[:5]\n\n    # Step 5: Validate final_answer presence and structure\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n\n    # Build patterns for each campaign (title and amount)\n    def money_pattern(amount):\n        # e.g. $12345.00, $12,345, use cents-to-dollars conversion\n        dollars = amount // 100\n        cents = amount % 100\n        if cents != 0:\n            money_str = f\"\\${dollars:,}.{cents:02d}\"\n        else:\n            money_str = f\"\\${dollars:,}\"\n        # Allow loose formatting: $12345, $12,345, $12345.00, $12,345.00\n        return r\"\\$ ?\" + re.escape(str(dollars)) + r\"(,\\d{3})*(\\.\\d{2})?\"\n\n    campaign_checks = []\n    for camp_id, title, amount in top5:\n        # Look for the campaign title\n        title_pattern = re.escape(title)\n        # Look for the amount\n        # Accept either full cents or rounded dollars\n        amt_pattern = money_pattern(amount)\n        campaign_checks.append((title_pattern, amt_pattern))\n\n    # Step 6: Extract campaign blocks from final_answer\n    # Try to find exactly these 5 titles in order, each with a corresponding amount\n    found_sequence = []\n    answer_text = final_answer.lower()\n    last_pos = 0\n    for idx, (title_pat, amt_pat) in enumerate(campaign_checks):\n        # Try to find title AFTER last found campaign\n        title_regex = re.compile(title_pat, re.IGNORECASE)\n        amt_regex = re.compile(amt_pat, re.IGNORECASE)\n        m_title = title_regex.search(final_answer, last_pos)\n        if not m_title:\n            return {\"result\": \"others\"}\n        # Search for amount near title\n        amt_window_start = max(m_title.start() - 100, 0)\n        amt_window_end = m_title.end() + 100\n        amt_text = final_answer[amt_window_start:amt_window_end]\n        m_amt = amt_regex.search(amt_text)\n        if not m_amt:\n            return {\"result\": \"others\"}\n        found_sequence.append((title_pat, amt_pat))\n        last_pos = m_title.end()\n\n    # Now ensure there are exactly 5 unique campaigns in answer and no extras\n    # Extract all matching campaign titles from final_answer\n    all_titles = [re.escape(title) for camp_id, title, amount in sorted_campaigns]\n    title_regex_all = re.compile('|'.join(all_titles), re.IGNORECASE)\n    found_titles = [m.group().strip() for m in title_regex_all.finditer(final_answer)]\n    found_titles_set = set([t.lower() for t in found_titles])\n    top_titles_set = set([title.lower() for camp_id, title, amount in top5])\n    # Only these top 5 titles should appear\n    if not top_titles_set.issubset(found_titles_set):\n        return {\"result\": \"others\"}\n    # If more than these appear, allow only if not extra Seattle Animals campaigns\n    if any(title for title in found_titles_set if title not in top_titles_set):\n        # Possibly answer includes extra campaigns, so we fail\n        return {\"result\": \"others\"}\n    # If the titles were not found in order, fail\n    expected_order = [title.lower() for camp_id, title, amount in top5]\n    actual_order = [t.lower() for t in found_titles if t.lower() in top_titles_set]\n    if actual_order != expected_order:\n        return {\"result\": \"others\"}\n\n    # All checks passed; 100% certain task was completed\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify that the agent completed the task, we must check if the final_answer returned the top 5 campaigns in the 'Animals' category that are located in 'Seattle, WA', sorted in descending order by highest amount raised. The database is not modified by this task, so only the accuracy and completeness of the returned data in final_answer must be checked. The verification code must: (1) identify the correct campaigns from the database using category and location filters, (2) calculate the amount raised for each campaign from the donations table, (3) sort campaigns by amount raised descending and select the top 5, (4) extract campaign info from final_answer and (5) confirm that the answer includes exactly these 5 campaigns, in the correct order, with accurate information. All other cases are 'others'.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Identify 'Animals' category id in initial_db\",\n        \"Get all campaigns with category_id='Animals', location_city='Seattle', location_region='WA', and status='active'\",\n        \"For each such campaign, sum all donations.amount_cents mapped to that campaign id in final_db\",\n        \"Sort eligible campaigns by total amount raised descending; select top 5\",\n        \"Extract campaign names/info from final_answer using robust regex\",\n        \"Validate that final_answer contains exactly these campaigns, in correct sorted order and with accurate raised amounts\",\n        \"Return 'complete' only if all criteria match; otherwise 'others'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Step 1: Get 'Animals' category id\\n    categories = safe_query(initial_db_path, \\\"SELECT id FROM categories WHERE name = ?\\\", (\\\"Animals\\\",))\\n    if not categories or not categories[0] or not isinstance(categories[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    animals_cat_id = categories[0][0]\\n    \\n    # Step 2: Get eligible campaigns in 'Seattle, WA', status active\\n    campaigns = safe_query(initial_db_path, \\\"\\\"\\\"\\n        SELECT id, title \\n        FROM campaigns \\n        WHERE category_id = ? AND location_city = ? AND location_region = ? AND status = 'active' \\n    \\\"\\\"\\\", (animals_cat_id, \\\"Seattle\\\", \\\"WA\\\"))\\n    if not campaigns:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    campaign_ids = [row[0] for row in campaigns]\\n    campaign_titles = {row[0]: row[1] for row in campaigns}\\n    \\n    # Step 3: For each campaign, sum amount_cents donated\\n    campaign_amounts = {}\\n    for camp_id in campaign_ids:\\n        # get all donations for this campaign in final_db (since agent should not modify donations, initial or final works; use final for RL safety)\\n        total = safe_query(final_db_path, \\\"SELECT SUM(amount_cents) FROM donations WHERE campaign_id = ?\\\", (camp_id,))\\n        amount = total[0][0] if total and total[0][0] is not None else 0\\n        campaign_amounts[camp_id] = amount\\n\\n    # Step 4: Sort by total raised descending, select top 5\\n    sorted_campaigns = sorted([(camp_id, campaign_titles[camp_id], campaign_amounts[camp_id]) for camp_id in campaign_ids], key=lambda x: (-x[2], x[1]))\\n    top5 = sorted_campaigns[:5]\\n\\n    # Step 5: Validate final_answer presence and structure\\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Build patterns for each campaign (title and amount)\\n    def money_pattern(amount):\\n        # e.g. $12345.00, $12,345, use cents-to-dollars conversion\\n        dollars = amount // 100\\n        cents = amount % 100\\n        if cents != 0:\\n            money_str = f\\\"\\\\${dollars:,}.{cents:02d}\\\"\\n        else:\\n            money_str = f\\\"\\\\${dollars:,}\\\"\\n        # Allow loose formatting: $12345, $12,345, $12345.00, $12,345.00\\n        return r\\\"\\\\$ ?\\\" + re.escape(str(dollars)) + r\\\"(,\\\\d{3})*(\\\\.\\\\d{2})?\\\"\\n\\n    campaign_checks = []\\n    for camp_id, title, amount in top5:\\n        # Look for the campaign title\\n        title_pattern = re.escape(title)\\n        # Look for the amount\\n        # Accept either full cents or rounded dollars\\n        amt_pattern = money_pattern(amount)\\n        campaign_checks.append((title_pattern, amt_pattern))\\n\\n    # Step 6: Extract campaign blocks from final_answer\\n    # Try to find exactly these 5 titles in order, each with a corresponding amount\\n    found_sequence = []\\n    answer_text = final_answer.lower()\\n    last_pos = 0\\n    for idx, (title_pat, amt_pat) in enumerate(campaign_checks):\\n        # Try to find title AFTER last found campaign\\n        title_regex = re.compile(title_pat, re.IGNORECASE)\\n        amt_regex = re.compile(amt_pat, re.IGNORECASE)\\n        m_title = title_regex.search(final_answer, last_pos)\\n        if not m_title:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # Search for amount near title\\n        amt_window_start = max(m_title.start() - 100, 0)\\n        amt_window_end = m_title.end() + 100\\n        amt_text = final_answer[amt_window_start:amt_window_end]\\n        m_amt = amt_regex.search(amt_text)\\n        if not m_amt:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        found_sequence.append((title_pat, amt_pat))\\n        last_pos = m_title.end()\\n\\n    # Now ensure there are exactly 5 unique campaigns in answer and no extras\\n    # Extract all matching campaign titles from final_answer\\n    all_titles = [re.escape(title) for camp_id, title, amount in sorted_campaigns]\\n    title_regex_all = re.compile('|'.join(all_titles), re.IGNORECASE)\\n    found_titles = [m.group().strip() for m in title_regex_all.finditer(final_answer)]\\n    found_titles_set = set([t.lower() for t in found_titles])\\n    top_titles_set = set([title.lower() for camp_id, title, amount in top5])\\n    # Only these top 5 titles should appear\\n    if not top_titles_set.issubset(found_titles_set):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # If more than these appear, allow only if not extra Seattle Animals campaigns\\n    if any(title for title in found_titles_set if title not in top_titles_set):\\n        # Possibly answer includes extra campaigns, so we fail\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # If the titles were not found in order, fail\\n    expected_order = [title.lower() for camp_id, title, amount in top5]\\n    actual_order = [t.lower() for t in found_titles if t.lower() in top_titles_set]\\n    if actual_order != expected_order:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks passed; 100% certain task was completed\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 5, "task": "Create a recurring monthly pledge of 20 USD to the campaign \"Wildfire Relief for Sonoma\" starting on 2026-03-01 with donor name \"Jordan Patel\", message \"Stay strongsending continued support.\", and set anonymity to true.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Defensive helper to run safe queries\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # returns list of tuples\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            res = cursor.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n\n    # Helper: find campaign_id for target title\n    def get_campaign_id(db_path: str, title: str):\n        rows = safe_query(db_path, \"SELECT id FROM campaigns WHERE title = ?\", (title,))\n        if not rows or len(rows[0]) < 1:\n            return None\n        return rows[0][0]\n\n    # Strictly match all required fields for donation_intent\n    def matching_intents(db_path, campaign_id):\n        if campaign_id is None:\n            return []\n        query = (\n            \"SELECT id, donor_user_id, donor_name, message, is_anonymous, kind, currency_code, amount_cents, \"\n            \"start_date, interval_unit, interval_count, status \"\n            \"FROM donation_intents WHERE \"\n            \"campaign_id = ? AND \"\n            \"donor_name = ? AND \"\n            \"message = ? AND \"\n            \"is_anonymous = 1 AND \"\n            \"kind = 'recurring' AND \"\n            \"currency_code = 'USD' AND \"\n            \"amount_cents = 2000 AND \"\n            \"start_date = '2026-03-01' AND \"\n            \"interval_unit = 'month' AND \"\n            \"interval_count = 1 AND \"\n            \"status = 'active'\"\n        )\n        params = (\n            campaign_id,\n            'Jordan Patel',\n            'Stay strongsending continued support.'\n        )\n        # Return full rows (tuples)\n        return safe_query(db_path, query, params)\n\n    # Get ALL matching intents (even wrong status etc.) for disambiguation\n    def loose_matching_intents(db_path, campaign_id):\n        if campaign_id is None:\n            return []\n        query = (\n            \"SELECT id FROM donation_intents WHERE \"\n            \"campaign_id = ? AND \"\n            \"donor_name = ? AND \"\n            \"message = ? AND \"\n            \"is_anonymous = 1 AND \"\n            \"kind = 'recurring' AND \"\n            \"currency_code = 'USD' AND \"\n            \"amount_cents = 2000 AND \"\n            \"start_date = '2026-03-01' AND \"\n            \"interval_unit = 'month' AND \"\n            \"interval_count = 1\"\n        )\n        params = (\n            campaign_id, 'Jordan Patel', 'Stay strongsending continued support.'\n        )\n        return safe_query(db_path, query, params)\n\n    # 1. Find campaign_id for 'Wildfire Relief for Sonoma' in both DBs (should exist)\n    cid_final = get_campaign_id(final_db_path, \"Wildfire Relief for Sonoma\")\n    cid_initial = get_campaign_id(initial_db_path, \"Wildfire Relief for Sonoma\")\n    if (cid_final is None) or (cid_initial is None) or (cid_final != cid_initial):\n        return {\"result\": \"others\"}\n\n    # 2. Strictly look for matching intent in final DB\n    final_intents = matching_intents(final_db_path, cid_final)\n    if len(final_intents) != 1:\n        return {\"result\": \"others\"}\n    \n    # 3. There must be NO such intent in the INITIAL DB\n    initial_intents_strict = matching_intents(initial_db_path, cid_initial)\n    if len(initial_intents_strict) != 0:\n        return {\"result\": \"others\"}\n\n    # 4. Also ensure only one new loose match is present (prevent accidental double-creation, wrong status, etc.)\n    initial_loose = set([row[0] for row in loose_matching_intents(initial_db_path, cid_initial)])\n    final_loose = set([row[0] for row in loose_matching_intents(final_db_path, cid_final)])\n    new_ids = final_loose - initial_loose\n    if len(new_ids) != 1 or len(final_loose) != 1:\n        return {\"result\": \"others\"}\n\n    # 5. Defensive: ensure the record is precisely as defined (fields)\n    record = final_intents[0]\n    # record fields: id, donor_user_id, donor_name, message, is_anonymous, kind, currency_code, amount_cents, start_date, interval_unit, interval_count, status\n    if (\n        record[2] != 'Jordan Patel' or\n        record[3] != 'Stay strongsending continued support.' or\n        record[4] != 1 or\n        record[5] != 'recurring' or\n        record[6] != 'USD' or\n        record[7] != 2000 or\n        record[8] != '2026-03-01' or\n        record[9] != 'month' or\n        record[10] != 1 or\n        record[11] != 'active'\n    ):\n        return {\"result\": \"others\"}\n    # All checks passed: single, correct, new intent, all values as required\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The user task is to create a specific new recurring donation pledge to the campaign 'Wildfire Relief for Sonoma' with the following precise attributes: (1) recurring monthly (interval_unit = 'month', interval_count = 1), (2) 20 USD amount, (3) starts on 2026-03-01, (4) donor name 'Jordan Patel', (5) message 'Stay strongsending continued support.', and (6) anonymity set to true (is_anonymous = 1). The pledge must only be considered created if it did not exist in the initial database, but does exist in the final database with all required fields matching exactly. We must ensure: (a) The campaign 'Wildfire Relief for Sonoma' exists and get its ID; (b) There is NO matching donation_intent before but EXACTLY ONE after with all required values; (c) The intent must have kind='recurring', status='active', and not be in 'canceled' or 'completed'; (d) All edge cases are handled robustly (e.g., no extra pledges created, misfields, misattribution, wrong campaign). This is a modification-based task.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find campaign_id for title = 'Wildfire Relief for Sonoma'.\",\n        \"Confirm in the initial_db there is NO recurring donation_intent for that campaign, with donor_name 'Jordan Patel', amount 2000, currency_code 'USD', message 'Stay strongsending continued support.', is_anonymous=1, kind='recurring', start_date='2026-03-01', interval_unit='month', interval_count=1.\",\n        \"Confirm in the final_db there is EXACTLY ONE donation_intent matching the above, with status='active'.\",\n        \"Check that there is only one such new record created by the agent (no duplicates, no mismatches).\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Defensive helper to run safe queries\\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # returns list of tuples\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            res = cursor.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n\\n    # Helper: find campaign_id for target title\\n    def get_campaign_id(db_path: str, title: str):\\n        rows = safe_query(db_path, \\\"SELECT id FROM campaigns WHERE title = ?\\\", (title,))\\n        if not rows or len(rows[0]) < 1:\\n            return None\\n        return rows[0][0]\\n\\n    # Strictly match all required fields for donation_intent\\n    def matching_intents(db_path, campaign_id):\\n        if campaign_id is None:\\n            return []\\n        query = (\\n            \\\"SELECT id, donor_user_id, donor_name, message, is_anonymous, kind, currency_code, amount_cents, \\\"\\n            \\\"start_date, interval_unit, interval_count, status \\\"\\n            \\\"FROM donation_intents WHERE \\\"\\n            \\\"campaign_id = ? AND \\\"\\n            \\\"donor_name = ? AND \\\"\\n            \\\"message = ? AND \\\"\\n            \\\"is_anonymous = 1 AND \\\"\\n            \\\"kind = 'recurring' AND \\\"\\n            \\\"currency_code = 'USD' AND \\\"\\n            \\\"amount_cents = 2000 AND \\\"\\n            \\\"start_date = '2026-03-01' AND \\\"\\n            \\\"interval_unit = 'month' AND \\\"\\n            \\\"interval_count = 1 AND \\\"\\n            \\\"status = 'active'\\\"\\n        )\\n        params = (\\n            campaign_id,\\n            'Jordan Patel',\\n            'Stay strongsending continued support.'\\n        )\\n        # Return full rows (tuples)\\n        return safe_query(db_path, query, params)\\n\\n    # Get ALL matching intents (even wrong status etc.) for disambiguation\\n    def loose_matching_intents(db_path, campaign_id):\\n        if campaign_id is None:\\n            return []\\n        query = (\\n            \\\"SELECT id FROM donation_intents WHERE \\\"\\n            \\\"campaign_id = ? AND \\\"\\n            \\\"donor_name = ? AND \\\"\\n            \\\"message = ? AND \\\"\\n            \\\"is_anonymous = 1 AND \\\"\\n            \\\"kind = 'recurring' AND \\\"\\n            \\\"currency_code = 'USD' AND \\\"\\n            \\\"amount_cents = 2000 AND \\\"\\n            \\\"start_date = '2026-03-01' AND \\\"\\n            \\\"interval_unit = 'month' AND \\\"\\n            \\\"interval_count = 1\\\"\\n        )\\n        params = (\\n            campaign_id, 'Jordan Patel', 'Stay strongsending continued support.'\\n        )\\n        return safe_query(db_path, query, params)\\n\\n    # 1. Find campaign_id for 'Wildfire Relief for Sonoma' in both DBs (should exist)\\n    cid_final = get_campaign_id(final_db_path, \\\"Wildfire Relief for Sonoma\\\")\\n    cid_initial = get_campaign_id(initial_db_path, \\\"Wildfire Relief for Sonoma\\\")\\n    if (cid_final is None) or (cid_initial is None) or (cid_final != cid_initial):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Strictly look for matching intent in final DB\\n    final_intents = matching_intents(final_db_path, cid_final)\\n    if len(final_intents) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # 3. There must be NO such intent in the INITIAL DB\\n    initial_intents_strict = matching_intents(initial_db_path, cid_initial)\\n    if len(initial_intents_strict) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Also ensure only one new loose match is present (prevent accidental double-creation, wrong status, etc.)\\n    initial_loose = set([row[0] for row in loose_matching_intents(initial_db_path, cid_initial)])\\n    final_loose = set([row[0] for row in loose_matching_intents(final_db_path, cid_final)])\\n    new_ids = final_loose - initial_loose\\n    if len(new_ids) != 1 or len(final_loose) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Defensive: ensure the record is precisely as defined (fields)\\n    record = final_intents[0]\\n    # record fields: id, donor_user_id, donor_name, message, is_anonymous, kind, currency_code, amount_cents, start_date, interval_unit, interval_count, status\\n    if (\\n        record[2] != 'Jordan Patel' or\\n        record[3] != 'Stay strongsending continued support.' or\\n        record[4] != 1 or\\n        record[5] != 'recurring' or\\n        record[6] != 'USD' or\\n        record[7] != 2000 or\\n        record[8] != '2026-03-01' or\\n        record[9] != 'month' or\\n        record[10] != 1 or\\n        record[11] != 'active'\\n    ):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed: single, correct, new intent, all values as required\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 6, "task": "Fetch my donation history for the last 90 days and return each donations campaign title, amount, date, and whether it was one-time or recurring.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n\n    # Helper for DB queries\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    if final_answer is None or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n\n    # 1. Get user_id for 'current_user' from users table (robustly)\n    user_row = safe_query(final_db_path, \"SELECT id, username FROM users WHERE username=?\", (\"current_user\",))\n    if not user_row:\n        return {\"result\": \"others\"}\n    user_id = user_row[0][0]\n\n    # 2. Compute last 90 days window (based on maximum donated_at timestamp in donations table)\n    donated_at_rows = safe_query(final_db_path, \"SELECT MAX(donated_at) FROM donations\")\n    try:\n        max_donated_at = donated_at_rows[0][0]\n        reference_dt = datetime.strptime(max_donated_at, \"%Y-%m-%d %H:%M:%S\")\n    except Exception:\n        reference_dt = datetime.utcnow()\n    # 90 days before\n    window_start_dt = reference_dt - timedelta(days=90)\n    window_start_str = window_start_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n    window_end_str = reference_dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # 3. Fetch all donations for current_user in last 90 days\n    donations_query = '''\n        SELECT d.id, d.donation_intent_id, d.campaign_id, d.amount_cents, d.donated_at\n        FROM donations d\n        WHERE d.donor_user_id=? \n          AND d.donated_at >= ? AND d.donated_at <= ?\n        ORDER BY d.donated_at ASC\n    '''\n    donation_rows = safe_query(final_db_path, donations_query, (user_id, window_start_str, window_end_str))\n\n    # For each donation, get campaign title and donation type (one-time/recurring)\n    donation_infos = []\n    for d in donation_rows:\n        donation_id, donation_intent_id, campaign_id, amount_cents, donated_at = d\n        # Get campaign title\n        c_row = safe_query(final_db_path, \"SELECT title FROM campaigns WHERE id=?\", (campaign_id,))\n        campaign_title = c_row[0][0] if c_row else None\n        # Determine type\n        if donation_intent_id is None:\n            donation_type = None\n        else:\n            kind_row = safe_query(final_db_path, \"SELECT kind FROM donation_intents WHERE id=?\", (donation_intent_id,))\n            donation_type = kind_row[0][0] if kind_row else None\n        # Defensive: if campaign_title missing or donation_type missing, fail\n        if not campaign_title or donation_type not in (\"one_time\", \"recurring\"):\n            return {\"result\": \"others\"}\n        donation_infos.append({\n            \"campaign_title\": campaign_title,\n            \"amount_cents\": amount_cents,\n            \"donated_at\": donated_at,\n            \"donation_type\": donation_type\n        })\n\n    # 4. Parse final_answer for donation records\n    # Build regex for expected donation entry: must match title, amount, date, type (allow flexible wording for recurring)\n    # Examples: 'Campaign: Help Mayas Recovery, Amount: $50.00, Date: 2026-01-24, Type: one-time'\n    #           'Campaign: Wildfire Relief for Sonoma, Amount: $20.00, Date: 2026-03-01, Type: recurring'\n    def extract_donations(text):\n        donations_found = []\n        # Acceptable dollar regex\n        dollar_re = re.compile(r\"\\$(\\d{1,7}(?:\\.\\d{2})?)\")\n        # Accept flexible field order and line breaks\n        # Main regex: capture campaign title, amount, date, type\n        entry_re = re.compile(\n            r\"(?i)(?:Campaign|Title|Fund|Project|Name):\\s*([\\w\\s'\\-.,&]+).*?Amount:\\s*\\$([\\d,]+(?:\\.\\d{2})?).*?Date:?\\s*(\\d{4}-\\d{2}-\\d{2}).*?(Type|Donation type|Kind):?\\s*(one[-_\\s]?time|recurring|monthly|single)\",\n            re.DOTALL\n        )\n        for match in entry_re.finditer(text):\n            title = match.group(1).strip()\n            amount_str = match.group(2).replace(\",\",\"\")\n            try:\n                # Defensive conversion\n                amount_cents = int(round(float(amount_str) * 100))\n            except Exception:\n                continue\n            date_str = match.group(3)\n            type_str = match.group(5).lower()\n            # Normalize donation_type\n            dt = \"recurring\" if \"recurring\" in type_str or \"monthly\" in type_str else \"one_time\"\n            donations_found.append({\n                \"campaign_title\": title,\n                \"amount_cents\": amount_cents,\n                \"donated_at\": date_str,\n                \"donation_type\": dt\n            })\n        return donations_found\n\n    extracted = extract_donations(final_answer)\n    # Defensive: if not all donations found, fail\n    if len(extracted) != len(donation_infos):\n        return {\"result\": \"others\"}\n    # Compare entries one by one (order-insensitive)\n    def key(d):\n        return (d[\"campaign_title\"], d[\"amount_cents\"], d[\"donated_at\"], d[\"donation_type\"])\n    db_set = set(key(d) for d in donation_infos)\n    ans_set = set(key(d) for d in extracted)\n    if db_set != ans_set:\n        return {\"result\": \"others\"}\n    # All entries present and fields correct\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The task is a query: the agent must fetch the user's donation history for the last 90 days and return, for each donation, the campaign title, amount, date, and whether it was one-time or recurring. To verify completion, the function must (1) extract all relevant donation records for the current_user (Taylor Nguyen, user_id=1) from the database after agent execution, (2) check if the final_answer contains the required fields for each matching donation, and (3) confirm that all donations are correctly represented (no omissions, all fields present and accurate). If the answer is missing, incomplete, or contains errors, the result must be 'others'.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Extract user_id of current_user from database (users table)\",\n        \"Find all donations made by the current_user in the last 90 days using donated_at in the final_db\",\n        \"For each donation, fetch campaign title, amount, donation date, and donation type (one-time/recurring)\",\n        \"Parse final_answer via regex to extract donation records and fields\",\n        \"Check that donation count and all fields in final_answer match exactly the database values\",\n        \"If missing, incomplete, or incorrect, return 'others'; if all present and correct, return 'complete'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n\\n    # Helper for DB queries\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    if final_answer is None or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 1. Get user_id for 'current_user' from users table (robustly)\\n    user_row = safe_query(final_db_path, \\\"SELECT id, username FROM users WHERE username=?\\\", (\\\"current_user\\\",))\\n    if not user_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    user_id = user_row[0][0]\\n\\n    # 2. Compute last 90 days window (based on maximum donated_at timestamp in donations table)\\n    donated_at_rows = safe_query(final_db_path, \\\"SELECT MAX(donated_at) FROM donations\\\")\\n    try:\\n        max_donated_at = donated_at_rows[0][0]\\n        reference_dt = datetime.strptime(max_donated_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    except Exception:\\n        reference_dt = datetime.utcnow()\\n    # 90 days before\\n    window_start_dt = reference_dt - timedelta(days=90)\\n    window_start_str = window_start_dt.strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n    window_end_str = reference_dt.strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n\\n    # 3. Fetch all donations for current_user in last 90 days\\n    donations_query = '''\\n        SELECT d.id, d.donation_intent_id, d.campaign_id, d.amount_cents, d.donated_at\\n        FROM donations d\\n        WHERE d.donor_user_id=? \\n          AND d.donated_at >= ? AND d.donated_at <= ?\\n        ORDER BY d.donated_at ASC\\n    '''\\n    donation_rows = safe_query(final_db_path, donations_query, (user_id, window_start_str, window_end_str))\\n\\n    # For each donation, get campaign title and donation type (one-time/recurring)\\n    donation_infos = []\\n    for d in donation_rows:\\n        donation_id, donation_intent_id, campaign_id, amount_cents, donated_at = d\\n        # Get campaign title\\n        c_row = safe_query(final_db_path, \\\"SELECT title FROM campaigns WHERE id=?\\\", (campaign_id,))\\n        campaign_title = c_row[0][0] if c_row else None\\n        # Determine type\\n        if donation_intent_id is None:\\n            donation_type = None\\n        else:\\n            kind_row = safe_query(final_db_path, \\\"SELECT kind FROM donation_intents WHERE id=?\\\", (donation_intent_id,))\\n            donation_type = kind_row[0][0] if kind_row else None\\n        # Defensive: if campaign_title missing or donation_type missing, fail\\n        if not campaign_title or donation_type not in (\\\"one_time\\\", \\\"recurring\\\"):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        donation_infos.append({\\n            \\\"campaign_title\\\": campaign_title,\\n            \\\"amount_cents\\\": amount_cents,\\n            \\\"donated_at\\\": donated_at,\\n            \\\"donation_type\\\": donation_type\\n        })\\n\\n    # 4. Parse final_answer for donation records\\n    # Build regex for expected donation entry: must match title, amount, date, type (allow flexible wording for recurring)\\n    # Examples: 'Campaign: Help Mayas Recovery, Amount: $50.00, Date: 2026-01-24, Type: one-time'\\n    #           'Campaign: Wildfire Relief for Sonoma, Amount: $20.00, Date: 2026-03-01, Type: recurring'\\n    def extract_donations(text):\\n        donations_found = []\\n        # Acceptable dollar regex\\n        dollar_re = re.compile(r\\\"\\\\$(\\\\d{1,7}(?:\\\\.\\\\d{2})?)\\\")\\n        # Accept flexible field order and line breaks\\n        # Main regex: capture campaign title, amount, date, type\\n        entry_re = re.compile(\\n            r\\\"(?i)(?:Campaign|Title|Fund|Project|Name):\\\\s*([\\\\w\\\\s'\\\\-.,&]+).*?Amount:\\\\s*\\\\$([\\\\d,]+(?:\\\\.\\\\d{2})?).*?Date:?\\\\s*(\\\\d{4}-\\\\d{2}-\\\\d{2}).*?(Type|Donation type|Kind):?\\\\s*(one[-_\\\\s]?time|recurring|monthly|single)\\\",\\n            re.DOTALL\\n        )\\n        for match in entry_re.finditer(text):\\n            title = match.group(1).strip()\\n            amount_str = match.group(2).replace(\\\",\\\",\\\"\\\")\\n            try:\\n                # Defensive conversion\\n                amount_cents = int(round(float(amount_str) * 100))\\n            except Exception:\\n                continue\\n            date_str = match.group(3)\\n            type_str = match.group(5).lower()\\n            # Normalize donation_type\\n            dt = \\\"recurring\\\" if \\\"recurring\\\" in type_str or \\\"monthly\\\" in type_str else \\\"one_time\\\"\\n            donations_found.append({\\n                \\\"campaign_title\\\": title,\\n                \\\"amount_cents\\\": amount_cents,\\n                \\\"donated_at\\\": date_str,\\n                \\\"donation_type\\\": dt\\n            })\\n        return donations_found\\n\\n    extracted = extract_donations(final_answer)\\n    # Defensive: if not all donations found, fail\\n    if len(extracted) != len(donation_infos):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Compare entries one by one (order-insensitive)\\n    def key(d):\\n        return (d[\\\"campaign_title\\\"], d[\\\"amount_cents\\\"], d[\\\"donated_at\\\"], d[\\\"donation_type\\\"])\\n    db_set = set(key(d) for d in donation_infos)\\n    ans_set = set(key(d) for d in extracted)\\n    if db_set != ans_set:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All entries present and fields correct\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 7, "task": "Generate a donation receipt for my donation to \"Community Food Pantry Restock\" made on 2026-01-20 for 75 USD and return the receipt metadata (receipt ID, date issued, and total).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Resolve campaign and user\n    # Get campaign id for 'Community Food Pantry Restock'\n    campaign_row = safe_query(final_db_path, \"SELECT id FROM campaigns WHERE title = ?\", (\"Community Food Pantry Restock\",))\n    if not campaign_row:\n        return {\"result\": \"others\"}\n    campaign_id = campaign_row[0][0]\n\n    # For user 'Taylor Nguyen' (current_user), per dump: user_id = 1\n    donor_user_id = 1\n\n    # 2. Find donation matching task criteria (date, amount, campaign, user) in final DB\n    # Allowed time window for date: '2026-01-20', match any time\n    # Amount: 75 USD => 7500 cents\n    donation_row = safe_query(\n        final_db_path,\n        \"\"\"\n        SELECT id, donated_at FROM donations \n        WHERE donor_user_id = ? AND campaign_id = ? AND amount_cents = ? AND currency_code = 'USD' \n        AND date(donated_at) = ?\n        ORDER BY donated_at ASC\n        \"\"\",\n        (donor_user_id, campaign_id, 7500, '2026-01-20')\n    )\n    if not donation_row:\n        return {\"result\": \"others\"}\n    # For deterministic matching, donation_id must be unique for this criteria\n    if len(donation_row) != 1:\n        return {\"result\": \"others\"}\n    donation_id, donated_at = donation_row[0]\n\n    # 3. Check for receipt for this donation in final DB\n    receipt_rows = safe_query(\n        final_db_path,\n        \"SELECT id, receipt_number, issued_at, total_amount_cents, currency_code FROM receipts WHERE donation_id = ?\",\n        (donation_id,)\n    )\n    if not receipt_rows:\n        return {\"result\": \"others\"}\n    if len(receipt_rows) != 1:\n        return {\"result\": \"others\"}\n    receipt_id, receipt_number, issued_at, total_amount_cents, currency_code = receipt_rows[0]\n\n    # 4. Make sure this receipt was NOT present in the initial DB\n    initial_receipts = safe_query(\n        initial_db_path,\n        \"SELECT id FROM receipts WHERE donation_id = ?\",\n        (donation_id,)\n    )\n    # If present before, it's not newly generated\n    if initial_receipts:\n        return {\"result\": \"others\"}\n\n    # 5. final_answer must contain all required metadata matching DB: receipt id (or number), issued date, total\n    if not final_answer or not isinstance(final_answer, str):\n        return {\"result\": \"others\"}\n\n    text = final_answer.strip().replace('\\n', ' ')\n    # Accept 'receipt id', 'receipt number', or 'receipt #', case-insensitive\n    id_match = re.search(r\"receipt (id|number|#)[:\\s]*([\\w\\-]+)\", text, re.IGNORECASE)\n    if not id_match:\n        return {\"result\": \"others\"}\n    fa_receipt_num = id_match.group(2)\n\n    # Accept 'date issued', 'issued at', 'issue date', etc.\n    date_match = re.search(r\"date issued[:\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\", text, re.IGNORECASE)\n    if not date_match:\n        # Try alternative: 'issued at:'\n        date_match2 = re.search(r\"issued at[:\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\", text, re.IGNORECASE)\n        if not date_match2:\n            # Accept full timestamp, just match date part\n            date_match3 = re.search(r\"date issued[:\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\", text, re.IGNORECASE)\n            fa_issued_date = None if not date_match3 else date_match3.group(1)\n        else:\n            fa_issued_date = date_match2.group(1)\n    else:\n        fa_issued_date = date_match.group(1)\n\n    # If not found, try 'issued on:' variant and match date\n    if not 'fa_issued_date' in locals() or not fa_issued_date:\n        date_match4 = re.search(r\"issued on[:\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\", text, re.IGNORECASE)\n        if date_match4:\n            fa_issued_date = date_match4.group(1)\n    # If still no date found, reject\n    if not 'fa_issued_date' in locals() or not fa_issued_date:\n        return {\"result\": \"others\"}\n\n    # Accept 'total: $75', 'amount: $75', etc.\n    total_match = re.search(r\"(total|amount)[:\\s]*\\$?([0-9]+(?:\\.[0-9]{2})?)\", text, re.IGNORECASE)\n    if not total_match:\n        # Accept cents\n        total_match2 = re.search(r\"(total|amount)[:\\s]*([0-9]+)[ ]?usd\", text, re.IGNORECASE)\n        if not total_match2:\n            return {\"result\": \"others\"}\n        fa_total = total_match2.group(2)\n    else:\n        fa_total = total_match.group(2)\n    # Normalize to '75.00' for comparison\n    try:\n        fa_total_cents = int(round(float(fa_total) * 100))\n    except Exception:\n        return {\"result\": \"others\"}\n\n    # 6. Match values vs. DB\n    # Receipt number must match exactly\n    if str(fa_receipt_num).strip() != str(receipt_number).strip():\n        return {\"result\": \"others\"}\n\n    # Issued date: consider only date part from timestamp\n    issued_date = str(issued_at)[:10]\n    if fa_issued_date != issued_date:\n        return {\"result\": \"others\"}\n\n    # Total: Must equal (in cents)\n    if fa_total_cents != total_amount_cents:\n        return {\"result\": \"others\"}\n\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n  \"reasoning\": \"To verify successful completion, we must (1) check the final database for a new donation receipt corresponding exactly to a donation of 75 USD made by the current user (Taylor Nguyen, user_id=1) to the \\\"Community Food Pantry Restock\\\" campaign (campaign_id=102) on 2026-01-20, (2) confirm that this receipt did not exist in the initial database, and (3) confirm that the final_answer contains the required metadata fields (receipt ID/number, date issued, total) matching the DB. The task requires both data creation and query, so both must be checked.\",\n  \"verification_strategy\": \"combined\",\n  \"key_checks\": [\n    \"Find the user's donation to 'Community Food Pantry Restock' (campaign_id=102) for 7500 cents (75 USD) on 2026-01-20 in the final database\",\n    \"Verify that a new row was added in 'receipts' in the final DB for this donation, compared to the initial DB\",\n    \"Extract receipt id/number, date issued, and total from the final_answer text\",\n    \"Ensure final_answer values match the corresponding values in the final database record for the new receipt\",\n    \"Edge case: If there is no new receipt for the correct donation, or if the metadata does not exactly match (or final_answer is missing/malformed), return others\"\n  ],\n  \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Resolve campaign and user\\n    # Get campaign id for 'Community Food Pantry Restock'\\n    campaign_row = safe_query(final_db_path, \\\"SELECT id FROM campaigns WHERE title = ?\\\", (\\\"Community Food Pantry Restock\\\",))\\n    if not campaign_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    campaign_id = campaign_row[0][0]\\n\\n    # For user 'Taylor Nguyen' (current_user), per dump: user_id = 1\\n    donor_user_id = 1\\n\\n    # 2. Find donation matching task criteria (date, amount, campaign, user) in final DB\\n    # Allowed time window for date: '2026-01-20', match any time\\n    # Amount: 75 USD => 7500 cents\\n    donation_row = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id, donated_at FROM donations \\n        WHERE donor_user_id = ? AND campaign_id = ? AND amount_cents = ? AND currency_code = 'USD' \\n        AND date(donated_at) = ?\\n        ORDER BY donated_at ASC\\n        \\\"\\\"\\\",\\n        (donor_user_id, campaign_id, 7500, '2026-01-20')\\n    )\\n    if not donation_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # For deterministic matching, donation_id must be unique for this criteria\\n    if len(donation_row) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    donation_id, donated_at = donation_row[0]\\n\\n    # 3. Check for receipt for this donation in final DB\\n    receipt_rows = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, receipt_number, issued_at, total_amount_cents, currency_code FROM receipts WHERE donation_id = ?\\\",\\n        (donation_id,)\\n    )\\n    if not receipt_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if len(receipt_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    receipt_id, receipt_number, issued_at, total_amount_cents, currency_code = receipt_rows[0]\\n\\n    # 4. Make sure this receipt was NOT present in the initial DB\\n    initial_receipts = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM receipts WHERE donation_id = ?\\\",\\n        (donation_id,)\\n    )\\n    # If present before, it's not newly generated\\n    if initial_receipts:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. final_answer must contain all required metadata matching DB: receipt id (or number), issued date, total\\n    if not final_answer or not isinstance(final_answer, str):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    text = final_answer.strip().replace('\\\\n', ' ')\\n    # Accept 'receipt id', 'receipt number', or 'receipt #', case-insensitive\\n    id_match = re.search(r\\\"receipt (id|number|#)[:\\\\s]*([\\\\w\\\\-]+)\\\", text, re.IGNORECASE)\\n    if not id_match:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    fa_receipt_num = id_match.group(2)\\n\\n    # Accept 'date issued', 'issued at', 'issue date', etc.\\n    date_match = re.search(r\\\"date issued[:\\\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\\\", text, re.IGNORECASE)\\n    if not date_match:\\n        # Try alternative: 'issued at:'\\n        date_match2 = re.search(r\\\"issued at[:\\\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\\\", text, re.IGNORECASE)\\n        if not date_match2:\\n            # Accept full timestamp, just match date part\\n            date_match3 = re.search(r\\\"date issued[:\\\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\\\", text, re.IGNORECASE)\\n            fa_issued_date = None if not date_match3 else date_match3.group(1)\\n        else:\\n            fa_issued_date = date_match2.group(1)\\n    else:\\n        fa_issued_date = date_match.group(1)\\n\\n    # If not found, try 'issued on:' variant and match date\\n    if not 'fa_issued_date' in locals() or not fa_issued_date:\\n        date_match4 = re.search(r\\\"issued on[:\\\\s]*([0-9]{4}-[0-9]{2}-[0-9]{2})\\\", text, re.IGNORECASE)\\n        if date_match4:\\n            fa_issued_date = date_match4.group(1)\\n    # If still no date found, reject\\n    if not 'fa_issued_date' in locals() or not fa_issued_date:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Accept 'total: $75', 'amount: $75', etc.\\n    total_match = re.search(r\\\"(total|amount)[:\\\\s]*\\\\$?([0-9]+(?:\\\\.[0-9]{2})?)\\\", text, re.IGNORECASE)\\n    if not total_match:\\n        # Accept cents\\n        total_match2 = re.search(r\\\"(total|amount)[:\\\\s]*([0-9]+)[ ]?usd\\\", text, re.IGNORECASE)\\n        if not total_match2:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        fa_total = total_match2.group(2)\\n    else:\\n        fa_total = total_match.group(2)\\n    # Normalize to '75.00' for comparison\\n    try:\\n        fa_total_cents = int(round(float(fa_total) * 100))\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Match values vs. DB\\n    # Receipt number must match exactly\\n    if str(fa_receipt_num).strip() != str(receipt_number).strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Issued date: consider only date part from timestamp\\n    issued_date = str(issued_at)[:10]\\n    if fa_issued_date != issued_date:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Total: Must equal (in cents)\\n    if fa_total_cents != total_amount_cents:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n  \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 8, "task": "Configure withdrawal settings for my campaign \"Help Mayas Recovery\" by adding a bank account with metadata {\"bank_name\":\"Chase\",\"account_last4\":\"1234\",\"account_type\":\"checking\"} and set it as the default payout method.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    CAMPAIGN_ID = 101\n    OWNER_USER_ID = 1\n    EXPECTED_META = {\n        'bank_name': 'Chase',\n        'account_last4': '1234',\n        'account_type': 'checking'\n    }\n    EXPECTED_TYPE = 'bank_account'\n    EXPECTED_IS_DEFAULT = 1\n\n    # 1. Find the payout_methods record in final_db\n    payout_methods = safe_query(\n        final_db_path,\n        \"\"\"\n        SELECT id FROM payout_methods\n        WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ? AND is_default = ?\n        \"\"\",\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'], EXPECTED_IS_DEFAULT)\n    )\n    if len(payout_methods) != 1:\n        return {\"result\": \"others\"}\n    payout_method_id = payout_methods[0][0]\n\n    # 2. Verify campaign_payout_settings for campaign_id = 101 references this payout method\n    campaign_payout_settings = safe_query(\n        final_db_path,\n        \"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\",\n        (CAMPAIGN_ID,)\n    )\n    if len(campaign_payout_settings) != 1:\n        return {\"result\": \"others\"}\n    default_payout_method_id = campaign_payout_settings[0][0]\n    if default_payout_method_id != payout_method_id:\n        return {\"result\": \"others\"}\n    # 3. Defensive: Ensure there are not duplicate payout_methods records matching (should not happen by constraints, but check)\n    payout_methods_dupes = safe_query(\n        final_db_path,\n        \"\"\"\n        SELECT COUNT(*) FROM payout_methods\n        WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ? AND is_default = ?\n        \"\"\",\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'], EXPECTED_IS_DEFAULT)\n    )\n    if len(payout_methods_dupes) != 1:\n        return {\"result\": \"others\"}\n    if payout_methods_dupes[0][0] != 1:\n        return {\"result\": \"others\"}\n    # 4. Defensive: ensure this payout_methods record is present in both initial and final (should be, per original dump)\n    initial_payout_methods = safe_query(\n        initial_db_path,\n        \"SELECT id FROM payout_methods WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ?\",\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'])\n    )\n    if len(initial_payout_methods) != 1:\n        return {\"result\": \"others\"}\n    # 5. Ensure campaign_payout_settings.default_payout_method_id in initial_db for campaign 101 was NOT pointing to this id\n    initial_campaign_payout_settings = safe_query(\n        initial_db_path,\n        \"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\",\n        (CAMPAIGN_ID,)\n    )\n    if len(initial_campaign_payout_settings) != 1:\n        return {\"result\": \"others\"}\n    initial_default_payout_method_id = initial_campaign_payout_settings[0][0]\n    # If initial was already set to this payout_method_id and is_default=1, it's not a change, so not a new configuration (but the prompt suggests a modification is always expected)\n    if initial_default_payout_method_id == payout_method_id:\n        # Still, for safety, check if is_default was 1 in initial (should be per dump)\n        prev_is_default = safe_query(\n            initial_db_path,\n            \"SELECT is_default FROM payout_methods WHERE id = ?\",\n            (payout_method_id,)\n        )\n        if len(prev_is_default) == 1 and prev_is_default[0][0] == 1:\n            # The setting was already active in the initial DB, so task was already done\n            return {\"result\": \"others\"}\n        # If for some reason is_default was not 1 and now it is, accept\n    # All conditions met\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"This task requires verifying that the campaign 'Help Mayas Recovery' (campaign_id=101, owned by user_id=1) has had its withdrawal (payout) settings updated by adding a bank account with metadata bank_name='Chase', account_last4='1234', account_type='checking', and setting this account as the DEFAULT payout method for the campaign. Modification must be directly observed in the DB: (1) a payout_methods record for the user with those attributes exists, (2) campaign_payout_settings.default_payout_method_id for campaign_id=101 points to that payout method, and (3) that payout_methods record is marked as 'is_default=1'. Since this is a backend-only modification (not a query), only DB state must be evaluated, not the agent final_answer. The verification must be robust to malformed DBs or extraneous changes but can only be certain when all these checks strictly pass.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Verify that in final_db, there exists a payout_methods record for owner_user_id=1 with type='bank_account', bank_name='Chase', account_last4='1234', account_type='checking'.\",\n        \"Verify that this payout_methods record has is_default=1.\",\n        \"Verify that in final_db, the campaign_payout_settings row for campaign_id=101 has default_payout_method_id equal to the id of the matching payout_methods record.\",\n        \"Ensure the above payout_methods record was already present in initial_db (since the scenario initially already has it), so the key verification is that default_payout_method_id is set to this payout method and is_default=1.\",\n        \"Handle all missing or malformed cases as failure (return 'others').\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    CAMPAIGN_ID = 101\\n    OWNER_USER_ID = 1\\n    EXPECTED_META = {\\n        'bank_name': 'Chase',\\n        'account_last4': '1234',\\n        'account_type': 'checking'\\n    }\\n    EXPECTED_TYPE = 'bank_account'\\n    EXPECTED_IS_DEFAULT = 1\\n\\n    # 1. Find the payout_methods record in final_db\\n    payout_methods = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id FROM payout_methods\\n        WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ? AND is_default = ?\\n        \\\"\\\"\\\",\\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'], EXPECTED_IS_DEFAULT)\\n    )\\n    if len(payout_methods) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    payout_method_id = payout_methods[0][0]\\n\\n    # 2. Verify campaign_payout_settings for campaign_id = 101 references this payout method\\n    campaign_payout_settings = safe_query(\\n        final_db_path,\\n        \\\"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\\\",\\n        (CAMPAIGN_ID,)\\n    )\\n    if len(campaign_payout_settings) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    default_payout_method_id = campaign_payout_settings[0][0]\\n    if default_payout_method_id != payout_method_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 3. Defensive: Ensure there are not duplicate payout_methods records matching (should not happen by constraints, but check)\\n    payout_methods_dupes = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT COUNT(*) FROM payout_methods\\n        WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ? AND is_default = ?\\n        \\\"\\\"\\\",\\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'], EXPECTED_IS_DEFAULT)\\n    )\\n    if len(payout_methods_dupes) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if payout_methods_dupes[0][0] != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 4. Defensive: ensure this payout_methods record is present in both initial and final (should be, per original dump)\\n    initial_payout_methods = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM payout_methods WHERE owner_user_id = ? AND type = ? AND bank_name = ? AND account_last4 = ? AND account_type = ?\\\",\\n        (OWNER_USER_ID, EXPECTED_TYPE, EXPECTED_META['bank_name'], EXPECTED_META['account_last4'], EXPECTED_META['account_type'])\\n    )\\n    if len(initial_payout_methods) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 5. Ensure campaign_payout_settings.default_payout_method_id in initial_db for campaign 101 was NOT pointing to this id\\n    initial_campaign_payout_settings = safe_query(\\n        initial_db_path,\\n        \\\"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\\\",\\n        (CAMPAIGN_ID,)\\n    )\\n    if len(initial_campaign_payout_settings) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_default_payout_method_id = initial_campaign_payout_settings[0][0]\\n    # If initial was already set to this payout_method_id and is_default=1, it's not a change, so not a new configuration (but the prompt suggests a modification is always expected)\\n    if initial_default_payout_method_id == payout_method_id:\\n        # Still, for safety, check if is_default was 1 in initial (should be per dump)\\n        prev_is_default = safe_query(\\n            initial_db_path,\\n            \\\"SELECT is_default FROM payout_methods WHERE id = ?\\\",\\n            (payout_method_id,)\\n        )\\n        if len(prev_is_default) == 1 and prev_is_default[0][0] == 1:\\n            # The setting was already active in the initial DB, so task was already done\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # If for some reason is_default was not 1 and now it is, accept\\n    # All conditions met\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 9, "task": "Request a payout of 2500 USD from my campaign \"Help Mayas Recovery\" to the default bank account and return the created payouts status plus any risk/fraud flags or verification document requirements.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    import json\n    \n    # Helper for DB queries (read-only)\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # Step 1: Find campaign id for 'Help Mayas Recovery'\n    campaign_row = safe_query(final_db_path, \"SELECT id FROM campaigns WHERE title = ?\", (\"Help Mayas Recovery\",))\n    if not campaign_row or not isinstance(campaign_row[0][0], int):\n        return {\"result\": \"others\"}\n    campaign_id = campaign_row[0][0]\n    \n    # Step 2: Get owner_user_id for cross-validation later (optional, but robust)\n    owner_row = safe_query(final_db_path, \"SELECT owner_user_id FROM campaigns WHERE id = ?\", (campaign_id,))\n    if not owner_row or not isinstance(owner_row[0][0], int):\n        return {\"result\": \"others\"}\n    owner_user_id = owner_row[0][0]\n    \n    # Step 3: Find default payout method for this campaign (from campaign_payout_settings)\n    payout_settings_row = safe_query(final_db_path, \"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\", (campaign_id,))\n    if not payout_settings_row or not isinstance(payout_settings_row[0][0], int):\n        return {\"result\": \"others\"}\n    default_payout_method_id = payout_settings_row[0][0]\n    \n    # Step 4: Identify the NEW payout: get set of payouts for campaign in initial and final DB, then diff them\n    payout_fields = \"id, campaign_id, payout_method_id, amount_cents, currency_code, status, risk_level, risk_flags_json, verification_required\"\n    initial_payouts = safe_query(initial_db_path, f\"SELECT {payout_fields} FROM payouts WHERE campaign_id = ?\", (campaign_id,))\n    final_payouts = safe_query(final_db_path, f\"SELECT {payout_fields} FROM payouts WHERE campaign_id = ?\", (campaign_id,))\n    # Build sets for comparison: use all fields except id and created timestamps\n    def payout_key(row):\n        # row: id:0, campaign_id:1, payout_method_id:2, amount_cents:3, currency_code:4, status:5, risk_level:6, risk_flags_json:7, verification_required:8\n        return (\n            row[1],row[2],row[3],row[4]\n        ) # campaign_id, payout_method_id, amount_cents, currency_code\n    initial_keys = set([payout_key(r) for r in initial_payouts])\n    # Find new rows in final which are not in initial, and have expected attributes\n    candidate_payouts = []\n    for row in final_payouts:\n        # Must match campaign, method, amount, currency\n        if (row[1] == campaign_id and row[2] == default_payout_method_id and row[3] == 250000 and row[4] == 'USD'):\n            if payout_key(row) not in initial_keys:\n                candidate_payouts.append(row)\n    if not candidate_payouts:\n        # Not found, return others\n        return {\"result\": \"others\"}\n    if len(candidate_payouts) > 1:\n        return {\"result\": \"others\"} # Only 1 expected, more would be ambiguous\n    payout_row = candidate_payouts[0]\n    payout_id = payout_row[0]\n    payout_status = payout_row[5] if isinstance(payout_row[5], str) else \"\"\n    risk_level = payout_row[6] if isinstance(payout_row[6], str) else \"\"\n    risk_flags_json = payout_row[7] if isinstance(payout_row[7], str) else \"\"\n    verification_required = (payout_row[8]==1)\n\n    # Step 5: Read risk flags from JSON if present\n    risk_flags = []\n    if risk_flags_json:\n        try:\n            risk_obj = json.loads(risk_flags_json)\n            if isinstance(risk_obj, dict) and 'flags' in risk_obj:\n                flags = risk_obj['flags']\n                if isinstance(flags, list):\n                    risk_flags = [str(f) for f in flags]\n        except Exception:\n            risk_flags = [] # If parsing fails, treat as absent\n    # Step 6: Read payout_verification_requirements for this payout, if any\n    req_rows = safe_query(final_db_path,\n        \"SELECT requirement_type, status FROM payout_verification_requirements WHERE payout_id = ?\", (payout_id,))\n    requirements = [(r[0], r[1]) for r in req_rows if isinstance(r[0], str) and isinstance(r[1], str)]\n\n    # Step 7: Now check the agent's provided answer\n    if not final_answer or not isinstance(final_answer, str) or len(final_answer) < 4:\n        return {\"result\": \"others\"}\n    ans = final_answer\n\n    # a) The answer must mention payout status and should match DB\n    # It may be phrased like \"status: pending\", \"status is 'on_hold'\", etc.\n    status_patterns = [\n        rf\"status[\\s:]+['\\\"]?{re.escape(payout_status)}['\\\"]?\", # status: on_hold\n        rf\"payout .*status.*{re.escape(payout_status)}\",\n        rf\"status.*is.*{re.escape(payout_status)}\"\n    ]\n    if not any(re.search(pat, ans, re.IGNORECASE) for pat in status_patterns):\n        return {\"result\": \"others\"}\n    # b) The answer must mention risk/fraud flags and risk level\n    # Accept either explicit listing, e.g.:\n    #  - 'risk flags: [flag1, flag2]' or\n    #  - 'risk level: medium'\n    risk_mentioned = False\n    # Pattern for risk level\n    risk_lvl_pat = rf\"risk level[\\s:]+['\\\"]?{re.escape(risk_level)}['\\\"]?\"\n    if risk_level and re.search(risk_lvl_pat, ans, re.IGNORECASE):\n        risk_mentioned = True\n    # Pattern for listing all present flags\n    if risk_flags:\n        for flag in risk_flags:\n            # Pattern: flag name should appear in the answer near the words \"risk\" or \"flag\"\n            flag_pat = rf\"(risk|flag)[\\w\\s,:;'-]*{re.escape(flag)}\"\n            if not re.search(flag_pat, ans, re.IGNORECASE):\n                risk_mentioned = False\n                break\n        else:\n            # All flags mentioned at least once\n            risk_mentioned = True\n    elif not risk_flags:\n        # Should state risk is none (if so in db)\n        none_pat = r\"risk (flags|level)[\\w\\s,:;'-]*(none|no|absent|not detected)\"\n        if risk_level.lower() == 'none' and re.search(none_pat, ans, re.IGNORECASE):\n            risk_mentioned = True\n    if not risk_mentioned:\n        return {\"result\": \"others\"}\n    # c) The answer must mention document requirements (if present):\n    requirements_matched = True\n    if requirements:\n        for req_type, req_status in requirements:\n            # Example: identity_document required, bank_account_ownership required\n            type_pat = re.escape(req_type.replace('_',' '))\n            status_pat = re.escape(req_status)\n            # Accept e.g. 'identity document required', 'bank account ownership: required', etc.\n            # Some answers may phrase as 'Requirement: identity_document, status: required'\n            if not (re.search(rf\"{type_pat}[\\w\\s,:;'\\-]*{status_pat}\", ans, re.IGNORECASE) or\n                    re.search(rf\"{status_pat}[\\w\\s,:;'\\-]*{type_pat}\", ans, re.IGNORECASE)):\n                requirements_matched = False\n                break\n    else:\n        # No requirements present: answer should mention none/waived\n        no_req_pat = r\"(no|none|not required|waived)[\\w\\s,:;'\\-]*(verification|requirement|document)\"\n        if not re.search(no_req_pat, ans, re.IGNORECASE):\n            # If DB says none needed, answer must say so\n            requirements_matched = False\n    if not requirements_matched:\n        return {\"result\": \"others\"}\n    # If all checks passed:\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure the agent successfully requested a payout of 2500 USD from the 'Help Mayas Recovery' campaign to the default bank account, AND returned the created payouts status plus any risk/fraud flags or verification document requirements. This task is combined: it requires checking for a new payout record in the final DB with the correct attributes (250000 cents, 'USD', campaign title, default payout method), and confirming the final_answer includes (1) the status of this payout, (2) any risk/fraud flags, and (3) any verification requirements. All three components must match precisely for the result to be 'complete', and any ambiguity or mismatch should return 'others'. Data must be cross-validated between the database and the returned answer. Defensive programming is needed around edge cases in both database and answer parsing.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"1. Identify the campaign 'Help Mayas Recovery' (get its id and owner).\",\n        \"2. Get the default payout method for this campaign.\",\n        \"3. Find any NEW payout in the final DB for this campaign, method, amount=250000 cents, currency='USD' (compared to the initial DB).\",\n        \"4. Extract status, risk flags (including risk_level, risk_flags_json), and any verification requirements for this payout from the final DB.\",\n        \"5. Parse final_answer and verify it contains:\",\n        \"   a) Status of the created payout (textually).\",\n        \"   b) Any risk/fraud flags (must mention if present).\",\n        \"   c) Any verification document requirements (type and status from payout_verification_requirements, if any present for this payout).\",\n        \"6. Cross-validate information in the answer with values in the database (status, flags, requirements must match EXACTLY).\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    import json\\n    \\n    # Helper for DB queries (read-only)\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # Step 1: Find campaign id for 'Help Mayas Recovery'\\n    campaign_row = safe_query(final_db_path, \\\"SELECT id FROM campaigns WHERE title = ?\\\", (\\\"Help Mayas Recovery\\\",))\\n    if not campaign_row or not isinstance(campaign_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    campaign_id = campaign_row[0][0]\\n    \\n    # Step 2: Get owner_user_id for cross-validation later (optional, but robust)\\n    owner_row = safe_query(final_db_path, \\\"SELECT owner_user_id FROM campaigns WHERE id = ?\\\", (campaign_id,))\\n    if not owner_row or not isinstance(owner_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    owner_user_id = owner_row[0][0]\\n    \\n    # Step 3: Find default payout method for this campaign (from campaign_payout_settings)\\n    payout_settings_row = safe_query(final_db_path, \\\"SELECT default_payout_method_id FROM campaign_payout_settings WHERE campaign_id = ?\\\", (campaign_id,))\\n    if not payout_settings_row or not isinstance(payout_settings_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    default_payout_method_id = payout_settings_row[0][0]\\n    \\n    # Step 4: Identify the NEW payout: get set of payouts for campaign in initial and final DB, then diff them\\n    payout_fields = \\\"id, campaign_id, payout_method_id, amount_cents, currency_code, status, risk_level, risk_flags_json, verification_required\\\"\\n    initial_payouts = safe_query(initial_db_path, f\\\"SELECT {payout_fields} FROM payouts WHERE campaign_id = ?\\\", (campaign_id,))\\n    final_payouts = safe_query(final_db_path, f\\\"SELECT {payout_fields} FROM payouts WHERE campaign_id = ?\\\", (campaign_id,))\\n    # Build sets for comparison: use all fields except id and created timestamps\\n    def payout_key(row):\\n        # row: id:0, campaign_id:1, payout_method_id:2, amount_cents:3, currency_code:4, status:5, risk_level:6, risk_flags_json:7, verification_required:8\\n        return (\\n            row[1],row[2],row[3],row[4]\\n        ) # campaign_id, payout_method_id, amount_cents, currency_code\\n    initial_keys = set([payout_key(r) for r in initial_payouts])\\n    # Find new rows in final which are not in initial, and have expected attributes\\n    candidate_payouts = []\\n    for row in final_payouts:\\n        # Must match campaign, method, amount, currency\\n        if (row[1] == campaign_id and row[2] == default_payout_method_id and row[3] == 250000 and row[4] == 'USD'):\\n            if payout_key(row) not in initial_keys:\\n                candidate_payouts.append(row)\\n    if not candidate_payouts:\\n        # Not found, return others\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if len(candidate_payouts) > 1:\\n        return {\\\"result\\\": \\\"others\\\"} # Only 1 expected, more would be ambiguous\\n    payout_row = candidate_payouts[0]\\n    payout_id = payout_row[0]\\n    payout_status = payout_row[5] if isinstance(payout_row[5], str) else \\\"\\\"\\n    risk_level = payout_row[6] if isinstance(payout_row[6], str) else \\\"\\\"\\n    risk_flags_json = payout_row[7] if isinstance(payout_row[7], str) else \\\"\\\"\\n    verification_required = (payout_row[8]==1)\\n\\n    # Step 5: Read risk flags from JSON if present\\n    risk_flags = []\\n    if risk_flags_json:\\n        try:\\n            risk_obj = json.loads(risk_flags_json)\\n            if isinstance(risk_obj, dict) and 'flags' in risk_obj:\\n                flags = risk_obj['flags']\\n                if isinstance(flags, list):\\n                    risk_flags = [str(f) for f in flags]\\n        except Exception:\\n            risk_flags = [] # If parsing fails, treat as absent\\n    # Step 6: Read payout_verification_requirements for this payout, if any\\n    req_rows = safe_query(final_db_path,\\n        \\\"SELECT requirement_type, status FROM payout_verification_requirements WHERE payout_id = ?\\\", (payout_id,))\\n    requirements = [(r[0], r[1]) for r in req_rows if isinstance(r[0], str) and isinstance(r[1], str)]\\n\\n    # Step 7: Now check the agent's provided answer\\n    if not final_answer or not isinstance(final_answer, str) or len(final_answer) < 4:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    ans = final_answer\\n\\n    # a) The answer must mention payout status and should match DB\\n    # It may be phrased like \\\"status: pending\\\", \\\"status is 'on_hold'\\\", etc.\\n    status_patterns = [\\n        rf\\\"status[\\\\s:]+['\\\\\\\"]?{re.escape(payout_status)}['\\\\\\\"]?\\\", # status: on_hold\\n        rf\\\"payout .*status.*{re.escape(payout_status)}\\\",\\n        rf\\\"status.*is.*{re.escape(payout_status)}\\\"\\n    ]\\n    if not any(re.search(pat, ans, re.IGNORECASE) for pat in status_patterns):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # b) The answer must mention risk/fraud flags and risk level\\n    # Accept either explicit listing, e.g.:\\n    #  - 'risk flags: [flag1, flag2]' or\\n    #  - 'risk level: medium'\\n    risk_mentioned = False\\n    # Pattern for risk level\\n    risk_lvl_pat = rf\\\"risk level[\\\\s:]+['\\\\\\\"]?{re.escape(risk_level)}['\\\\\\\"]?\\\"\\n    if risk_level and re.search(risk_lvl_pat, ans, re.IGNORECASE):\\n        risk_mentioned = True\\n    # Pattern for listing all present flags\\n    if risk_flags:\\n        for flag in risk_flags:\\n            # Pattern: flag name should appear in the answer near the words \\\"risk\\\" or \\\"flag\\\"\\n            flag_pat = rf\\\"(risk|flag)[\\\\w\\\\s,:;'-]*{re.escape(flag)}\\\"\\n            if not re.search(flag_pat, ans, re.IGNORECASE):\\n                risk_mentioned = False\\n                break\\n        else:\\n            # All flags mentioned at least once\\n            risk_mentioned = True\\n    elif not risk_flags:\\n        # Should state risk is none (if so in db)\\n        none_pat = r\\\"risk (flags|level)[\\\\w\\\\s,:;'-]*(none|no|absent|not detected)\\\"\\n        if risk_level.lower() == 'none' and re.search(none_pat, ans, re.IGNORECASE):\\n            risk_mentioned = True\\n    if not risk_mentioned:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # c) The answer must mention document requirements (if present):\\n    requirements_matched = True\\n    if requirements:\\n        for req_type, req_status in requirements:\\n            # Example: identity_document required, bank_account_ownership required\\n            type_pat = re.escape(req_type.replace('_',' '))\\n            status_pat = re.escape(req_status)\\n            # Accept e.g. 'identity document required', 'bank account ownership: required', etc.\\n            # Some answers may phrase as 'Requirement: identity_document, status: required'\\n            if not (re.search(rf\\\"{type_pat}[\\\\w\\\\s,:;'\\\\-]*{status_pat}\\\", ans, re.IGNORECASE) or\\n                    re.search(rf\\\"{status_pat}[\\\\w\\\\s,:;'\\\\-]*{type_pat}\\\", ans, re.IGNORECASE)):\\n                requirements_matched = False\\n                break\\n    else:\\n        # No requirements present: answer should mention none/waived\\n        no_req_pat = r\\\"(no|none|not required|waived)[\\\\w\\\\s,:;'\\\\-]*(verification|requirement|document)\\\"\\n        if not re.search(no_req_pat, ans, re.IGNORECASE):\\n            # If DB says none needed, answer must say so\\n            requirements_matched = False\\n    if not requirements_matched:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # If all checks passed:\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 0, "task": "Create a manual delivery order for merchant \"Bluebird Bakery\" at location \"Bluebird Bakery - Downtown\" with pickup address \"1200 Market St, San Francisco, CA 94102\" and dropoff address \"455 Castro St, San Francisco, CA 94114\", delivery window today 2:003:00 PM, items [\"Sourdough loaf\" x2, \"Croissant\" x6], and special instructions \"Call on arrival; leave at front desk if no answer\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import datetime\n\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Helper: get merchant id by name\n    def get_merchant_id(db_path, name):\n        rows = safe_query(db_path, \"SELECT id FROM merchants WHERE name = ?\", (name,))\n        return rows[0][0] if rows else None\n\n    # Helper: get merchant_location id by merchant id and location name\n    def get_merchant_location_id(db_path, merchant_id, name):\n        rows = safe_query(db_path, \"SELECT id FROM merchant_locations WHERE merchant_id = ? AND name = ?\", (merchant_id, name))\n        return rows[0][0] if rows else None\n\n    # Helper: get address id by formatted string\n    def get_address_id(db_path, formatted):\n        rows = safe_query(db_path, \"SELECT id FROM addresses WHERE formatted = ?\", (formatted,))\n        return rows[0][0] if rows else None\n\n    # Helper: get all relevant delivery orders in a DB\n    def get_candidate_orders(db_path):\n        merchant_id = get_merchant_id(db_path, \"Bluebird Bakery\")\n        if merchant_id is None:\n            return []\n        merchant_location_id = get_merchant_location_id(db_path, merchant_id, \"Bluebird Bakery - Downtown\")\n        if merchant_location_id is None:\n            return []\n        pickup_addr_id = get_address_id(db_path, \"1200 Market St, San Francisco, CA 94102\")\n        dropoff_addr_id = get_address_id(db_path, \"455 Castro St, San Francisco, CA 94114\")\n        if pickup_addr_id is None or dropoff_addr_id is None:\n            return []\n        # Accept orders with the expected merchant, location, pickup && dropoff addresses\n        orders = safe_query(db_path, \n            \"\"\"\n            SELECT id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions\n            FROM delivery_orders\n            WHERE merchant_id = ?\n                AND merchant_location_id = ?\n                AND pickup_address_id = ?\n                AND dropoff_address_id = ?\n            \"\"\", (merchant_id, merchant_location_id, pickup_addr_id, dropoff_addr_id)\n        )\n        return orders\n\n    # Helper: filter orders by window (today 2:00-3:00pm, any calendar date, but both windows must match hour range)\n    def filter_orders_by_window(orders):\n        def window_ok(pickup_start, pickup_end, dropoff_start, dropoff_end):\n            # All times are ISO format: YYYY-MM-DD HH:MM:SS\n            # Every window must be on the same calendar date ('today'); at least must check that the times fit 14:00-15:00\n            try:\n                # Parse all datetimes\n                ps = datetime.datetime.strptime(pickup_start, \"%Y-%m-%d %H:%M:%S\") if pickup_start else None\n                pe = datetime.datetime.strptime(pickup_end, \"%Y-%m-%d %H:%M:%S\") if pickup_end else None\n                ds = datetime.datetime.strptime(dropoff_start, \"%Y-%m-%d %H:%M:%S\") if dropoff_start else None\n                de = datetime.datetime.strptime(dropoff_end, \"%Y-%m-%d %H:%M:%S\") if dropoff_end else None\n                # Must have a window that covers 14:00-15:00\n                # Allow small flex for rounding (eg. 14:00:00, 14:30:00, 15:00:00 acceptable on boundaries)\n                window_start = datetime.time(14,0,0)\n                window_end = datetime.time(15,0,0)\n                # At least dropoff window must cover the required range\n                # We accept if dropoff_window_start >= 14:00 and dropoff_window_end <= 15:00 and window >= 30min\n                cond = (\n                    ds is not None and de is not None and\n                    ds.time() >= window_start and de.time() <= window_end and\n                    (de - ds).total_seconds() >= 1800\n                )\n                # Also check pickup window must start >= 14:00 and end <= 15:00, or overlap required\n                cond2 = (\n                    ps is not None and pe is not None and\n                    ps.time() >= window_start and pe.time() <= window_end and\n                    (pe - ps).total_seconds() >= 0 # Allow for pickup to precede dropoff\n                )\n                # We accept (either dropoff OR pickup window) as valid, but would prefer both fit\n                return cond or cond2\n            except Exception:\n                return False\n        # Orders: (id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, ...)\n        return [o for o in orders if window_ok(o[1], o[2], o[3], o[4])]\n\n    # Helper: check order items for exact match\n    def order_items_match(db_path, order_id):\n        items = safe_query(db_path, \"SELECT name, quantity FROM delivery_order_items WHERE order_id = ? ORDER BY name\", (order_id,))\n        expected = sorted([(\"Sourdough loaf\",2), (\"Croissant\",6)])\n        return sorted(items) == expected\n\n    # Helper: check instructions match exactly\n    def instructions_match(instr):\n        return (instr is not None and instr.strip() == \"Call on arrival; leave at front desk if no answer\")\n\n    # --- Load initial and final candidate orders ---\n    initial_orders = get_candidate_orders(initial_db_path)\n    final_orders = get_candidate_orders(final_db_path)\n    # Only orders matching location, addresses, etc, are examined (list of rows: id, windows, instr)\n\n    # Find candidate(s) in final DB that were NOT present in initial DB (by tuple of key fields)\n    # We use (pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions) to compare\n    initial_keys = set()\n    for r in initial_orders:\n        key = tuple(r[1:])\n        initial_keys.add(key)\n    # Candidates are those in final not present in initial\n    new_candidates = []\n    for r in final_orders:\n        key = tuple(r[1:])\n        if key not in initial_keys:\n            new_candidates.append(r)\n\n    # There must be EXACTLY one matching new order\n    if len(new_candidates) != 1:\n        return {\"result\": \"others\"}\n    cand = new_candidates[0]\n    order_id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions = cand\n\n    # Check item list match\n    if not order_items_match(final_db_path, order_id):\n        return {\"result\": \"others\"}\n    # Check special instructions exact match\n    if not instructions_match(special_instructions):\n        return {\"result\": \"others\"}\n    # Check window range\n    if not filter_orders_by_window([cand]):\n        return {\"result\": \"others\"}\n    # Optionally, check for 'manual' creation; in this schema, status_created or internal_notes may be evidence\n    # Accept as manual if there is an order_status_events row for this id with status 'created' and notes containing 'Manual order' (case-insensitive)\n    events = safe_query(final_db_path, \"SELECT notes FROM order_status_events WHERE order_id = ? AND status = 'created'\", (order_id,))\n    manual = False\n    for ev in events:\n        if ev[0] and \"manual order\" in ev[0].lower():\n            manual = True\n            break\n    if not manual:\n        # Fallback: check for internal_note for this order about manual entry\n        notes = safe_query(final_db_path, \"SELECT note FROM internal_notes WHERE entity_type = 'order' AND entity_id = ?\", (order_id,))\n        for n in notes:\n            if n[0] and \"manual order\" in n[0].lower():\n                manual = True\n                break\n    if not manual:\n        # If we cannot decisively verify manual creation, we must return \"others\"\n        return {\"result\": \"others\"}\n    # All checks passed\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must confirm that a new manual delivery order was created for the merchant 'Bluebird Bakery' at the 'Bluebird Bakery - Downtown' location, with the pickup address '1200 Market St, San Francisco, CA 94102' and dropoff address '455 Castro St, San Francisco, CA 94114'. The order must have a delivery window today from 2:00 to 3:00 PM, include the items ['Sourdough loaf' x2, 'Croissant' x6], and contain the special instructions 'Call on arrival; leave at front desk if no answer'. Since it is a creation/modification task, only the final database state matters, not the final_answer. The function must check that: (1) such an order did not exist already in the initial DB, and (2) it was created correctly in the final DB with exactly the right details across all relevant tables. If there is ambiguity or missing data, the function must return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Check that a new delivery order was created in the final DB but not present in the initial DB\",\n        \"Verify the merchant is 'Bluebird Bakery' and merchant_location is 'Bluebird Bakery - Downtown'\",\n        \"Check that the pickup and dropoff address IDs point to the correct addresses ('1200 Market St, San Francisco, CA 94102' and '455 Castro St, San Francisco, CA 94114')\",\n        \"Verify the pickup or dropoff window is strictly today 2:003:00 PM (on any valid 'today' date)\",\n        \"Verify delivery_order_items for this order are exactly ['Sourdough loaf', 2] and ['Croissant', 6]\",\n        \"Verify the special_instructions field matches exactly 'Call on arrival; leave at front desk if no answer'\",\n        \"Ensure the delivery was created manually (e.g., has relevant status events or creation note if needed)\",\n        \"Return 'others' if there are any ambiguities, mismatches, or multiple possible matching orders\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import datetime\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Helper: get merchant id by name\\n    def get_merchant_id(db_path, name):\\n        rows = safe_query(db_path, \\\"SELECT id FROM merchants WHERE name = ?\\\", (name,))\\n        return rows[0][0] if rows else None\\n\\n    # Helper: get merchant_location id by merchant id and location name\\n    def get_merchant_location_id(db_path, merchant_id, name):\\n        rows = safe_query(db_path, \\\"SELECT id FROM merchant_locations WHERE merchant_id = ? AND name = ?\\\", (merchant_id, name))\\n        return rows[0][0] if rows else None\\n\\n    # Helper: get address id by formatted string\\n    def get_address_id(db_path, formatted):\\n        rows = safe_query(db_path, \\\"SELECT id FROM addresses WHERE formatted = ?\\\", (formatted,))\\n        return rows[0][0] if rows else None\\n\\n    # Helper: get all relevant delivery orders in a DB\\n    def get_candidate_orders(db_path):\\n        merchant_id = get_merchant_id(db_path, \\\"Bluebird Bakery\\\")\\n        if merchant_id is None:\\n            return []\\n        merchant_location_id = get_merchant_location_id(db_path, merchant_id, \\\"Bluebird Bakery - Downtown\\\")\\n        if merchant_location_id is None:\\n            return []\\n        pickup_addr_id = get_address_id(db_path, \\\"1200 Market St, San Francisco, CA 94102\\\")\\n        dropoff_addr_id = get_address_id(db_path, \\\"455 Castro St, San Francisco, CA 94114\\\")\\n        if pickup_addr_id is None or dropoff_addr_id is None:\\n            return []\\n        # Accept orders with the expected merchant, location, pickup && dropoff addresses\\n        orders = safe_query(db_path, \\n            \\\"\\\"\\\"\\n            SELECT id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions\\n            FROM delivery_orders\\n            WHERE merchant_id = ?\\n                AND merchant_location_id = ?\\n                AND pickup_address_id = ?\\n                AND dropoff_address_id = ?\\n            \\\"\\\"\\\", (merchant_id, merchant_location_id, pickup_addr_id, dropoff_addr_id)\\n        )\\n        return orders\\n\\n    # Helper: filter orders by window (today 2:00-3:00pm, any calendar date, but both windows must match hour range)\\n    def filter_orders_by_window(orders):\\n        def window_ok(pickup_start, pickup_end, dropoff_start, dropoff_end):\\n            # All times are ISO format: YYYY-MM-DD HH:MM:SS\\n            # Every window must be on the same calendar date ('today'); at least must check that the times fit 14:00-15:00\\n            try:\\n                # Parse all datetimes\\n                ps = datetime.datetime.strptime(pickup_start, \\\"%Y-%m-%d %H:%M:%S\\\") if pickup_start else None\\n                pe = datetime.datetime.strptime(pickup_end, \\\"%Y-%m-%d %H:%M:%S\\\") if pickup_end else None\\n                ds = datetime.datetime.strptime(dropoff_start, \\\"%Y-%m-%d %H:%M:%S\\\") if dropoff_start else None\\n                de = datetime.datetime.strptime(dropoff_end, \\\"%Y-%m-%d %H:%M:%S\\\") if dropoff_end else None\\n                # Must have a window that covers 14:00-15:00\\n                # Allow small flex for rounding (eg. 14:00:00, 14:30:00, 15:00:00 acceptable on boundaries)\\n                window_start = datetime.time(14,0,0)\\n                window_end = datetime.time(15,0,0)\\n                # At least dropoff window must cover the required range\\n                # We accept if dropoff_window_start >= 14:00 and dropoff_window_end <= 15:00 and window >= 30min\\n                cond = (\\n                    ds is not None and de is not None and\\n                    ds.time() >= window_start and de.time() <= window_end and\\n                    (de - ds).total_seconds() >= 1800\\n                )\\n                # Also check pickup window must start >= 14:00 and end <= 15:00, or overlap required\\n                cond2 = (\\n                    ps is not None and pe is not None and\\n                    ps.time() >= window_start and pe.time() <= window_end and\\n                    (pe - ps).total_seconds() >= 0 # Allow for pickup to precede dropoff\\n                )\\n                # We accept (either dropoff OR pickup window) as valid, but would prefer both fit\\n                return cond or cond2\\n            except Exception:\\n                return False\\n        # Orders: (id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, ...)\\n        return [o for o in orders if window_ok(o[1], o[2], o[3], o[4])]\\n\\n    # Helper: check order items for exact match\\n    def order_items_match(db_path, order_id):\\n        items = safe_query(db_path, \\\"SELECT name, quantity FROM delivery_order_items WHERE order_id = ? ORDER BY name\\\", (order_id,))\\n        expected = sorted([(\\\"Sourdough loaf\\\",2), (\\\"Croissant\\\",6)])\\n        return sorted(items) == expected\\n\\n    # Helper: check instructions match exactly\\n    def instructions_match(instr):\\n        return (instr is not None and instr.strip() == \\\"Call on arrival; leave at front desk if no answer\\\")\\n\\n    # --- Load initial and final candidate orders ---\\n    initial_orders = get_candidate_orders(initial_db_path)\\n    final_orders = get_candidate_orders(final_db_path)\\n    # Only orders matching location, addresses, etc, are examined (list of rows: id, windows, instr)\\n\\n    # Find candidate(s) in final DB that were NOT present in initial DB (by tuple of key fields)\\n    # We use (pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions) to compare\\n    initial_keys = set()\\n    for r in initial_orders:\\n        key = tuple(r[1:])\\n        initial_keys.add(key)\\n    # Candidates are those in final not present in initial\\n    new_candidates = []\\n    for r in final_orders:\\n        key = tuple(r[1:])\\n        if key not in initial_keys:\\n            new_candidates.append(r)\\n\\n    # There must be EXACTLY one matching new order\\n    if len(new_candidates) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    cand = new_candidates[0]\\n    order_id, pickup_window_start, pickup_window_end, dropoff_window_start, dropoff_window_end, special_instructions = cand\\n\\n    # Check item list match\\n    if not order_items_match(final_db_path, order_id):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check special instructions exact match\\n    if not instructions_match(special_instructions):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check window range\\n    if not filter_orders_by_window([cand]):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Optionally, check for 'manual' creation; in this schema, status_created or internal_notes may be evidence\\n    # Accept as manual if there is an order_status_events row for this id with status 'created' and notes containing 'Manual order' (case-insensitive)\\n    events = safe_query(final_db_path, \\\"SELECT notes FROM order_status_events WHERE order_id = ? AND status = 'created'\\\", (order_id,))\\n    manual = False\\n    for ev in events:\\n        if ev[0] and \\\"manual order\\\" in ev[0].lower():\\n            manual = True\\n            break\\n    if not manual:\\n        # Fallback: check for internal_note for this order about manual entry\\n        notes = safe_query(final_db_path, \\\"SELECT note FROM internal_notes WHERE entity_type = 'order' AND entity_id = ?\\\", (order_id,))\\n        for n in notes:\\n            if n[0] and \\\"manual order\\\" in n[0].lower():\\n                manual = True\\n                break\\n    if not manual:\\n        # If we cannot decisively verify manual creation, we must return \\\"others\\\"\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 1, "task": "List all delivery orders for merchant \"Bluebird Bakery\" created in the last 24 hours and return each orders id, customer name, current status, and latest ETA.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Helper function to parse date string\n    def parse_datetime(dt_str):\n        try:\n            return datetime.strptime(dt_str, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            return None\n\n    # If answer is missing or empty, cannot verify\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n\n    # Step 1: Find merchant id for 'Bluebird Bakery'\n    merchant_rows = safe_query(final_db_path, \"SELECT id FROM merchants WHERE name = ?\", (\"Bluebird Bakery\",))\n    if not merchant_rows or len(merchant_rows[0]) == 0:\n        return {\"result\": \"others\"}\n    merchant_id = merchant_rows[0][0]\n\n    # Step 2: Use DB time baseline for 'now'; pick latest timestamp in DB for consistency\n    time_rows = safe_query(final_db_path, \"SELECT MAX(created_at) FROM delivery_orders\")\n    db_now = None\n    if time_rows and len(time_rows[0]) > 0 and time_rows[0][0]:\n        db_now = parse_datetime(time_rows[0][0])\n    if not db_now:\n        # fallback to system time\n        db_now = datetime.now()\n    last_24hr_baseline = db_now - timedelta(hours=24)\n\n    # Step 3: Find all relevant orders from DB\n    order_rows = safe_query(\n        final_db_path,\n        \"SELECT id, customer_id, current_status, latest_eta, created_at FROM delivery_orders WHERE merchant_id = ?\",\n        (merchant_id,)\n    )\n    orders_24hr = []\n    for row in order_rows:\n        oid, cust_id, status, eta, created_at = row\n        created_dt = parse_datetime(created_at)\n        if not created_dt:\n            continue\n        if created_dt >= last_24hr_baseline - timedelta(seconds=1):\n            orders_24hr.append((oid, cust_id, status, eta))\n    if not orders_24hr:\n        # If no orders, allow only if answer is truly empty or says none exists.\n        if re.search(r'(no\\s+orders|none|zero|empty)', final_answer, re.IGNORECASE):\n            return {\"result\": \"complete\"}\n        return {\"result\": \"others\"}\n\n    # Step 4: For each order, get customer name\n    # Compose expected set of entries\n    expected_orders = []\n    for oid, cust_id, status, eta in orders_24hr:\n        cust_name_rows = safe_query(final_db_path, \"SELECT full_name FROM customers WHERE id = ?\", (cust_id,))\n        cust_name = cust_name_rows[0][0] if cust_name_rows and cust_name_rows[0] else ''\n        # eta may be None; check for string\n        latest_eta = eta if eta else ''\n        expected_orders.append({\n            \"id\": str(oid),\n            \"customer\": cust_name,\n            \"status\": status,\n            \"eta\": latest_eta\n        })\n    # Step 5: Extract orders from answer using regex\n    # Accept list/table formats\n    # ID, customer name, status, ETA fields\n    # Common patterns:\n    # 1. ID: number, Customer: name, Status: status, ETA: datetime\n    # 2. Tables with columns (ID, Customer, Status, ETA)\n    # Try to extract all unique sets matching these fields\n    # Try general pattern: ID (number), customer name (text), status (text from DB), latest ETA (datetime)\n    # Accept either 'eta' or 'latest eta' as field\n    # Compose status values as alternates\n    status_set = set(order['status'] for order in expected_orders)\n    status_regex = '|'.join(re.escape(s) for s in status_set)\n    # Compose datetime regex\n    datetime_regex = r'\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'\n    # Pattern: ID, customer, status, ETA as table rows or as blocks\n    order_pattern = re.compile(\n        rf'(\\bID\\b\\s*[:=]?\\s*(\\d+)[^\\n]*?(Customer\\s*[:=]?\\s*([^\\n]+?))?[^\\n]*?(Status\\s*[:=]?\\s*({status_regex}))[^\\n]*?(ETA|Latest ETA|latest eta)?[^\\d]*(?:({datetime_regex}))?)',\n        re.IGNORECASE\n    )\n    # Also look for rows in table form\n    table_pattern = re.compile(\n        rf'(\\d+)\\s*[,|\\t]\\s*([^,|\\t]+)\\s*[,|\\t]\\s*({status_regex})\\s*[,|\\t]\\s*({datetime_regex})',\n        re.IGNORECASE\n    )\n    found_orders = set()\n    extracted_orders = []\n    # Try to extract table-rows\n    for m in table_pattern.finditer(final_answer):\n        oid, cust_name, status, eta = m.group(1), m.group(2).strip(), m.group(3), m.group(4)\n        extracted_orders.append({\n            \"id\": oid,\n            \"customer\": cust_name,\n            \"status\": status,\n            \"eta\": eta\n        })\n        found_orders.add(oid)\n    # Try to extract block-form answers\n    for m in order_pattern.finditer(final_answer):\n        oid = m.group(2)\n        cust_name = m.group(4).strip() if m.group(4) else ''\n        status = m.group(6)\n        eta = m.group(8) if m.group(8) else ''\n        extracted_orders.append({\n            \"id\": oid,\n            \"customer\": cust_name,\n            \"status\": status,\n            \"eta\": eta\n        })\n        found_orders.add(oid)\n    # Defensive: Remove dupes (prefer one per order id)\n    final_extracted = {}\n    for od in extracted_orders:\n        if od[\"id\"] not in final_extracted:\n            final_extracted[od[\"id\"]] = od\n    extracted_orders = list(final_extracted.values())\n    # Step 6: Check if extracted_orders matches expected_orders (exactly)\n    # Only allow complete if all expected orders are present with full fields and match\n    expected_by_id = {od[\"id\"]: od for od in expected_orders}\n    matched_ids = set()\n    for od in extracted_orders:\n        if od[\"id\"] in expected_by_id:\n            exp = expected_by_id[od[\"id\"]]\n            # Flexible whitespace for names\n            name_match = od[\"customer\"].strip() == exp[\"customer\"].strip() if exp[\"customer\"] else True\n            # Flexible: if eta is empty accept only if DB eta is empty\n            eta_match = (od[\"eta\"] == exp[\"eta\"])\n            # Status exact match\n            status_match = (od[\"status\"] == exp[\"status\"])\n            if name_match and status_match and eta_match:\n                matched_ids.add(od[\"id\"])\n    # Only allow complete if\n    # - All expected order ids are in the answer with correct fields\n    # - The answer contains ONLY these order ids, nothing else\n    exp_ids = set(expected_by_id.keys())\n    found_ids = set(final_extracted.keys())\n    # Defensive: accept if the answer contains exactly the correct order ids, no extras, and all fields for each\n    if matched_ids == exp_ids and found_ids == exp_ids:\n        # Extra check: ensure that for each expected order, their customer names/states/eta are not missing or malformed\n        for eid in exp_ids:\n            od = final_extracted[eid]\n            expod = expected_by_id[eid]\n            if not od[\"id\"] or not od[\"status\"]:\n                return {\"result\": \"others\"}\n            # Customer name and eta may be empty, but only if DB is like that\n            if expod[\"customer\"] and od[\"customer\"].strip() != expod[\"customer\"].strip():\n                return {\"result\": \"others\"}\n            if expod[\"eta\"] != od[\"eta\"]:\n                return {\"result\": \"others\"}\n            if od[\"status\"] != expod[\"status\"]:\n                return {\"result\": \"others\"}\n        return {\"result\": \"complete\"}\n    return {\"result\": \"others\"}", "raw_response": "{\n    \"reasoning\": \"The task is to list all delivery orders for merchant 'Bluebird Bakery' created in the last 24 hours, and for each order, return its id, customer name, current status, and latest ETA. To verify completion, the answer must include all such orders and their requested fields, corresponding exactly to what is in the database. We must validate, for the final_answer: (1) all relevant orders are present, (2) the fields are extracted and matched to database values, (3) the format requested is followed and nothing is missing, (4) answer does not contain extraneous or unrelated orders or data. The database itself should not change for query-only tasks, so only the final_answer is used for verification.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Extract order entries from final_answer (id, customer name, current status, latest ETA)\",\n        \"Fetch all delivery orders for merchant 'Bluebird Bakery' created in last 24 hours from final_db\",\n        \"For each relevant order, validate that its id, customer name, current status, latest ETA appear in final_answer and exactly match the database\",\n        \"Ensure no extraneous orders are listed in final_answer\",\n        \"Handle missing/None final_answer and malformed responses gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Helper function to parse date string\\n    def parse_datetime(dt_str):\\n        try:\\n            return datetime.strptime(dt_str, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        except Exception:\\n            return None\\n\\n    # If answer is missing or empty, cannot verify\\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 1: Find merchant id for 'Bluebird Bakery'\\n    merchant_rows = safe_query(final_db_path, \\\"SELECT id FROM merchants WHERE name = ?\\\", (\\\"Bluebird Bakery\\\",))\\n    if not merchant_rows or len(merchant_rows[0]) == 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    merchant_id = merchant_rows[0][0]\\n\\n    # Step 2: Use DB time baseline for 'now'; pick latest timestamp in DB for consistency\\n    time_rows = safe_query(final_db_path, \\\"SELECT MAX(created_at) FROM delivery_orders\\\")\\n    db_now = None\\n    if time_rows and len(time_rows[0]) > 0 and time_rows[0][0]:\\n        db_now = parse_datetime(time_rows[0][0])\\n    if not db_now:\\n        # fallback to system time\\n        db_now = datetime.now()\\n    last_24hr_baseline = db_now - timedelta(hours=24)\\n\\n    # Step 3: Find all relevant orders from DB\\n    order_rows = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, customer_id, current_status, latest_eta, created_at FROM delivery_orders WHERE merchant_id = ?\\\",\\n        (merchant_id,)\\n    )\\n    orders_24hr = []\\n    for row in order_rows:\\n        oid, cust_id, status, eta, created_at = row\\n        created_dt = parse_datetime(created_at)\\n        if not created_dt:\\n            continue\\n        if created_dt >= last_24hr_baseline - timedelta(seconds=1):\\n            orders_24hr.append((oid, cust_id, status, eta))\\n    if not orders_24hr:\\n        # If no orders, allow only if answer is truly empty or says none exists.\\n        if re.search(r'(no\\\\s+orders|none|zero|empty)', final_answer, re.IGNORECASE):\\n            return {\\\"result\\\": \\\"complete\\\"}\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: For each order, get customer name\\n    # Compose expected set of entries\\n    expected_orders = []\\n    for oid, cust_id, status, eta in orders_24hr:\\n        cust_name_rows = safe_query(final_db_path, \\\"SELECT full_name FROM customers WHERE id = ?\\\", (cust_id,))\\n        cust_name = cust_name_rows[0][0] if cust_name_rows and cust_name_rows[0] else ''\\n        # eta may be None; check for string\\n        latest_eta = eta if eta else ''\\n        expected_orders.append({\\n            \\\"id\\\": str(oid),\\n            \\\"customer\\\": cust_name,\\n            \\\"status\\\": status,\\n            \\\"eta\\\": latest_eta\\n        })\\n    # Step 5: Extract orders from answer using regex\\n    # Accept list/table formats\\n    # ID, customer name, status, ETA fields\\n    # Common patterns:\\n    # 1. ID: number, Customer: name, Status: status, ETA: datetime\\n    # 2. Tables with columns (ID, Customer, Status, ETA)\\n    # Try to extract all unique sets matching these fields\\n    # Try general pattern: ID (number), customer name (text), status (text from DB), latest ETA (datetime)\\n    # Accept either 'eta' or 'latest eta' as field\\n    # Compose status values as alternates\\n    status_set = set(order['status'] for order in expected_orders)\\n    status_regex = '|'.join(re.escape(s) for s in status_set)\\n    # Compose datetime regex\\n    datetime_regex = r'\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}'\\n    # Pattern: ID, customer, status, ETA as table rows or as blocks\\n    order_pattern = re.compile(\\n        rf'(\\\\bID\\\\b\\\\s*[:=]?\\\\s*(\\\\d+)[^\\\\n]*?(Customer\\\\s*[:=]?\\\\s*([^\\\\n]+?))?[^\\\\n]*?(Status\\\\s*[:=]?\\\\s*({status_regex}))[^\\\\n]*?(ETA|Latest ETA|latest eta)?[^\\\\d]*(?:({datetime_regex}))?)',\\n        re.IGNORECASE\\n    )\\n    # Also look for rows in table form\\n    table_pattern = re.compile(\\n        rf'(\\\\d+)\\\\s*[,|\\\\t]\\\\s*([^,|\\\\t]+)\\\\s*[,|\\\\t]\\\\s*({status_regex})\\\\s*[,|\\\\t]\\\\s*({datetime_regex})',\\n        re.IGNORECASE\\n    )\\n    found_orders = set()\\n    extracted_orders = []\\n    # Try to extract table-rows\\n    for m in table_pattern.finditer(final_answer):\\n        oid, cust_name, status, eta = m.group(1), m.group(2).strip(), m.group(3), m.group(4)\\n        extracted_orders.append({\\n            \\\"id\\\": oid,\\n            \\\"customer\\\": cust_name,\\n            \\\"status\\\": status,\\n            \\\"eta\\\": eta\\n        })\\n        found_orders.add(oid)\\n    # Try to extract block-form answers\\n    for m in order_pattern.finditer(final_answer):\\n        oid = m.group(2)\\n        cust_name = m.group(4).strip() if m.group(4) else ''\\n        status = m.group(6)\\n        eta = m.group(8) if m.group(8) else ''\\n        extracted_orders.append({\\n            \\\"id\\\": oid,\\n            \\\"customer\\\": cust_name,\\n            \\\"status\\\": status,\\n            \\\"eta\\\": eta\\n        })\\n        found_orders.add(oid)\\n    # Defensive: Remove dupes (prefer one per order id)\\n    final_extracted = {}\\n    for od in extracted_orders:\\n        if od[\\\"id\\\"] not in final_extracted:\\n            final_extracted[od[\\\"id\\\"]] = od\\n    extracted_orders = list(final_extracted.values())\\n    # Step 6: Check if extracted_orders matches expected_orders (exactly)\\n    # Only allow complete if all expected orders are present with full fields and match\\n    expected_by_id = {od[\\\"id\\\"]: od for od in expected_orders}\\n    matched_ids = set()\\n    for od in extracted_orders:\\n        if od[\\\"id\\\"] in expected_by_id:\\n            exp = expected_by_id[od[\\\"id\\\"]]\\n            # Flexible whitespace for names\\n            name_match = od[\\\"customer\\\"].strip() == exp[\\\"customer\\\"].strip() if exp[\\\"customer\\\"] else True\\n            # Flexible: if eta is empty accept only if DB eta is empty\\n            eta_match = (od[\\\"eta\\\"] == exp[\\\"eta\\\"])\\n            # Status exact match\\n            status_match = (od[\\\"status\\\"] == exp[\\\"status\\\"])\\n            if name_match and status_match and eta_match:\\n                matched_ids.add(od[\\\"id\\\"])\\n    # Only allow complete if\\n    # - All expected order ids are in the answer with correct fields\\n    # - The answer contains ONLY these order ids, nothing else\\n    exp_ids = set(expected_by_id.keys())\\n    found_ids = set(final_extracted.keys())\\n    # Defensive: accept if the answer contains exactly the correct order ids, no extras, and all fields for each\\n    if matched_ids == exp_ids and found_ids == exp_ids:\\n        # Extra check: ensure that for each expected order, their customer names/states/eta are not missing or malformed\\n        for eid in exp_ids:\\n            od = final_extracted[eid]\\n            expod = expected_by_id[eid]\\n            if not od[\\\"id\\\"] or not od[\\\"status\\\"]:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            # Customer name and eta may be empty, but only if DB is like that\\n            if expod[\\\"customer\\\"] and od[\\\"customer\\\"].strip() != expod[\\\"customer\\\"].strip():\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if expod[\\\"eta\\\"] != od[\\\"eta\\\"]:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if od[\\\"status\\\"] != expod[\\\"status\\\"]:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    return {\\\"result\\\": \\\"others\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 2, "task": "Batch the three earliest scheduled orders for location \"Bluebird Bakery - Downtown\" with pickup window 1:302:00 PM into a single dispatch batch and set the batch name to \"Downtown Afternoon Run\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            res = cursor.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n\n    # Helper: get merchant_location_id for 'Bluebird Bakery - Downtown'\n    locs = safe_query(final_db_path, \"SELECT id FROM merchant_locations WHERE name = ? LIMIT 1\", (\"Bluebird Bakery - Downtown\",))\n    if not locs or not locs[0] or locs[0][0] is None:\n        return {\"result\": \"others\"}\n    location_id = locs[0][0]\n\n    # Find 3 earliest 'scheduled' orders for this location with pickup window 13:30-14:00\n    orders = safe_query(final_db_path, \"\"\"\n        SELECT id, pickup_window_start, pickup_window_end\n        FROM delivery_orders\n        WHERE merchant_location_id = ?\n          AND current_status = 'scheduled'\n          AND pickup_window_start >= '2026-02-18 13:30:00'\n          AND pickup_window_end <= '2026-02-18 14:00:00'\n        ORDER BY pickup_window_start ASC, id ASC\n    \"\"\", (location_id,))\n    # Defensive: if less or more than 3 orders found, fail\n    if len(orders) != 3:\n        return {\"result\": \"others\"}\n    target_order_ids = set([row[0] for row in orders])\n\n    # Ensure batch named 'Downtown Afternoon Run' did NOT exist in initial DB\n    existing = safe_query(initial_db_path, \"SELECT id FROM dispatch_batches WHERE merchant_location_id = ? AND name = ?\", (location_id, \"Downtown Afternoon Run\"))\n    if existing:\n        return {\"result\": \"others\"}\n    # Now look for it in the final DB\n    batch_records = safe_query(final_db_path, \"SELECT id, pickup_window_start, pickup_window_end FROM dispatch_batches WHERE merchant_location_id = ? AND name = ?\", (location_id, \"Downtown Afternoon Run\"))\n    if len(batch_records) != 1:\n        return {\"result\": \"others\"}\n    batch_id, batch_start, batch_end = batch_records[0]\n    # Pickup window timing check (should include 1:302:00 PM)\n    # Accept batch pickup_window_start <= '2026-02-18 13:30:00' and batch pickup_window_end >= '2026-02-18 14:00:00', or exact\n    if not (batch_start and batch_end):\n        return {\"result\": \"others\"}\n    if batch_start > '2026-02-18 13:30:00' or batch_end < '2026-02-18 14:00:00':\n        return {\"result\": \"others\"}\n    # Get orders linked to this batch\n    batch_orders = safe_query(final_db_path, \"SELECT order_id FROM dispatch_batch_orders WHERE batch_id = ?\", (batch_id,))\n    batch_order_ids = set([row[0] for row in batch_orders])\n    # The batch must contain EXACTLY the three orders and NO others\n    if batch_order_ids != target_order_ids:\n        return {\"result\": \"others\"}\n    # Make sure these orders are NOT included together in any other batch\n    batch_ids_with_these_orders = safe_query(final_db_path, \"SELECT DISTINCT batch_id FROM dispatch_batch_orders WHERE order_id IN (?,?,?)\", tuple(target_order_ids))\n    batch_ids_with_these_orders = set(row[0] for row in batch_ids_with_these_orders)\n    # The only batch with all three should be our intended batch\n    for other_batch_id in batch_ids_with_these_orders:\n        if other_batch_id == batch_id:\n            continue\n        # For all other batches, check does it also have all three?\n        order_ids_in_other = safe_query(final_db_path, \"SELECT order_id FROM dispatch_batch_orders WHERE batch_id = ?\", (other_batch_id,))\n        if set(row[0] for row in order_ids_in_other) == target_order_ids:\n            return {\"result\": \"others\"}\n    # All checks pass\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This is a precise modification-based task. The agent must batch the three earliest scheduled orders for location 'Bluebird Bakery - Downtown' with pickup window 1:302:00 PM into a new single dispatch batch, and set its name to 'Downtown Afternoon Run'. To verify this, we must: (1) Identify which three orders this refers to (they must have pickup_window_start >= 13:30 and pickup_window_end <= 14:00 at location 'Bluebird Bakery - Downtown'); (2) Confirm in the FINAL database that these three order IDs (and ONLY them) appear in a dispatch batch named exactly 'Downtown Afternoon Run', and that this batch is newly created vs the initial state, and contains NO extra orders; (3) Ensure there is no uncertainty or ambiguity about batch naming or membership. If ALL of these are true, return 'complete'; else, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify merchant_location_id for 'Bluebird Bakery - Downtown' in both databases\",\n        \"Find the three earliest scheduled delivery_orders for that location, with pickup window exactly 1:302:00 PM\",\n        \"Verify that in the initial database, no batch named 'Downtown Afternoon Run' exists\",\n        \"Verify that in the final database, there is EXACTLY ONE dispatch_batches record named 'Downtown Afternoon Run', for this location, with correct pickup window\",\n        \"Check that this batch links to ALL AND ONLY the three correct orders via dispatch_batch_orders\",\n        \"Ensure no other batch in final_db includes all three orders together\",\n        \"Check for no extraneous orders in this batch\",\n        \"Return 'complete' ONLY if all these are true, else 'others'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            res = cursor.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n\\n    # Helper: get merchant_location_id for 'Bluebird Bakery - Downtown'\\n    locs = safe_query(final_db_path, \\\"SELECT id FROM merchant_locations WHERE name = ? LIMIT 1\\\", (\\\"Bluebird Bakery - Downtown\\\",))\\n    if not locs or not locs[0] or locs[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    location_id = locs[0][0]\\n\\n    # Find 3 earliest 'scheduled' orders for this location with pickup window 13:30-14:00\\n    orders = safe_query(final_db_path, \\\"\\\"\\\"\\n        SELECT id, pickup_window_start, pickup_window_end\\n        FROM delivery_orders\\n        WHERE merchant_location_id = ?\\n          AND current_status = 'scheduled'\\n          AND pickup_window_start >= '2026-02-18 13:30:00'\\n          AND pickup_window_end <= '2026-02-18 14:00:00'\\n        ORDER BY pickup_window_start ASC, id ASC\\n    \\\"\\\"\\\", (location_id,))\\n    # Defensive: if less or more than 3 orders found, fail\\n    if len(orders) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    target_order_ids = set([row[0] for row in orders])\\n\\n    # Ensure batch named 'Downtown Afternoon Run' did NOT exist in initial DB\\n    existing = safe_query(initial_db_path, \\\"SELECT id FROM dispatch_batches WHERE merchant_location_id = ? AND name = ?\\\", (location_id, \\\"Downtown Afternoon Run\\\"))\\n    if existing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Now look for it in the final DB\\n    batch_records = safe_query(final_db_path, \\\"SELECT id, pickup_window_start, pickup_window_end FROM dispatch_batches WHERE merchant_location_id = ? AND name = ?\\\", (location_id, \\\"Downtown Afternoon Run\\\"))\\n    if len(batch_records) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    batch_id, batch_start, batch_end = batch_records[0]\\n    # Pickup window timing check (should include 1:302:00 PM)\\n    # Accept batch pickup_window_start <= '2026-02-18 13:30:00' and batch pickup_window_end >= '2026-02-18 14:00:00', or exact\\n    if not (batch_start and batch_end):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if batch_start > '2026-02-18 13:30:00' or batch_end < '2026-02-18 14:00:00':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Get orders linked to this batch\\n    batch_orders = safe_query(final_db_path, \\\"SELECT order_id FROM dispatch_batch_orders WHERE batch_id = ?\\\", (batch_id,))\\n    batch_order_ids = set([row[0] for row in batch_orders])\\n    # The batch must contain EXACTLY the three orders and NO others\\n    if batch_order_ids != target_order_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Make sure these orders are NOT included together in any other batch\\n    batch_ids_with_these_orders = safe_query(final_db_path, \\\"SELECT DISTINCT batch_id FROM dispatch_batch_orders WHERE order_id IN (?,?,?)\\\", tuple(target_order_ids))\\n    batch_ids_with_these_orders = set(row[0] for row in batch_ids_with_these_orders)\\n    # The only batch with all three should be our intended batch\\n    for other_batch_id in batch_ids_with_these_orders:\\n        if other_batch_id == batch_id:\\n            continue\\n        # For all other batches, check does it also have all three?\\n        order_ids_in_other = safe_query(final_db_path, \\\"SELECT order_id FROM dispatch_batch_orders WHERE batch_id = ?\\\", (other_batch_id,))\\n        if set(row[0] for row in order_ids_in_other) == target_order_ids:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # All checks pass\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 3, "task": "Assign the available driver \"Dasher: Miguel R.\" to order \"BB-10482\" with pickup time 2:10 PM and add a dispatch note \"Traffic on US-101; use surface streets\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper for read-only DB queries\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Get driver_id for 'Dasher: Miguel R.'\n    driver_q = \"SELECT id FROM drivers WHERE display_name = ?\"\n    final_driver = safe_query(final_db_path, driver_q, (\"Dasher: Miguel R.\",))\n    if len(final_driver) != 1:\n        return {\"result\": \"others\"}\n    driver_id = final_driver[0][0]\n    # Sanity: check initial DB agrees\n    initial_driver = safe_query(initial_db_path, driver_q, (\"Dasher: Miguel R.\",))\n    if len(initial_driver) != 1 or initial_driver[0][0] != driver_id:\n        return {\"result\": \"others\"}\n\n    # Get order_id for 'BB-10482'\n    order_q = \"SELECT id FROM delivery_orders WHERE external_order_ref = ?\"\n    final_order = safe_query(final_db_path, order_q, (\"BB-10482\",))\n    if len(final_order) != 1:\n        return {\"result\": \"others\"}\n    order_id = final_order[0][0]\n    # Sanity: check initial DB agrees\n    initial_order = safe_query(initial_db_path, order_q, (\"BB-10482\",))\n    if len(initial_order) != 1 or initial_order[0][0] != order_id:\n        return {\"result\": \"others\"}\n\n    # Check for any current assignments for this order in FINAL DB\n    final_assignments = safe_query(\n        final_db_path,\n        \"SELECT id, driver_id, is_current, pickup_time_planned, dispatch_note, unassigned_at, unassigned_reason FROM order_assignments WHERE order_id = ? AND is_current = 1\",\n        (order_id,)\n    )\n    if len(final_assignments) != 1:\n        return {\"result\": \"others\"}\n    assign = final_assignments[0]\n    a_id, a_driver_id, a_is_current, a_pickup_time, a_note, a_unassigned_at, a_unassigned_reason = assign\n    # Must be Miguel R., current, not unassigned\n    if a_driver_id != driver_id or a_is_current != 1:\n        return {\"result\": \"others\"}\n    if a_unassigned_at is not None or a_unassigned_reason is not None:\n        return {\"result\": \"others\"}\n\n    # Pickup time must be exactly '2026-02-18 14:10:00' (2:10 PM)\n    if a_pickup_time != '2026-02-18 14:10:00':\n        return {\"result\": \"others\"}\n    # Dispatch note must match exactly\n    if (a_note or '').strip() != 'Traffic on US-101; use surface streets':\n        return {\"result\": \"others\"}\n\n    # In INITIAL DB, there must NOT be a current assignment for order 104 and this driver\n    initial_assignments = safe_query(\n        initial_db_path,\n        \"SELECT id FROM order_assignments WHERE order_id = ? AND is_current = 1 AND driver_id = ?\",\n        (order_id, driver_id)\n    )\n    if len(initial_assignments) != 0:\n        return {\"result\": \"others\"}\n\n    # Also, in initial DB no current assignment for order 104 to any driver\n    initial_any_current = safe_query(\n        initial_db_path,\n        \"SELECT id FROM order_assignments WHERE order_id = ? AND is_current = 1\",\n        (order_id,)\n    )\n    if len(initial_any_current) != 0:\n        return {\"result\": \"others\"}\n\n    # In final DB, ensure NO other current assignment for this order (robustness)\n    # i.e., only one is_current=1 for this order\n    all_current = safe_query(\n        final_db_path,\n        \"SELECT driver_id FROM order_assignments WHERE order_id = ? AND is_current = 1\",\n        (order_id,)\n    )\n    if len(all_current) != 1 or all_current[0][0] != driver_id:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This is a strict modification-based verification. The agent must: (1) Assign the available driver 'Dasher: Miguel R.' to order 'BB-10482' (order_id 104); (2) Set the planned pickup time to 2:10 PM; (3) Add a dispatch note: 'Traffic on US-101; use surface streets'. The verification will check the existence of an 'order_assignments' row (for order_id=104, driver_id=1) that is marked as current (is_current=1) in the final DB but NOT present in the initial DB. The assignment must have the correct pickup_time_planned and dispatch_note values as per the task, and cannot be unassigned (unassigned_at, unassigned_reason must be NULL). All other required fields must conform and no extraneous current assignment for that order may exist. No check on final_answer text is needed.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find driver_id for 'Dasher: Miguel R.' (should be 1) in both DBs\",\n        \"Find order_id for external_order_ref 'BB-10482' (should be 104) in both DBs\",\n        \"In final DB, ensure a single current assignment exists: order_assignments where order_id=104, driver_id=1, is_current=1\",\n        \"Verify assignment pickup_time_planned is '2026-02-18 14:10:00' (2:10 PM)\",\n        \"Verify assignment dispatch_note exactly matches 'Traffic on US-101; use surface streets'\",\n        \"Verify assignment unassigned_at/unassigned_reason are NULL\",\n        \"Verify no such current assignment existed in initial DB (there should be no order_assignments row for order_id=104 and is_current=1 in initial DB assigned to 'Dasher: Miguel R.')\",\n        \"No other drivers currently assigned to order 104 (is_current=1) in final DB\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper for read-only DB queries\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Get driver_id for 'Dasher: Miguel R.'\\n    driver_q = \\\"SELECT id FROM drivers WHERE display_name = ?\\\"\\n    final_driver = safe_query(final_db_path, driver_q, (\\\"Dasher: Miguel R.\\\",))\\n    if len(final_driver) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    driver_id = final_driver[0][0]\\n    # Sanity: check initial DB agrees\\n    initial_driver = safe_query(initial_db_path, driver_q, (\\\"Dasher: Miguel R.\\\",))\\n    if len(initial_driver) != 1 or initial_driver[0][0] != driver_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Get order_id for 'BB-10482'\\n    order_q = \\\"SELECT id FROM delivery_orders WHERE external_order_ref = ?\\\"\\n    final_order = safe_query(final_db_path, order_q, (\\\"BB-10482\\\",))\\n    if len(final_order) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order_id = final_order[0][0]\\n    # Sanity: check initial DB agrees\\n    initial_order = safe_query(initial_db_path, order_q, (\\\"BB-10482\\\",))\\n    if len(initial_order) != 1 or initial_order[0][0] != order_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check for any current assignments for this order in FINAL DB\\n    final_assignments = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, driver_id, is_current, pickup_time_planned, dispatch_note, unassigned_at, unassigned_reason FROM order_assignments WHERE order_id = ? AND is_current = 1\\\",\\n        (order_id,)\\n    )\\n    if len(final_assignments) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    assign = final_assignments[0]\\n    a_id, a_driver_id, a_is_current, a_pickup_time, a_note, a_unassigned_at, a_unassigned_reason = assign\\n    # Must be Miguel R., current, not unassigned\\n    if a_driver_id != driver_id or a_is_current != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if a_unassigned_at is not None or a_unassigned_reason is not None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Pickup time must be exactly '2026-02-18 14:10:00' (2:10 PM)\\n    if a_pickup_time != '2026-02-18 14:10:00':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Dispatch note must match exactly\\n    if (a_note or '').strip() != 'Traffic on US-101; use surface streets':\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # In INITIAL DB, there must NOT be a current assignment for order 104 and this driver\\n    initial_assignments = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM order_assignments WHERE order_id = ? AND is_current = 1 AND driver_id = ?\\\",\\n        (order_id, driver_id)\\n    )\\n    if len(initial_assignments) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Also, in initial DB no current assignment for order 104 to any driver\\n    initial_any_current = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM order_assignments WHERE order_id = ? AND is_current = 1\\\",\\n        (order_id,)\\n    )\\n    if len(initial_any_current) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # In final DB, ensure NO other current assignment for this order (robustness)\\n    # i.e., only one is_current=1 for this order\\n    all_current = safe_query(\\n        final_db_path,\\n        \\\"SELECT driver_id FROM order_assignments WHERE order_id = ? AND is_current = 1\\\",\\n        (order_id,)\\n    )\\n    if len(all_current) != 1 or all_current[0][0] != driver_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 4, "task": "Unassign the current driver from order \"BB-10482\" due to \"vehicle issue\" and immediately reassign the nearest available driver within 3 miles of the pickup address.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import math\n    import re\n\n    def safe_query(db_path: str, query: str, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            res = cur.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n\n    # Helper to compute haversine distance in miles\n    def haversine(lat1, lng1, lat2, lng2):\n        if None in [lat1, lng1, lat2, lng2]:\n            return None\n        try:\n            # convert decimal degrees to radians\n            lon1, lat1, lon2, lat2 = map(math.radians, [lng1, lat1, lng2, lat2])\n            # haversine formula\n            dlon = lon2 - lon1\n            dlat = lat2 - lat1\n            a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2\n            c = 2 * math.asin(math.sqrt(a))\n            mi = 3959 * c  # radius of earth in miles\n            return mi\n        except Exception:\n            return None\n\n    # Step 1: Get order_id for 'BB-10482'\n    order_rows = safe_query(initial_db_path, \"SELECT id, pickup_address_id FROM delivery_orders WHERE external_order_ref = ?\", (\"BB-10482\",))\n    if not order_rows or len(order_rows[0]) < 2:\n        return {\"result\": \"others\"}\n    order_id, pickup_address_id = order_rows[0][0], order_rows[0][1]\n\n    # Step 2: Get pickup lat/lng\n    pickup_addr = safe_query(initial_db_path, \"SELECT lat, lng FROM addresses WHERE id = ?\", (pickup_address_id,))\n    if not pickup_addr or len(pickup_addr[0]) < 2:\n        return {\"result\": \"others\"}\n    pickup_lat, pickup_lng = pickup_addr[0][0], pickup_addr[0][1]\n    if pickup_lat is None or pickup_lng is None:\n        return {\"result\": \"others\"}\n\n    # Step 3: Get initial current assignment\n    initial_assign = safe_query(initial_db_path, \"SELECT id, driver_id, assigned_at, is_current FROM order_assignments WHERE order_id = ? AND is_current = 1\", (order_id,))\n    if not initial_assign or len(initial_assign[0]) < 4:\n        return {\"result\": \"others\"}\n    initial_assign_id, initial_driver_id, assigned_at_init, is_current_init = initial_assign[0]\n\n    # Step 4: Find prior assignment (should be same as above), then find in final_db: assignment with is_current=0 for this order_id and correct unassign reason\n    prev_assign_final = safe_query(final_db_path, \"SELECT id, driver_id, assigned_at, unassigned_at, unassigned_reason, is_current FROM order_assignments WHERE order_id = ? AND is_current = 0 ORDER BY unassigned_at DESC\", (order_id,))\n    if not prev_assign_final:\n        return {\"result\": \"others\"}\n    # Find one where unassigned_reason contains 'vehicle issue' (case insensitive)\n    prev_unassigned_row = None\n    for row in prev_assign_final:\n        if row[4] and re.search(r'vehicle\\s*issue', str(row[4]), re.IGNORECASE):\n            prev_unassigned_row = row\n            break\n    if not prev_unassigned_row:\n        return {\"result\": \"others\"}\n    prev_unassigned_id, prev_driver_id, prev_assigned_at, prev_unassigned_at, prev_unassigned_reason, prev_is_current = prev_unassigned_row\n\n    # Step 5: Find new assignment in final_db (is_current=1) for this order_id\n    new_assigns_final = safe_query(final_db_path, \"SELECT id, driver_id, assigned_at, pickup_time_planned FROM order_assignments WHERE order_id = ? AND is_current = 1\", (order_id,))\n    if not new_assigns_final:\n        return {\"result\": \"others\"}\n    # Only allow exactly one current assignment\n    if len(new_assigns_final) != 1:\n        return {\"result\": \"others\"}\n    new_assign_id, new_driver_id, new_assigned_at, new_pt_planned = new_assigns_final[0]\n    if new_driver_id is None:\n        return {\"result\": \"others\"}\n\n    # Step 6: Ensure new assignment is to a different driver\n    if new_driver_id == prev_driver_id:\n        # Task is to reassign; must not be same driver\n        return {\"result\": \"others\"}\n\n    # Step 7: Check new driver's active/available status in final_db\n    driver_row = safe_query(final_db_path, \"SELECT is_active, availability_status, last_known_lat, last_known_lng FROM drivers WHERE id = ?\", (new_driver_id,))\n    if not driver_row or len(driver_row[0]) < 4:\n        return {\"result\": \"others\"}\n    is_active, avail_status, d_lat, d_lng = driver_row[0]\n    if is_active != 1 or str(avail_status).lower() not in ['available', 'on_delivery']:\n        # Should be available, but we allow on_delivery as may be set at assignment\n        return {\"result\": \"others\"}\n    if d_lat is None or d_lng is None:\n        return {\"result\": \"others\"}\n\n    # Step 8: Confirm new driver's last_known location is within 3 miles of pickup address\n    dist_mi = haversine(pickup_lat, pickup_lng, d_lat, d_lng)\n    if dist_mi is None or dist_mi > 3:\n        return {\"result\": \"others\"}\n\n    # Step 9: Ensure reassignment happens after unassignment and \"immediately\"\n    # (require new_assigned_at >= prev_unassigned_at, and within 10 minutes)\n    # Parse datetime strings: format is 'YYYY-MM-DD HH:MM:SS'\n    import datetime\n    try:\n        if prev_unassigned_at and new_assigned_at:\n            t_prev = datetime.datetime.strptime(prev_unassigned_at, '%Y-%m-%d %H:%M:%S')\n            t_new = datetime.datetime.strptime(new_assigned_at, '%Y-%m-%d %H:%M:%S')\n            # Allow up to 10 minutes between unassign and assign\n            if t_new < t_prev or (t_new - t_prev).total_seconds() > 600:\n                return {\"result\": \"others\"}\n    except Exception:\n        # Malformed timestamps\n        return {\"result\": \"others\"}\n\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This is a modification-based task with two sequential requirements: (1) Unassign the current driver from order 'BB-10482' and record the reason as 'vehicle issue', and (2) Immediately reassign the nearest available driver within 3 miles of the pickup address. To verify successful completion, we must: (a) confirm the current assignment of a driver for order 'BB-10482' in initial_db, (b) in final_db, ensure that assignment has been ended (is_current = 0) with unassigned_reason 'vehicle issue', and (c) confirm a new assignment (is_current = 1) to another driver, who should be available and within 3 miles of the pickup location, and (d) the new assignment must occur after the unassignment (i.e., immediately).\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find order_id for 'BB-10482'\",\n        \"Verify initial_db: order_assignments has is_current=1 for this order_id\",\n        \"Verify final_db: previous assignment is_current=0 with unassigned_reason containing 'vehicle issue'\",\n        \"Verify final_db: there is a new assignment (is_current=1) for this order_id with a different driver\",\n        \"Confirm new driver is available and active in drivers table\",\n        \"Confirm new driver's last_known location is within 3 miles of the pickup address (lat/lng)\",\n        \"Ensure the reassignment happens after the unassignment, and immediately (assignment timestamps close together)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import math\\n    import re\\n\\n    def safe_query(db_path: str, query: str, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            res = cur.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n\\n    # Helper to compute haversine distance in miles\\n    def haversine(lat1, lng1, lat2, lng2):\\n        if None in [lat1, lng1, lat2, lng2]:\\n            return None\\n        try:\\n            # convert decimal degrees to radians\\n            lon1, lat1, lon2, lat2 = map(math.radians, [lng1, lat1, lng2, lat2])\\n            # haversine formula\\n            dlon = lon2 - lon1\\n            dlat = lat2 - lat1\\n            a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2\\n            c = 2 * math.asin(math.sqrt(a))\\n            mi = 3959 * c  # radius of earth in miles\\n            return mi\\n        except Exception:\\n            return None\\n\\n    # Step 1: Get order_id for 'BB-10482'\\n    order_rows = safe_query(initial_db_path, \\\"SELECT id, pickup_address_id FROM delivery_orders WHERE external_order_ref = ?\\\", (\\\"BB-10482\\\",))\\n    if not order_rows or len(order_rows[0]) < 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order_id, pickup_address_id = order_rows[0][0], order_rows[0][1]\\n\\n    # Step 2: Get pickup lat/lng\\n    pickup_addr = safe_query(initial_db_path, \\\"SELECT lat, lng FROM addresses WHERE id = ?\\\", (pickup_address_id,))\\n    if not pickup_addr or len(pickup_addr[0]) < 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    pickup_lat, pickup_lng = pickup_addr[0][0], pickup_addr[0][1]\\n    if pickup_lat is None or pickup_lng is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Get initial current assignment\\n    initial_assign = safe_query(initial_db_path, \\\"SELECT id, driver_id, assigned_at, is_current FROM order_assignments WHERE order_id = ? AND is_current = 1\\\", (order_id,))\\n    if not initial_assign or len(initial_assign[0]) < 4:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    initial_assign_id, initial_driver_id, assigned_at_init, is_current_init = initial_assign[0]\\n\\n    # Step 4: Find prior assignment (should be same as above), then find in final_db: assignment with is_current=0 for this order_id and correct unassign reason\\n    prev_assign_final = safe_query(final_db_path, \\\"SELECT id, driver_id, assigned_at, unassigned_at, unassigned_reason, is_current FROM order_assignments WHERE order_id = ? AND is_current = 0 ORDER BY unassigned_at DESC\\\", (order_id,))\\n    if not prev_assign_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find one where unassigned_reason contains 'vehicle issue' (case insensitive)\\n    prev_unassigned_row = None\\n    for row in prev_assign_final:\\n        if row[4] and re.search(r'vehicle\\\\s*issue', str(row[4]), re.IGNORECASE):\\n            prev_unassigned_row = row\\n            break\\n    if not prev_unassigned_row:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    prev_unassigned_id, prev_driver_id, prev_assigned_at, prev_unassigned_at, prev_unassigned_reason, prev_is_current = prev_unassigned_row\\n\\n    # Step 5: Find new assignment in final_db (is_current=1) for this order_id\\n    new_assigns_final = safe_query(final_db_path, \\\"SELECT id, driver_id, assigned_at, pickup_time_planned FROM order_assignments WHERE order_id = ? AND is_current = 1\\\", (order_id,))\\n    if not new_assigns_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Only allow exactly one current assignment\\n    if len(new_assigns_final) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_assign_id, new_driver_id, new_assigned_at, new_pt_planned = new_assigns_final[0]\\n    if new_driver_id is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 6: Ensure new assignment is to a different driver\\n    if new_driver_id == prev_driver_id:\\n        # Task is to reassign; must not be same driver\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 7: Check new driver's active/available status in final_db\\n    driver_row = safe_query(final_db_path, \\\"SELECT is_active, availability_status, last_known_lat, last_known_lng FROM drivers WHERE id = ?\\\", (new_driver_id,))\\n    if not driver_row or len(driver_row[0]) < 4:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    is_active, avail_status, d_lat, d_lng = driver_row[0]\\n    if is_active != 1 or str(avail_status).lower() not in ['available', 'on_delivery']:\\n        # Should be available, but we allow on_delivery as may be set at assignment\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if d_lat is None or d_lng is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 8: Confirm new driver's last_known location is within 3 miles of pickup address\\n    dist_mi = haversine(pickup_lat, pickup_lng, d_lat, d_lng)\\n    if dist_mi is None or dist_mi > 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 9: Ensure reassignment happens after unassignment and \\\"immediately\\\"\\n    # (require new_assigned_at >= prev_unassigned_at, and within 10 minutes)\\n    # Parse datetime strings: format is 'YYYY-MM-DD HH:MM:SS'\\n    import datetime\\n    try:\\n        if prev_unassigned_at and new_assigned_at:\\n            t_prev = datetime.datetime.strptime(prev_unassigned_at, '%Y-%m-%d %H:%M:%S')\\n            t_new = datetime.datetime.strptime(new_assigned_at, '%Y-%m-%d %H:%M:%S')\\n            # Allow up to 10 minutes between unassign and assign\\n            if t_new < t_prev or (t_new - t_prev).total_seconds() > 600:\\n                return {\\\"result\\\": \\\"others\\\"}\\n    except Exception:\\n        # Malformed timestamps\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 5, "task": "For order \"BB-10482\", append a status event timeline update marking it as \"picked_up\" at 2:18 PM with pickup notes \"Order verified; 2 bags\" and then mark it \"en_route\" with an updated ETA of 2:42 PM.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    # Helper: Safe, read-only query\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            result = cursor.fetchall()\n            conn.close()\n            return result\n        except Exception:\n            return []\n    # Task constants\n    EXTERNAL_ORDER_REF = 'BB-10482'\n    PICKED_UP_TIMESTAMP = '2026-02-18 14:18:00'  # 2:18 PM\n    PICKED_UP_EXPECTED_NOTES = 'Order verified; 2 bags'\n    EN_ROUTE_EXPECTED_ETA = '2026-02-18 14:42:00'  # 2:42 PM\n\n    # Step 1: Get order_id for the external_order_ref in both DBs\n    get_order_id_query = \"SELECT id FROM delivery_orders WHERE external_order_ref = ?\"\n    init_order_id_rows = safe_query(initial_db_path, get_order_id_query, (EXTERNAL_ORDER_REF,))\n    final_order_id_rows = safe_query(final_db_path, get_order_id_query, (EXTERNAL_ORDER_REF,))\n    if not init_order_id_rows or not final_order_id_rows:\n        return {\"result\": \"others\"}\n    init_order_id = init_order_id_rows[0][0]\n    final_order_id = final_order_id_rows[0][0]\n    if init_order_id != final_order_id:\n        return {\"result\": \"others\"}\n    order_id = init_order_id\n\n    # Step 2: Get all status events for this order in both DBs, IN ORDER\n    event_cols = [\"id\", \"status\", \"event_time\", \"eta\", \"notes\", \"created_by_user_id\", \"created_at\"]\n    col_idx = {k: i for i, k in enumerate(event_cols)}\n    event_sel = \", \".join(event_cols)\n    query_events = f\"SELECT {event_sel} FROM order_status_events WHERE order_id = ? ORDER BY event_time ASC, id ASC\"\n    init_events = safe_query(initial_db_path, query_events, (order_id,))\n    final_events = safe_query(final_db_path, query_events, (order_id,))\n    if len(final_events) < len(init_events) + 2:\n        return {\"result\": \"others\"}\n    # Step 3: Check prefix matches (old events not modified)\n    init_len = len(init_events)\n    # Compare by status, event_time, eta, notes (ignore id, created_by_user_id, created_at)\n    for i in range(init_len):\n        init_ev = init_events[i]\n        final_ev = final_events[i]\n        for field in [\"status\", \"event_time\", \"eta\", \"notes\"]:\n            ii = col_idx[field]\n            if (init_ev[ii] or \"\") != (final_ev[ii] or \"\"):\n                return {\"result\": \"others\"}\n    # Step 4: The 2 new events should be picked_up then en_route, in order; no extras\n    new_events = final_events[init_len:]\n    if len(new_events) != 2:\n        return {\"result\": \"others\"}\n    picked_up_ev, en_route_ev = new_events\n    # Check picked_up event\n    if (picked_up_ev[col_idx['status']] != 'picked_up' or\n        (picked_up_ev[col_idx['event_time']] or \"\") != PICKED_UP_TIMESTAMP or\n        (picked_up_ev[col_idx['notes']] or \"\") != PICKED_UP_EXPECTED_NOTES):\n        return {\"result\": \"others\"}\n    # Check en_route event: status & ETA\n    if (en_route_ev[col_idx['status']] != 'en_route'):\n        return {\"result\": \"others\"}\n    if (en_route_ev[col_idx['eta']] or \"\") != EN_ROUTE_EXPECTED_ETA:\n        return {\"result\": \"others\"}\n    # en_route event_time must be equal to or after picked_up\n    try:\n        from datetime import datetime\n        pt = picked_up_ev[col_idx['event_time']] or \"\"\n        et = en_route_ev[col_idx['event_time']] or \"\"\n        if not pt or not et:\n            return {\"result\": \"others\"}\n        pt_dt = datetime.strptime(pt, '%Y-%m-%d %H:%M:%S')\n        et_dt = datetime.strptime(et, '%Y-%m-%d %H:%M:%S')\n        if et_dt < pt_dt:\n            return {\"result\": \"others\"}\n    except Exception:\n        return {\"result\": \"others\"}\n    # No duplicate picked_up or en_route status after this position\n    after_events = final_events[init_len+2:]\n    for ev in after_events:\n        if ev[col_idx['status']] in ('picked_up','en_route'):\n            return {\"result\": \"others\"}\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task requires verifying that for order 'BB-10482', two new status timeline events were appended: 1) a 'picked_up' event at 2:18 PM with notes 'Order verified; 2 bags', and 2) an 'en_route' event with ETA 2:42 PM. The events must match exactly in order, timestamp, notes, and ETA. We must compare the order_status_events table for the specific order in the initial and final database, and confirm that, after the agent's actions, there is a 'picked_up' event with the given time and notes and a subsequent 'en_route' event with the updated ETA (2:42 PM). Events must be new: i.e., must not have existed in the initial database (must be appended or updated in sequence). There must be no modification to older events for 'BB-10482'. Only these precise updates are allowed; anything extra or missing is incomplete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find the delivery_orders.id corresponding to external_order_ref 'BB-10482'\",\n        \"Query all order_status_events for this order, sorted by event_time, from both the initial and final db\",\n        \"Ensure in final_db, two new events are present after initial_db events (new records)\",\n        \"First new event: status='picked_up', event_time exactly '2026-02-18 14:18:00', notes exactly 'Order verified; 2 bags'\",\n        \"Second new event: status='en_route', ETA exactly '2026-02-18 14:42:00' (2:42 PM), event_time >= picked_up\",\n        \"No other changes to other status events for BB-10482; new events only appended\",\n        \"No duplication (only one picked_up and one new en_route event for this order after those in initial_db)\",\n        \"If any check fails or is ambiguous, return 'others'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    # Helper: Safe, read-only query\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            result = cursor.fetchall()\\n            conn.close()\\n            return result\\n        except Exception:\\n            return []\\n    # Task constants\\n    EXTERNAL_ORDER_REF = 'BB-10482'\\n    PICKED_UP_TIMESTAMP = '2026-02-18 14:18:00'  # 2:18 PM\\n    PICKED_UP_EXPECTED_NOTES = 'Order verified; 2 bags'\\n    EN_ROUTE_EXPECTED_ETA = '2026-02-18 14:42:00'  # 2:42 PM\\n\\n    # Step 1: Get order_id for the external_order_ref in both DBs\\n    get_order_id_query = \\\"SELECT id FROM delivery_orders WHERE external_order_ref = ?\\\"\\n    init_order_id_rows = safe_query(initial_db_path, get_order_id_query, (EXTERNAL_ORDER_REF,))\\n    final_order_id_rows = safe_query(final_db_path, get_order_id_query, (EXTERNAL_ORDER_REF,))\\n    if not init_order_id_rows or not final_order_id_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    init_order_id = init_order_id_rows[0][0]\\n    final_order_id = final_order_id_rows[0][0]\\n    if init_order_id != final_order_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order_id = init_order_id\\n\\n    # Step 2: Get all status events for this order in both DBs, IN ORDER\\n    event_cols = [\\\"id\\\", \\\"status\\\", \\\"event_time\\\", \\\"eta\\\", \\\"notes\\\", \\\"created_by_user_id\\\", \\\"created_at\\\"]\\n    col_idx = {k: i for i, k in enumerate(event_cols)}\\n    event_sel = \\\", \\\".join(event_cols)\\n    query_events = f\\\"SELECT {event_sel} FROM order_status_events WHERE order_id = ? ORDER BY event_time ASC, id ASC\\\"\\n    init_events = safe_query(initial_db_path, query_events, (order_id,))\\n    final_events = safe_query(final_db_path, query_events, (order_id,))\\n    if len(final_events) < len(init_events) + 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Step 3: Check prefix matches (old events not modified)\\n    init_len = len(init_events)\\n    # Compare by status, event_time, eta, notes (ignore id, created_by_user_id, created_at)\\n    for i in range(init_len):\\n        init_ev = init_events[i]\\n        final_ev = final_events[i]\\n        for field in [\\\"status\\\", \\\"event_time\\\", \\\"eta\\\", \\\"notes\\\"]:\\n            ii = col_idx[field]\\n            if (init_ev[ii] or \\\"\\\") != (final_ev[ii] or \\\"\\\"):\\n                return {\\\"result\\\": \\\"others\\\"}\\n    # Step 4: The 2 new events should be picked_up then en_route, in order; no extras\\n    new_events = final_events[init_len:]\\n    if len(new_events) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    picked_up_ev, en_route_ev = new_events\\n    # Check picked_up event\\n    if (picked_up_ev[col_idx['status']] != 'picked_up' or\\n        (picked_up_ev[col_idx['event_time']] or \\\"\\\") != PICKED_UP_TIMESTAMP or\\n        (picked_up_ev[col_idx['notes']] or \\\"\\\") != PICKED_UP_EXPECTED_NOTES):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check en_route event: status & ETA\\n    if (en_route_ev[col_idx['status']] != 'en_route'):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if (en_route_ev[col_idx['eta']] or \\\"\\\") != EN_ROUTE_EXPECTED_ETA:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # en_route event_time must be equal to or after picked_up\\n    try:\\n        from datetime import datetime\\n        pt = picked_up_ev[col_idx['event_time']] or \\\"\\\"\\n        et = en_route_ev[col_idx['event_time']] or \\\"\\\"\\n        if not pt or not et:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        pt_dt = datetime.strptime(pt, '%Y-%m-%d %H:%M:%S')\\n        et_dt = datetime.strptime(et, '%Y-%m-%d %H:%M:%S')\\n        if et_dt < pt_dt:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # No duplicate picked_up or en_route status after this position\\n    after_events = final_events[init_len+2:]\\n    for ev in after_events:\\n        if ev[col_idx['status']] in ('picked_up','en_route'):\\n            return {\\\"result\\\": \\\"others\\\"}\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 6, "task": "Ingest five GPS pings for order \"BB-10482\" (lat/lng: 37.7765,-122.4172; 37.7751,-122.4149; 37.7732,-122.4110; 37.7706,-122.4080; 37.7681,-122.4052) with timestamps spaced 2 minutes apart starting at 2:20 PM and recalculate the synthesized ETA after the last ping.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    from datetime import datetime\n    \n    # The expected 5 pings; times are in 24h\n    expected_pings = [\n        {'ping_time': '2026-02-18 14:20:00', 'lat': 37.7765, 'lng': -122.4172},\n        {'ping_time': '2026-02-18 14:22:00', 'lat': 37.7751, 'lng': -122.4149},\n        {'ping_time': '2026-02-18 14:24:00', 'lat': 37.7732, 'lng': -122.4110},\n        {'ping_time': '2026-02-18 14:26:00', 'lat': 37.7706, 'lng': -122.4080},\n        {'ping_time': '2026-02-18 14:28:00', 'lat': 37.7681, 'lng': -122.4052}\n    ]\n    order_id = 104\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            res = cur.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n    \n    # 1. Check that the five pings are NOT in the initial DB\n    inits = []\n    for ping in expected_pings:\n        q = \"\"\"\n        SELECT 1 FROM order_gps_pings WHERE order_id = ? AND ABS(lat - ?) < 0.0001 AND ABS(lng - ?) < 0.0001 AND ping_time = ?\n        \"\"\"\n        res = safe_query(initial_db_path, q, (order_id, ping['lat'], ping['lng'], ping['ping_time']))\n        if res:\n            inits.append(ping)\n    if inits:\n        # They should NOT pre-exist\n        return {\"result\": \"others\"}\n    \n    # 2. Check that the five pings ARE present in the final DB (and match values exactly)\n    finals = []\n    for ping in expected_pings:\n        q = \"\"\"\n        SELECT id, driver_id, accuracy_m, source FROM order_gps_pings WHERE order_id = ? AND ABS(lat - ?) < 0.0001 AND ABS(lng - ?) < 0.0001 AND ping_time = ?\n        \"\"\"\n        res = safe_query(final_db_path, q, (order_id, ping['lat'], ping['lng'], ping['ping_time']))\n        if not res:\n            return {\"result\": \"others\"}\n        finals.append(res[0])\n    # Defensive: ensure all pings are actually unique rows\n    if len({r[0] for r in finals}) != 5:\n        return {\"result\": \"others\"}\n    \n    # 3. ETA must be recalculated AFTER the last ping (>= 2026-02-18 14:28:00)\n    #    Accept: either delivery_orders.latest_eta field updated, or a corresponding order_status_events ETA update\n    # Fetch last ping time\n    last_ping_time_str = expected_pings[-1]['ping_time']\n    try:\n        last_ping_time = datetime.strptime(last_ping_time_str, \"%Y-%m-%d %H:%M:%S\")\n    except Exception:\n        return {\"result\": \"others\"}\n    \n    # Get initial and final latest_eta and updated_at fields\n    q_eta = \"SELECT latest_eta, updated_at FROM delivery_orders WHERE id = ?\"\n    eta_init = safe_query(initial_db_path, q_eta, (order_id,))\n    eta_final = safe_query(final_db_path, q_eta, (order_id,))\n    if not eta_final or not eta_final[0]:\n        return {\"result\": \"others\"}\n    (latest_eta_final, updated_at_final) = eta_final[0]\n    latest_eta_init = eta_init[0][0] if eta_init and eta_init[0] else None\n    updated_at_init = eta_init[0][1] if eta_init and eta_init[0] else None\n    \n    # Parse times\n    def parse_dt(t):\n        try:\n            return datetime.strptime(t, \"%Y-%m-%d %H:%M:%S\") if t else None\n        except Exception:\n            return None\n    eta_final_parsed = parse_dt(latest_eta_final)\n    eta_init_parsed = parse_dt(latest_eta_init)\n    updated_at_final_parsed = parse_dt(updated_at_final)\n    updated_at_init_parsed = parse_dt(updated_at_init)\n    # The ETA must be modified and the updated_at must be after last ping, OR the ETA must be more recent\n    eta_changed = (latest_eta_final != latest_eta_init) and (\n        not eta_init_parsed or (eta_final_parsed and eta_final_parsed != eta_init_parsed)\n    )\n    updated_after_last_ping = updated_at_final_parsed and updated_at_final_parsed >= last_ping_time\n    # Accept as sufficient if either delivery_orders.latest_eta/updated_at meets the criteria, or new status event\n    eta_ok = False\n    if eta_changed and updated_after_last_ping:\n        eta_ok = True\n    else:\n        # Look for order_status_events 'en_route'-type event with eta set, created at/after last ping\n        q_evt = \"\"\"\n        SELECT status, event_time, eta, created_at FROM order_status_events WHERE order_id = ? AND eta IS NOT NULL ORDER BY event_time DESC LIMIT 3\n        \"\"\"\n        events = safe_query(final_db_path, q_evt, (order_id,))\n        for status, event_time, eta, created_at in events:\n            evt_time = parse_dt(event_time)\n            evt_created = parse_dt(created_at)\n            eta_time = parse_dt(eta)\n            if (evt_time and evt_time >= last_ping_time) or (evt_created and evt_created >= last_ping_time):\n                # If ETA and status are consistent, accept; just needs a new ETA after last ping\n                eta_ok = True\n                break\n    if not eta_ok:\n        return {\"result\": \"others\"}\n    \n    # All checks pass\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This is a pure modification-based task. The agent must (1) ingest five specific GPS pings for order 'BB-10482' (order_id=104) with the right lat/lng and timestamps (t=2:20 PM, then each 2 minutes after), and (2) recalculate the synthesized ETA after the last ping, i.e., update the delivery_orders.latest_eta field and/or add a GPS-driven ETA update in the order_status_events table. To consider the task complete, all five pings must be present ONLY in final_db (not initial_db), with exact matching values in lat/lng and ping_time, linked to order_id 104 in correct time sequence. The ETA recalculation must have actually occurred after the ingestion (timing and/or updated eta field). No other cases are 'complete'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Extract expected GPS pings (lat/lng/times) for order BB-10482 (order_id=104)\",\n        \"Ensure these 5 GPS pings do NOT exist in the initial database, but DO exist in the final database (on order 104, times/coords/driver_id, with a 2-minute interval from 14:20 to 14:28)\",\n        \"Order and values must match exactly (lat/lng, timestamps, order_id)\",\n        \"After the last ping (>= 2026-02-18 14:28:00), check for an updated ETA (either latest_eta in delivery_orders, or an 'en_route'/'eta_updated' record in order_status_events) updated at/after last ping\",\n        \"If and only if all above are true, return 'complete'; otherwise or if uncertain, return 'others'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    from datetime import datetime\\n    \\n    # The expected 5 pings; times are in 24h\\n    expected_pings = [\\n        {'ping_time': '2026-02-18 14:20:00', 'lat': 37.7765, 'lng': -122.4172},\\n        {'ping_time': '2026-02-18 14:22:00', 'lat': 37.7751, 'lng': -122.4149},\\n        {'ping_time': '2026-02-18 14:24:00', 'lat': 37.7732, 'lng': -122.4110},\\n        {'ping_time': '2026-02-18 14:26:00', 'lat': 37.7706, 'lng': -122.4080},\\n        {'ping_time': '2026-02-18 14:28:00', 'lat': 37.7681, 'lng': -122.4052}\\n    ]\\n    order_id = 104\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            res = cur.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n    \\n    # 1. Check that the five pings are NOT in the initial DB\\n    inits = []\\n    for ping in expected_pings:\\n        q = \\\"\\\"\\\"\\n        SELECT 1 FROM order_gps_pings WHERE order_id = ? AND ABS(lat - ?) < 0.0001 AND ABS(lng - ?) < 0.0001 AND ping_time = ?\\n        \\\"\\\"\\\"\\n        res = safe_query(initial_db_path, q, (order_id, ping['lat'], ping['lng'], ping['ping_time']))\\n        if res:\\n            inits.append(ping)\\n    if inits:\\n        # They should NOT pre-exist\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # 2. Check that the five pings ARE present in the final DB (and match values exactly)\\n    finals = []\\n    for ping in expected_pings:\\n        q = \\\"\\\"\\\"\\n        SELECT id, driver_id, accuracy_m, source FROM order_gps_pings WHERE order_id = ? AND ABS(lat - ?) < 0.0001 AND ABS(lng - ?) < 0.0001 AND ping_time = ?\\n        \\\"\\\"\\\"\\n        res = safe_query(final_db_path, q, (order_id, ping['lat'], ping['lng'], ping['ping_time']))\\n        if not res:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        finals.append(res[0])\\n    # Defensive: ensure all pings are actually unique rows\\n    if len({r[0] for r in finals}) != 5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # 3. ETA must be recalculated AFTER the last ping (>= 2026-02-18 14:28:00)\\n    #    Accept: either delivery_orders.latest_eta field updated, or a corresponding order_status_events ETA update\\n    # Fetch last ping time\\n    last_ping_time_str = expected_pings[-1]['ping_time']\\n    try:\\n        last_ping_time = datetime.strptime(last_ping_time_str, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Get initial and final latest_eta and updated_at fields\\n    q_eta = \\\"SELECT latest_eta, updated_at FROM delivery_orders WHERE id = ?\\\"\\n    eta_init = safe_query(initial_db_path, q_eta, (order_id,))\\n    eta_final = safe_query(final_db_path, q_eta, (order_id,))\\n    if not eta_final or not eta_final[0]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    (latest_eta_final, updated_at_final) = eta_final[0]\\n    latest_eta_init = eta_init[0][0] if eta_init and eta_init[0] else None\\n    updated_at_init = eta_init[0][1] if eta_init and eta_init[0] else None\\n    \\n    # Parse times\\n    def parse_dt(t):\\n        try:\\n            return datetime.strptime(t, \\\"%Y-%m-%d %H:%M:%S\\\") if t else None\\n        except Exception:\\n            return None\\n    eta_final_parsed = parse_dt(latest_eta_final)\\n    eta_init_parsed = parse_dt(latest_eta_init)\\n    updated_at_final_parsed = parse_dt(updated_at_final)\\n    updated_at_init_parsed = parse_dt(updated_at_init)\\n    # The ETA must be modified and the updated_at must be after last ping, OR the ETA must be more recent\\n    eta_changed = (latest_eta_final != latest_eta_init) and (\\n        not eta_init_parsed or (eta_final_parsed and eta_final_parsed != eta_init_parsed)\\n    )\\n    updated_after_last_ping = updated_at_final_parsed and updated_at_final_parsed >= last_ping_time\\n    # Accept as sufficient if either delivery_orders.latest_eta/updated_at meets the criteria, or new status event\\n    eta_ok = False\\n    if eta_changed and updated_after_last_ping:\\n        eta_ok = True\\n    else:\\n        # Look for order_status_events 'en_route'-type event with eta set, created at/after last ping\\n        q_evt = \\\"\\\"\\\"\\n        SELECT status, event_time, eta, created_at FROM order_status_events WHERE order_id = ? AND eta IS NOT NULL ORDER BY event_time DESC LIMIT 3\\n        \\\"\\\"\\\"\\n        events = safe_query(final_db_path, q_evt, (order_id,))\\n        for status, event_time, eta, created_at in events:\\n            evt_time = parse_dt(event_time)\\n            evt_created = parse_dt(created_at)\\n            eta_time = parse_dt(eta)\\n            if (evt_time and evt_time >= last_ping_time) or (evt_created and evt_created >= last_ping_time):\\n                # If ETA and status are consistent, accept; just needs a new ETA after last ping\\n                eta_ok = True\\n                break\\n    if not eta_ok:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # All checks pass\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 7, "task": "Mark order \"BB-10482\" as delivered at 2:46 PM and attach proof-of-delivery with photo metadata {\"url\":\"https://cdn.example.com/pod/bb-10482-1.jpg\",\"timestamp\":\"2:46 PM\",\"notes\":\"Left at front desk\"} and recipient signature name \"A. Patel\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    # Helper: get order_id from external_order_ref\n    def get_order_id(db_path: str, external_order_ref: str) -> int | None:\n        rows = safe_query(db_path, \"SELECT id FROM delivery_orders WHERE external_order_ref = ?\", (external_order_ref,))\n        if rows and isinstance(rows[0][0], int):\n            return rows[0][0]\n        return None\n    # Helper: check if delivered status exists\n    def delivered_status_event(db_path: str, order_id: int) -> tuple | None:\n        rows = safe_query(db_path, \"SELECT id, status, event_time FROM order_status_events WHERE order_id = ? AND status = 'delivered' ORDER BY event_time ASC\", (order_id,))\n        if rows:\n            return rows[0]  # (id, status, event_time)\n        return None\n    def get_pod(db_path: str, order_id: int) -> dict | None:\n        rows = safe_query(db_path, \"SELECT photo_url, photo_timestamp, photo_notes, recipient_signature_name FROM proof_of_delivery WHERE order_id = ?\", (order_id,))\n        if rows:\n            return {\n                \"photo_url\": rows[0][0],\n                \"photo_timestamp\": rows[0][1],\n                \"photo_notes\": rows[0][2],\n                \"recipient_signature_name\": rows[0][3]\n            }\n        return None\n    # Helper to validate time (accepts either string or full datetime)\n    def is_time_246pm(dt_string: str) -> bool:\n        if not dt_string or not isinstance(dt_string, str):\n            return False\n        # Accept either '2:46 PM' or datetime containing '14:46' or '2:46 PM'\n        # Typical format: 'YYYY-MM-DD HH:MM:SS'\n        m1 = re.search(r'\\b14:46\\b', dt_string)\n        m2 = re.search(r'\\b2:46 ?PM\\b', dt_string, re.IGNORECASE)\n        if m1 or m2:\n            return True\n        return False\n    # Main logic\n    external_ref = 'BB-10482'\n    order_id_init = get_order_id(initial_db_path, external_ref)\n    order_id_final = get_order_id(final_db_path, external_ref)\n    if not order_id_final:\n        return {\"result\": \"others\"}\n    # 1. Check status changed to delivered\n    rows_init = safe_query(initial_db_path, \"SELECT current_status FROM delivery_orders WHERE id = ?\", (order_id_final,))\n    rows_final = safe_query(final_db_path, \"SELECT current_status, updated_at FROM delivery_orders WHERE id = ?\", (order_id_final,))\n    if not rows_final or rows_final[0][0] != 'delivered':\n        return {\"result\": \"others\"}\n    if not rows_init or rows_init[0][0] == 'delivered': # Already delivered before\n        return {\"result\": \"others\"}\n    # 2. Check delivered status event present and new\n    event_init = delivered_status_event(initial_db_path, order_id_final)\n    event_final = delivered_status_event(final_db_path, order_id_final)\n    if event_final is None:\n        return {\"result\": \"others\"}\n    if event_init is not None: # Already had delivered event before\n        return {\"result\": \"others\"}\n    # Must check that event_time matches 2:46 PM\n    event_time_final = event_final[2] if len(event_final) > 2 else ''\n    if not is_time_246pm(str(event_time_final)):\n        return {\"result\": \"others\"}\n    # 3. Check proof_of_delivery is new and correct\n    pod_init = get_pod(initial_db_path, order_id_final)\n    pod_final = get_pod(final_db_path, order_id_final)\n    if pod_final is None:\n        return {\"result\": \"others\"}\n    if pod_init is not None: # Already POD exists\n        return {\"result\": \"others\"}\n    # Validate fields\n    expected_url = 'https://cdn.example.com/pod/bb-10482-1.jpg'\n    expected_notes = 'Left at front desk'\n    expected_sig = 'A. Patel'\n    if pod_final['photo_url'] != expected_url:\n        return {\"result\": \"others\"}\n    if pod_final['photo_notes'] != expected_notes:\n        return {\"result\": \"others\"}\n    if pod_final['recipient_signature_name'] != expected_sig:\n        return {\"result\": \"others\"}\n    # Accept photo_timestamp as either '2:46 PM' or datetime containing '14:46' or '2:46 PM'\n    pod_ts = pod_final['photo_timestamp']\n    if not is_time_246pm(str(pod_ts)):\n        return {\"result\": \"others\"}\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the task, we must confirm that (1) the order 'BB-10482' has been marked as delivered at 2:46 PM, (2) a proof-of-delivery record exists for this order containing the correct photo URL, timestamp ('2:46 PM'), notes ('Left at front desk'), and recipient signature name ('A. Patel'), and (3) these modifications are new relative to the initial database. The delivered timestamp must be 2:46 PM, either as a datetime or as a localized string. Due to the field definitions, the task is fully modification_based (not dependent on final_answer). We must defensively check for malformed/missing records, differences between initial and final states, and exact match of all required fields.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Order 'BB-10482' (order_id) status changed to 'delivered' in final database\",\n        \"A new 'delivered' status event for order_id is present in final database but not in initial database, with event_time matching 2:46 PM\",\n        \"A new proof_of_delivery record for order_id exists in final database but not in initial database\",\n        \"proof_of_delivery record for BB-10482 contains photo_url 'https://cdn.example.com/pod/bb-10482-1.jpg', photo_notes 'Left at front desk', recipient_signature_name 'A. Patel'\",\n        \"Timestamp in proof_of_delivery photo_timestamp or delivered status event must correspond to 2:46 PM\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    # Helper: get order_id from external_order_ref\\n    def get_order_id(db_path: str, external_order_ref: str) -> int | None:\\n        rows = safe_query(db_path, \\\"SELECT id FROM delivery_orders WHERE external_order_ref = ?\\\", (external_order_ref,))\\n        if rows and isinstance(rows[0][0], int):\\n            return rows[0][0]\\n        return None\\n    # Helper: check if delivered status exists\\n    def delivered_status_event(db_path: str, order_id: int) -> tuple | None:\\n        rows = safe_query(db_path, \\\"SELECT id, status, event_time FROM order_status_events WHERE order_id = ? AND status = 'delivered' ORDER BY event_time ASC\\\", (order_id,))\\n        if rows:\\n            return rows[0]  # (id, status, event_time)\\n        return None\\n    def get_pod(db_path: str, order_id: int) -> dict | None:\\n        rows = safe_query(db_path, \\\"SELECT photo_url, photo_timestamp, photo_notes, recipient_signature_name FROM proof_of_delivery WHERE order_id = ?\\\", (order_id,))\\n        if rows:\\n            return {\\n                \\\"photo_url\\\": rows[0][0],\\n                \\\"photo_timestamp\\\": rows[0][1],\\n                \\\"photo_notes\\\": rows[0][2],\\n                \\\"recipient_signature_name\\\": rows[0][3]\\n            }\\n        return None\\n    # Helper to validate time (accepts either string or full datetime)\\n    def is_time_246pm(dt_string: str) -> bool:\\n        if not dt_string or not isinstance(dt_string, str):\\n            return False\\n        # Accept either '2:46 PM' or datetime containing '14:46' or '2:46 PM'\\n        # Typical format: 'YYYY-MM-DD HH:MM:SS'\\n        m1 = re.search(r'\\\\b14:46\\\\b', dt_string)\\n        m2 = re.search(r'\\\\b2:46 ?PM\\\\b', dt_string, re.IGNORECASE)\\n        if m1 or m2:\\n            return True\\n        return False\\n    # Main logic\\n    external_ref = 'BB-10482'\\n    order_id_init = get_order_id(initial_db_path, external_ref)\\n    order_id_final = get_order_id(final_db_path, external_ref)\\n    if not order_id_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 1. Check status changed to delivered\\n    rows_init = safe_query(initial_db_path, \\\"SELECT current_status FROM delivery_orders WHERE id = ?\\\", (order_id_final,))\\n    rows_final = safe_query(final_db_path, \\\"SELECT current_status, updated_at FROM delivery_orders WHERE id = ?\\\", (order_id_final,))\\n    if not rows_final or rows_final[0][0] != 'delivered':\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not rows_init or rows_init[0][0] == 'delivered': # Already delivered before\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 2. Check delivered status event present and new\\n    event_init = delivered_status_event(initial_db_path, order_id_final)\\n    event_final = delivered_status_event(final_db_path, order_id_final)\\n    if event_final is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if event_init is not None: # Already had delivered event before\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Must check that event_time matches 2:46 PM\\n    event_time_final = event_final[2] if len(event_final) > 2 else ''\\n    if not is_time_246pm(str(event_time_final)):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 3. Check proof_of_delivery is new and correct\\n    pod_init = get_pod(initial_db_path, order_id_final)\\n    pod_final = get_pod(final_db_path, order_id_final)\\n    if pod_final is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if pod_init is not None: # Already POD exists\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Validate fields\\n    expected_url = 'https://cdn.example.com/pod/bb-10482-1.jpg'\\n    expected_notes = 'Left at front desk'\\n    expected_sig = 'A. Patel'\\n    if pod_final['photo_url'] != expected_url:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if pod_final['photo_notes'] != expected_notes:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if pod_final['recipient_signature_name'] != expected_sig:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Accept photo_timestamp as either '2:46 PM' or datetime containing '14:46' or '2:46 PM'\\n    pod_ts = pod_final['photo_timestamp']\\n    if not is_time_246pm(str(pod_ts)):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 8, "task": "Cancel order \"BB-10501\" with reason \"store_closed\" at 5:12 PM, issue a full refund of $38.60 to the customer, and record an internal note \"Location closed early due to power outage\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    import datetime\n\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Find the order_id for 'BB-10501' in final DB\n    order_rows = safe_query(final_db_path, \"SELECT id, current_status, canceled_at, cancel_reason FROM delivery_orders WHERE external_order_ref = ?\", (\"BB-10501\",))\n    if len(order_rows) != 1:\n        return {\"result\": \"others\"}\n    order_id, status, canceled_at, cancel_reason = order_rows[0]\n    # Check status 'canceled'\n    if status != \"canceled\":\n        return {\"result\": \"others\"}\n    # Check cancel_reason\n    if cancel_reason != \"store_closed\":\n        return {\"result\": \"others\"}\n    # Check canceled_at (datetime in 17:12 hour)\n    # Allow for 5 minute leeway, require at least correct hour/minute\n    if not canceled_at:\n        return {\"result\": \"others\"}\n    try:\n        dt = datetime.datetime.strptime(canceled_at, \"%Y-%m-%d %H:%M:%S\")\n        if not (dt.hour == 17 and 10 <= dt.minute <= 14):\n            return {\"result\": \"others\"}\n    except Exception:\n        return {\"result\": \"others\"}\n\n    # 2. Refund comparison: find all refund rows for this order in both dbs\n    initial_refunds = safe_query(initial_db_path, \"SELECT id, order_id, amount_cents, currency FROM refunds WHERE order_id = ?\", (order_id,))\n    final_refunds = safe_query(final_db_path, \"SELECT id, order_id, amount_cents, currency, reason FROM refunds WHERE order_id = ?\", (order_id,))\n    # Must be exactly one new full refund, 3860 cents USD\n    initial_ids = set(r[0] for r in initial_refunds)\n    new_refunds = [r for r in final_refunds if r[0] not in initial_ids]\n    if len(new_refunds) != 1:\n        return {\"result\": \"others\"}\n    refund = new_refunds[0]\n    if refund[2] != 3860 or (refund[3] or \"\").upper() != \"USD\":\n        return {\"result\": \"others\"}\n    # Any reason is permitted, but must be non-empty\n    if not refund[4] or refund[4].strip() == \"\":\n        return {\"result\": \"others\"}\n\n    # 3. Internal Note: Look for exact text (case-insensitive)\n    notes = safe_query(final_db_path, \"SELECT note FROM internal_notes WHERE entity_type = 'order' AND entity_id = ?\", (order_id,))\n    expected_note = \"Location closed early due to power outage\"\n    found = False\n    for n in notes:\n        if isinstance(n[0], str) and n[0].strip().lower() == expected_note.lower():\n            found = True\n            break\n    if not found:\n        return {\"result\": \"others\"}\n\n    # 4. Defensive: No ambiguous/partial data\n    # (already checked exact matches above)\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we need to ensure the agent: (1) canceled order 'BB-10501' with reason 'store_closed' at 5:12 PM (17:12), (2) issued a full refund of $38.60 to the customer linked to that order, and (3) recorded the internal note 'Location closed early due to power outage' against the order. This is a modification-based task, so database changes must match exactly. We must defensively check: the order's status and cancel fields, a matching refund record (amount, currency, reason, linkage), and presence of the correct internal note. All must be 100% satisfied in the final database compared to initial; if any element is missing or ambiguous, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Order 'BB-10501' is present in delivery_orders table and current_status='canceled'\",\n        \"canceled_at for 'BB-10501' is close to 2026-02-18 17:12:00 (allow a few minutes leeway, but requires 17:12 hour)\",\n        \"cancel_reason for 'BB-10501' is 'store_closed'\",\n        \"Exactly one new refund for this order since the initial DB, amount_cents=3860, currency='USD', reason is non-empty, refund linked to the same order id\",\n        \"An internal_notes row exists for entity_type='order', entity_id corresponding to 'BB-10501', with note exactly 'Location closed early due to power outage' (case-insensitive match allowed)\",\n        \"No partial/ambiguous records (e.g., partial refund, wrong note, status not canceled)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    import datetime\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Find the order_id for 'BB-10501' in final DB\\n    order_rows = safe_query(final_db_path, \\\"SELECT id, current_status, canceled_at, cancel_reason FROM delivery_orders WHERE external_order_ref = ?\\\", (\\\"BB-10501\\\",))\\n    if len(order_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order_id, status, canceled_at, cancel_reason = order_rows[0]\\n    # Check status 'canceled'\\n    if status != \\\"canceled\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check cancel_reason\\n    if cancel_reason != \\\"store_closed\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check canceled_at (datetime in 17:12 hour)\\n    # Allow for 5 minute leeway, require at least correct hour/minute\\n    if not canceled_at:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    try:\\n        dt = datetime.datetime.strptime(canceled_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        if not (dt.hour == 17 and 10 <= dt.minute <= 14):\\n            return {\\\"result\\\": \\\"others\\\"}\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Refund comparison: find all refund rows for this order in both dbs\\n    initial_refunds = safe_query(initial_db_path, \\\"SELECT id, order_id, amount_cents, currency FROM refunds WHERE order_id = ?\\\", (order_id,))\\n    final_refunds = safe_query(final_db_path, \\\"SELECT id, order_id, amount_cents, currency, reason FROM refunds WHERE order_id = ?\\\", (order_id,))\\n    # Must be exactly one new full refund, 3860 cents USD\\n    initial_ids = set(r[0] for r in initial_refunds)\\n    new_refunds = [r for r in final_refunds if r[0] not in initial_ids]\\n    if len(new_refunds) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    refund = new_refunds[0]\\n    if refund[2] != 3860 or (refund[3] or \\\"\\\").upper() != \\\"USD\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Any reason is permitted, but must be non-empty\\n    if not refund[4] or refund[4].strip() == \\\"\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Internal Note: Look for exact text (case-insensitive)\\n    notes = safe_query(final_db_path, \\\"SELECT note FROM internal_notes WHERE entity_type = 'order' AND entity_id = ?\\\", (order_id,))\\n    expected_note = \\\"Location closed early due to power outage\\\"\\n    found = False\\n    for n in notes:\\n        if isinstance(n[0], str) and n[0].strip().lower() == expected_note.lower():\\n            found = True\\n            break\\n    if not found:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Defensive: No ambiguous/partial data\\n    # (already checked exact matches above)\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "doordash_drive_delivery_tracking", "task_idx": 9, "task": "Create a customer support case for order \"BB-10490\" with channel \"chat\", customer message \"Driver marked delivered but I didn't receive it at 901 Howard St Apt 12\", set priority to \"high\", assign resolution code \"not_received\", and add an escalation note \"Check GPS drop point and POD photo; contact driver within 10 minutes\".", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    # Task constants\n    ORDER_EXTERNAL_REF = \"BB-10490\"\n    REQUIRED_CHANNEL = \"chat\"\n    REQUIRED_MESSAGE = \"Driver marked delivered but I didn't receive it at 901 Howard St Apt 12\"\n    REQUIRED_PRIORITY = \"high\"\n    REQUIRED_RESOLUTION_CODE = \"not_received\"\n    REQUIRED_NOTE_SUBSTR = \"Check GPS drop point and POD photo; contact driver within 10 minutes\"\n\n    # Helper to safely query database\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Step 1: Resolve order_id for 'BB-10490' in both DBs (should be 105, but defensive)\n    def get_order_id(db_path):\n        rows = safe_query(db_path, \"SELECT id FROM delivery_orders WHERE external_order_ref=?\", (ORDER_EXTERNAL_REF,))\n        return rows[0][0] if rows else None\n    order_id_init = get_order_id(initial_db_path)\n    order_id_final = get_order_id(final_db_path)\n    if not order_id_init or not order_id_final or order_id_init != order_id_final:\n        return {\"result\": \"others\"}\n    order_id = order_id_final\n\n    # Step 2: Find support cases for this order in both DBs\n    def get_cases(db_path):\n        # (id, channel, customer_message, priority, resolution_code, status, created_by_user_id, assigned_to_user_id, created_at, updated_at)\n        q = \"SELECT id, channel, customer_message, priority, resolution_code FROM support_cases WHERE order_id=?\"\n        return safe_query(db_path, q, (order_id,))\n    cases_init = get_cases(initial_db_path)\n    cases_final = get_cases(final_db_path)\n\n    # Find the new support_case(s) (those in final but not in initial by id)\n    init_ids = set(row[0] for row in cases_init)\n    final_ids = set(row[0] for row in cases_final)\n    new_case_ids = final_ids - init_ids\n    # Must be exactly one new case\n    if len(new_case_ids) != 1:\n        return {\"result\": \"others\"}\n    new_case_id = list(new_case_ids)[0]\n    # Fetch the full new row\n    row = [row for row in cases_final if row[0] == new_case_id][0]\n    _, channel, customer_message, priority, resolution_code = row\n    # Check all fields for strict match\n    if str(channel) != REQUIRED_CHANNEL:\n        return {\"result\": \"others\"}\n    if str(customer_message) != REQUIRED_MESSAGE:\n        return {\"result\": \"others\"}\n    if str(priority) != REQUIRED_PRIORITY:\n        return {\"result\": \"others\"}\n    if str(resolution_code) != REQUIRED_RESOLUTION_CODE:\n        return {\"result\": \"others\"}\n\n    # Step 3: There must be a new note for this case with required escalation note (substring, case-insensitive)\n    def get_notes(db_path, case_id):\n        # (id, case_id, author_user_id, note, created_at)\n        return safe_query(db_path, \"SELECT id, note FROM support_case_notes WHERE case_id=?\", (case_id,))\n    notes_init = get_notes(initial_db_path, new_case_id)\n    notes_final = get_notes(final_db_path, new_case_id)\n    init_ids2 = set(row[0] for row in notes_init)\n    final_ids2 = set(row[0] for row in notes_final)\n    new_note_ids = final_ids2 - init_ids2\n    if not new_note_ids:\n        return {\"result\": \"others\"}\n    # There may be >1 note, any must match\n    found = False\n    pattern = re.escape(REQUIRED_NOTE_SUBSTR)\n    for row in notes_final:\n        if row[0] in new_note_ids:\n            note = str(row[1]) if row[1] is not None else ''\n            if re.search(pattern, note, re.IGNORECASE):\n                found = True\n                break\n    if not found:\n        return {\"result\": \"others\"}\n\n    # Ensure no extra support_case for this order was added (should have only one new one)\n    # (already checked above with len(new_case_ids)==1)\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This is a pure database modification task: the agent must create a customer support case for order 'BB-10490' (delivery_orders.id=105), with channel 'chat', customer message \\\"Driver marked delivered but I didn't receive it at 901 Howard St Apt 12\\\", priority 'high', resolution code 'not_received', and add an escalation note \\\"Check GPS drop point and POD photo; contact driver within 10 minutes\\\". None of these records exist initially (no support case for order 105 or such note). Task completion is 100% if and only if: (1) exactly one NEW support_cases row for order_id=105 with all required fields, and (2) a NEW support_case_notes note for that support_case whose text matches or contains the escalation instructions. All relationships/fields must be exact; partial, duplicate, or missing records mean task is NOT complete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find all support_cases for order_id=105 in initial and final DBs. There must be exactly one more in the final DB.\",\n        \"The new support_case row must have: channel='chat', customer_message exactly as specified, priority='high', resolution_code='not_received'.\",\n        \"A new support_case_notes row must be present (not in initial DB) with case_id of new support_case, and note containing 'Check GPS drop point and POD photo; contact driver within 10 minutes' (case-insensitive substring match).\",\n        \"No extra or duplicate support_cases for order_id=105 added.\",\n        \"All checks must pass for result to be 'complete'.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    # Task constants\\n    ORDER_EXTERNAL_REF = \\\"BB-10490\\\"\\n    REQUIRED_CHANNEL = \\\"chat\\\"\\n    REQUIRED_MESSAGE = \\\"Driver marked delivered but I didn't receive it at 901 Howard St Apt 12\\\"\\n    REQUIRED_PRIORITY = \\\"high\\\"\\n    REQUIRED_RESOLUTION_CODE = \\\"not_received\\\"\\n    REQUIRED_NOTE_SUBSTR = \\\"Check GPS drop point and POD photo; contact driver within 10 minutes\\\"\\n\\n    # Helper to safely query database\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Step 1: Resolve order_id for 'BB-10490' in both DBs (should be 105, but defensive)\\n    def get_order_id(db_path):\\n        rows = safe_query(db_path, \\\"SELECT id FROM delivery_orders WHERE external_order_ref=?\\\", (ORDER_EXTERNAL_REF,))\\n        return rows[0][0] if rows else None\\n    order_id_init = get_order_id(initial_db_path)\\n    order_id_final = get_order_id(final_db_path)\\n    if not order_id_init or not order_id_final or order_id_init != order_id_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order_id = order_id_final\\n\\n    # Step 2: Find support cases for this order in both DBs\\n    def get_cases(db_path):\\n        # (id, channel, customer_message, priority, resolution_code, status, created_by_user_id, assigned_to_user_id, created_at, updated_at)\\n        q = \\\"SELECT id, channel, customer_message, priority, resolution_code FROM support_cases WHERE order_id=?\\\"\\n        return safe_query(db_path, q, (order_id,))\\n    cases_init = get_cases(initial_db_path)\\n    cases_final = get_cases(final_db_path)\\n\\n    # Find the new support_case(s) (those in final but not in initial by id)\\n    init_ids = set(row[0] for row in cases_init)\\n    final_ids = set(row[0] for row in cases_final)\\n    new_case_ids = final_ids - init_ids\\n    # Must be exactly one new case\\n    if len(new_case_ids) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_case_id = list(new_case_ids)[0]\\n    # Fetch the full new row\\n    row = [row for row in cases_final if row[0] == new_case_id][0]\\n    _, channel, customer_message, priority, resolution_code = row\\n    # Check all fields for strict match\\n    if str(channel) != REQUIRED_CHANNEL:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if str(customer_message) != REQUIRED_MESSAGE:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if str(priority) != REQUIRED_PRIORITY:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if str(resolution_code) != REQUIRED_RESOLUTION_CODE:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: There must be a new note for this case with required escalation note (substring, case-insensitive)\\n    def get_notes(db_path, case_id):\\n        # (id, case_id, author_user_id, note, created_at)\\n        return safe_query(db_path, \\\"SELECT id, note FROM support_case_notes WHERE case_id=?\\\", (case_id,))\\n    notes_init = get_notes(initial_db_path, new_case_id)\\n    notes_final = get_notes(final_db_path, new_case_id)\\n    init_ids2 = set(row[0] for row in notes_init)\\n    final_ids2 = set(row[0] for row in notes_final)\\n    new_note_ids = final_ids2 - init_ids2\\n    if not new_note_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # There may be >1 note, any must match\\n    found = False\\n    pattern = re.escape(REQUIRED_NOTE_SUBSTR)\\n    for row in notes_final:\\n        if row[0] in new_note_ids:\\n            note = str(row[1]) if row[1] is not None else ''\\n            if re.search(pattern, note, re.IGNORECASE):\\n                found = True\\n                break\\n    if not found:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Ensure no extra support_case for this order was added (should have only one new one)\\n    # (already checked above with len(new_case_ids)==1)\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 0, "task": "Create a new vehicle asset with VIN '1FTFW1E50JFB12345', name 'Truck-12', license plate 'CA-8XK219', current odometer 48210 miles, and engine hours 2150.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Task expects user_id=1 according to initial_db content\n    user_id = 1\n    vin = '1FTFW1E50JFB12345'\n    name = 'Truck-12'\n    license_plate = 'CA-8XK219'\n    odometer = 48210\n    engine_hours = 2150.0\n\n    vehicle_match_query = (\n        \"SELECT id FROM vehicles WHERE user_id = ? AND vin = ? AND name = ? AND license_plate = ? \"\n        \"AND odometer_miles = ? AND engine_hours = ?\"\n    )\n    params = (user_id, vin, name, license_plate, odometer, engine_hours)\n\n    # Count in initial DB\n    initial_rows = safe_query(initial_db_path, vehicle_match_query, params)\n    initial_count = len(initial_rows)\n\n    # Count in final DB\n    final_rows = safe_query(final_db_path, vehicle_match_query, params)\n    final_count = len(final_rows)\n\n    if final_count == initial_count + 1:\n        return {\"result\": \"complete\"}\n    return {\"result\": \"others\"}\n", "raw_response": "{\n    \"reasoning\": \"The task is to create a new vehicle asset with VIN '1FTFW1E50JFB12345', name 'Truck-12', license plate 'CA-8XK219', current odometer 48210 miles, and engine hours 2150. This is a creation/modification task. To verify completion, we must check if a new vehicle with all the exact specified properties was inserted into the vehicles table in the final database, and that this record did not exist in the initial database or was not inserted as a duplicate (i.e., the task did not just leave the database unchanged). However, inspecting the initial state, the vehicle with all requested fields (matching VIN, name, license plate, odometer, engine hours, user_id) already exists in the initial state (id=1, user_id=1). Therefore, to be certain the agent 'created' a new asset, there must be a new, additional row (not just unchanged existing row), with exactly the same values. If the count of matching vehicles is the same between initial and final, most likely no new asset was created (since the initial already had the required asset). If a new duplicate row has been added, this must be detected by a count increase in the final DB for that VIN/name/license_plate/odometer/engine_hours/user_id combination. If not, the operation was not performed, or was performed incorrectly. The only way to be 100% certain of successful completion is if the count of matching vehicle records increased by exactly 1 in the final DB as compared to the initial. Otherwise, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Count the number of vehicles in the initial database with the exact values: user_id=1, vin='1FTFW1E50JFB12345', name='Truck-12', license_plate='CA-8XK219', odometer_miles=48210, engine_hours=2150\",\n        \"Count the number of such vehicles in the final database\",\n        \"If the final count is exactly one greater than the initial count, return complete\",\n        \"Otherwise (including unchanged DB, multiple/duplicate additions, data errors), return others\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Task expects user_id=1 according to initial_db content\\n    user_id = 1\\n    vin = '1FTFW1E50JFB12345'\\n    name = 'Truck-12'\\n    license_plate = 'CA-8XK219'\\n    odometer = 48210\\n    engine_hours = 2150.0\\n\\n    vehicle_match_query = (\\n        \\\"SELECT id FROM vehicles WHERE user_id = ? AND vin = ? AND name = ? AND license_plate = ? \\\"\\n        \\\"AND odometer_miles = ? AND engine_hours = ?\\\"\\n    )\\n    params = (user_id, vin, name, license_plate, odometer, engine_hours)\\n\\n    # Count in initial DB\\n    initial_rows = safe_query(initial_db_path, vehicle_match_query, params)\\n    initial_count = len(initial_rows)\\n\\n    # Count in final DB\\n    final_rows = safe_query(final_db_path, vehicle_match_query, params)\\n    final_count = len(final_rows)\\n\\n    if final_count == initial_count + 1:\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    return {\\\"result\\\": \\\"others\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 1, "task": "Assign driver 'Maria Lopez' (employeeId 'D-1042') to vehicle 'Truck-12' effective from '2026-02-18T08:00:00-08:00' with no end date.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # --- 1. Get driver_id for Maria Lopez (employeeId 'D-1042') ---\n    driver_rows = safe_query(final_db_path, \"SELECT id, user_id FROM drivers WHERE full_name = ? AND employee_id = ?\", (\"Maria Lopez\", \"D-1042\"))\n    if len(driver_rows) != 1:\n        return {\"result\": \"others\"}\n    driver_id, driver_user_id = driver_rows[0]\n\n    # Confirm driver's existence and user_id agreement\n    driver_rows_init = safe_query(initial_db_path, \"SELECT id, user_id FROM drivers WHERE full_name = ? AND employee_id = ?\", (\"Maria Lopez\", \"D-1042\"))\n    if len(driver_rows_init) != 1:\n        return {\"result\": \"others\"}\n    driver_id_init, driver_user_id_init = driver_rows_init[0]\n    if driver_id != driver_id_init or driver_user_id != driver_user_id_init:\n        return {\"result\": \"others\"}\n\n    # --- 2. Get vehicle_id for Truck-12 ---\n    vehicle_rows = safe_query(final_db_path, \"SELECT id, user_id FROM vehicles WHERE name = ?\", (\"Truck-12\",))\n    if len(vehicle_rows) != 1:\n        return {\"result\": \"others\"}\n    vehicle_id, vehicle_user_id = vehicle_rows[0]\n\n    vehicle_rows_init = safe_query(initial_db_path, \"SELECT id, user_id FROM vehicles WHERE name = ?\", (\"Truck-12\",))\n    if len(vehicle_rows_init) != 1:\n        return {\"result\": \"others\"}\n    vehicle_id_init, vehicle_user_id_init = vehicle_rows_init[0]\n    if vehicle_id != vehicle_id_init or vehicle_user_id != vehicle_user_id_init:\n        return {\"result\": \"others\"}\n\n    # --- 3. user_id should match for driver and vehicle assignment ---\n    if driver_user_id != vehicle_user_id:\n        return {\"result\": \"others\"}\n    user_id = driver_user_id\n\n    # --- 4. Look for assignment (AFTER database) ---\n    q = \"\"\"\n        SELECT id, user_id, vehicle_id, driver_id, effective_start_at, effective_end_at FROM vehicle_driver_assignments\n        WHERE user_id=? AND vehicle_id=? AND driver_id=? AND effective_start_at=? AND effective_end_at IS NULL\n    \"\"\"\n    assignment_rows_final = safe_query(final_db_path, q, (user_id, vehicle_id, driver_id, '2026-02-18T08:00:00-08:00'))\n    if len(assignment_rows_final) != 1:\n        return {\"result\": \"others\"}\n    assignment_id = assignment_rows_final[0][0]\n\n    # --- 5. Ensure this exact assignment did NOT exist in BEFORE database ---\n    assignment_rows_init = safe_query(initial_db_path, q, (user_id, vehicle_id, driver_id, '2026-02-18T08:00:00-08:00'))\n    if len(assignment_rows_init) > 0:\n        return {\"result\": \"others\"}\n\n    # --- 6. Uniqueness: No more than one new such assignment created ---\n    # Make sure no duplicate assignments with same values were added\n    # Check if there are multiple in AFTER (already above), so just check none others\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task requires assigning driver 'Maria Lopez' (employeeId 'D-1042') to vehicle 'Truck-12' with an assignment effective from '2026-02-18T08:00:00-08:00' and with no end date. To be 100% certain, the following must be true in the final DB: (1) a new row must exist in the vehicle_driver_assignments table in the AFTER database, but NOT in the BEFORE database, with: correct user_id for both the driver and vehicle, correct driver_id (for D-1042/Maria Lopez), correct vehicle_id (for Truck-12), an effective_start_at equal to '2026-02-18T08:00:00-08:00', and effective_end_at IS NULL. All other fields must be valid per schema requirements. The check must confirm exactly ONE such new record exists (not multiple) and that it was not present before. Edge cases like duplicate assignments, incorrect IDs, wrong times, or mismatched vehicles/drivers must all result in failure.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find driver_id for Maria Lopez (employeeId 'D-1042') and vehicle_id for 'Truck-12' in both DBs\",\n        \"Check that in the AFTER DB, exactly one vehicle_driver_assignments row exists with: user_id, vehicle_id, driver_id matching, effective_start_at = '2026-02-18T08:00:00-08:00', effective_end_at IS NULL\",\n        \"Confirm this assignment row does NOT exist in the BEFORE DB\",\n        \"Ensure there are NO duplicate or extra similar assignments created\",\n        \"Confirm data integrity: user_id must match between driver and vehicle, values must be consistent\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # --- 1. Get driver_id for Maria Lopez (employeeId 'D-1042') ---\\n    driver_rows = safe_query(final_db_path, \\\"SELECT id, user_id FROM drivers WHERE full_name = ? AND employee_id = ?\\\", (\\\"Maria Lopez\\\", \\\"D-1042\\\"))\\n    if len(driver_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    driver_id, driver_user_id = driver_rows[0]\\n\\n    # Confirm driver's existence and user_id agreement\\n    driver_rows_init = safe_query(initial_db_path, \\\"SELECT id, user_id FROM drivers WHERE full_name = ? AND employee_id = ?\\\", (\\\"Maria Lopez\\\", \\\"D-1042\\\"))\\n    if len(driver_rows_init) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    driver_id_init, driver_user_id_init = driver_rows_init[0]\\n    if driver_id != driver_id_init or driver_user_id != driver_user_id_init:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 2. Get vehicle_id for Truck-12 ---\\n    vehicle_rows = safe_query(final_db_path, \\\"SELECT id, user_id FROM vehicles WHERE name = ?\\\", (\\\"Truck-12\\\",))\\n    if len(vehicle_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id, vehicle_user_id = vehicle_rows[0]\\n\\n    vehicle_rows_init = safe_query(initial_db_path, \\\"SELECT id, user_id FROM vehicles WHERE name = ?\\\", (\\\"Truck-12\\\",))\\n    if len(vehicle_rows_init) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id_init, vehicle_user_id_init = vehicle_rows_init[0]\\n    if vehicle_id != vehicle_id_init or vehicle_user_id != vehicle_user_id_init:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 3. user_id should match for driver and vehicle assignment ---\\n    if driver_user_id != vehicle_user_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    user_id = driver_user_id\\n\\n    # --- 4. Look for assignment (AFTER database) ---\\n    q = \\\"\\\"\\\"\\n        SELECT id, user_id, vehicle_id, driver_id, effective_start_at, effective_end_at FROM vehicle_driver_assignments\\n        WHERE user_id=? AND vehicle_id=? AND driver_id=? AND effective_start_at=? AND effective_end_at IS NULL\\n    \\\"\\\"\\\"\\n    assignment_rows_final = safe_query(final_db_path, q, (user_id, vehicle_id, driver_id, '2026-02-18T08:00:00-08:00'))\\n    if len(assignment_rows_final) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    assignment_id = assignment_rows_final[0][0]\\n\\n    # --- 5. Ensure this exact assignment did NOT exist in BEFORE database ---\\n    assignment_rows_init = safe_query(initial_db_path, q, (user_id, vehicle_id, driver_id, '2026-02-18T08:00:00-08:00'))\\n    if len(assignment_rows_init) > 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- 6. Uniqueness: No more than one new such assignment created ---\\n    # Make sure no duplicate assignments with same values were added\\n    # Check if there are multiple in AFTER (already above), so just check none others\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 2, "task": "Create a geofence named 'Oakland Yard' as a circular zone centered at (37.8044, -122.2711) with a 300-meter radius and enable enter/exit alerts for vehicle 'Truck-12'.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Check for geofence in final DB\n    geofence_query = '''SELECT id, user_id, name, type, center_lat, center_lng, radius_meters FROM geofences WHERE name = ? AND type = 'circle' AND center_lat IS NOT NULL AND center_lng IS NOT NULL AND radius_meters IS NOT NULL'''\n    geofence_rows_final = safe_query(final_db_path, geofence_query, ('Oakland Yard',))\n    # Find exact match for center and radius\n    matched_geofence_id = None\n    matched_user_id = None\n    for row in geofence_rows_final:\n        geofence_id, user_id, name, type_, lat, lng, radius = row\n        # Strict float match, tolerate minimal rounding differences\n        if abs(lat - 37.8044) < 1e-4 and abs(lng + 122.2711) < 1e-4 and abs(radius - 300.0) < 1e-2:\n            matched_geofence_id = geofence_id\n            matched_user_id = user_id\n            break\n    if matched_geofence_id is None or matched_user_id is None:\n        return {\"result\": \"others\"}\n\n    # Check existence in initial DB (to know whether it was newly created or already present)\n    geofence_rows_initial = safe_query(initial_db_path, geofence_query, ('Oakland Yard',))\n    initial_has_geofence = False\n    for row in geofence_rows_initial:\n        _, _, _, _, lat, lng, radius = row\n        if abs(lat - 37.8044) < 1e-4 and abs(lng + 122.2711) < 1e-4 and abs(radius - 300.0) < 1e-2:\n            initial_has_geofence = True\n            break\n    # Even if it was already present, alerts must be set for Truck-12\n\n    # Get vehicle_id for 'Truck-12' in final DB\n    vehicle_row = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name = ?\", ('Truck-12',))\n    if not vehicle_row or not isinstance(vehicle_row[0][0], int):\n        return {\"result\": \"others\"}\n    vehicle_id = vehicle_row[0][0]\n\n    # Check geofence_alert_rules in final DB\n    alert_rule_query = '''SELECT id, user_id, geofence_id, vehicle_id, alert_on_enter, alert_on_exit, enabled FROM geofence_alert_rules WHERE user_id = ? AND geofence_id = ? AND vehicle_id = ?''' \n    alert_rule_rows_final = safe_query(final_db_path, alert_rule_query, (matched_user_id, matched_geofence_id, vehicle_id))\n    alert_rule_ok = False\n    for row in alert_rule_rows_final:\n        _, _, _, _, enter, exit_, enabled = row\n        if enter == 1 and exit_ == 1 and enabled == 1:\n            alert_rule_ok = True\n            break\n    if not alert_rule_ok:\n        return {\"result\": \"others\"}\n\n    # Check geofence_alert_rules in initial DB\n    alert_rule_rows_initial = safe_query(initial_db_path, alert_rule_query, (matched_user_id, matched_geofence_id, vehicle_id))\n    alert_rule_initial_ok = False\n    for row in alert_rule_rows_initial:\n        _, _, _, _, enter, exit_, enabled = row\n        if enter == 1 and exit_ == 1 and enabled == 1:\n            alert_rule_initial_ok = True\n            break\n    # Accept completion if alert rule exists in final DB, even if already present initially (task is not about creating, just enabling)\n\n    # Defensive: if multiple geofences found, only accept exact matching one\n    # Defensive: if vehicle_id is missing or ambiguous, fail\n    # Defensive: malformed/missing records = fail\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify whether the agent completed the task, we must: 1) confirm that a geofence named 'Oakland Yard' as a circular zone with center (37.8044, -122.2711) and radius 300 meters was created or already exists in the final database; 2) verify that enter/exit alerts for vehicle 'Truck-12' are enabled for this geofence. We must ensure these checks are modification-based, as they require cross-checking changes between the initial and final database states, and that both conditions are met exactly with correct values and relationships. Edge cases, such as multiple geofences with similar names, missing vehicle records, or non-matching alert rules, must be rigorously excluded. If any element is missing or ambiguous, we return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Check that there is a geofence named 'Oakland Yard', type 'circle', centered at (37.8044, -122.2711) with radius 300 meters in final database.\",\n        \"Compare geofence records in initial and final databases to ensure this geofence exists (created or already present).\",\n        \"Ensure the vehicle 'Truck-12' exists in the final database, and get its vehicle_id.\",\n        \"Verify there is a geofence_alert_rules record in the final database for the user, geofence_id (Oakland Yard), and vehicle_id (Truck-12), with alert_on_enter=1, alert_on_exit=1, enabled=1.\",\n        \"Compare geofence_alert_rules records in initial and final database to ensure the rule exists (created or already present).\",\n        \"Handle missing/malformed data gracefully and exclude partial matches.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Check for geofence in final DB\\n    geofence_query = '''SELECT id, user_id, name, type, center_lat, center_lng, radius_meters FROM geofences WHERE name = ? AND type = 'circle' AND center_lat IS NOT NULL AND center_lng IS NOT NULL AND radius_meters IS NOT NULL'''\\n    geofence_rows_final = safe_query(final_db_path, geofence_query, ('Oakland Yard',))\\n    # Find exact match for center and radius\\n    matched_geofence_id = None\\n    matched_user_id = None\\n    for row in geofence_rows_final:\\n        geofence_id, user_id, name, type_, lat, lng, radius = row\\n        # Strict float match, tolerate minimal rounding differences\\n        if abs(lat - 37.8044) < 1e-4 and abs(lng + 122.2711) < 1e-4 and abs(radius - 300.0) < 1e-2:\\n            matched_geofence_id = geofence_id\\n            matched_user_id = user_id\\n            break\\n    if matched_geofence_id is None or matched_user_id is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check existence in initial DB (to know whether it was newly created or already present)\\n    geofence_rows_initial = safe_query(initial_db_path, geofence_query, ('Oakland Yard',))\\n    initial_has_geofence = False\\n    for row in geofence_rows_initial:\\n        _, _, _, _, lat, lng, radius = row\\n        if abs(lat - 37.8044) < 1e-4 and abs(lng + 122.2711) < 1e-4 and abs(radius - 300.0) < 1e-2:\\n            initial_has_geofence = True\\n            break\\n    # Even if it was already present, alerts must be set for Truck-12\\n\\n    # Get vehicle_id for 'Truck-12' in final DB\\n    vehicle_row = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name = ?\\\", ('Truck-12',))\\n    if not vehicle_row or not isinstance(vehicle_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vehicle_row[0][0]\\n\\n    # Check geofence_alert_rules in final DB\\n    alert_rule_query = '''SELECT id, user_id, geofence_id, vehicle_id, alert_on_enter, alert_on_exit, enabled FROM geofence_alert_rules WHERE user_id = ? AND geofence_id = ? AND vehicle_id = ?''' \\n    alert_rule_rows_final = safe_query(final_db_path, alert_rule_query, (matched_user_id, matched_geofence_id, vehicle_id))\\n    alert_rule_ok = False\\n    for row in alert_rule_rows_final:\\n        _, _, _, _, enter, exit_, enabled = row\\n        if enter == 1 and exit_ == 1 and enabled == 1:\\n            alert_rule_ok = True\\n            break\\n    if not alert_rule_ok:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check geofence_alert_rules in initial DB\\n    alert_rule_rows_initial = safe_query(initial_db_path, alert_rule_query, (matched_user_id, matched_geofence_id, vehicle_id))\\n    alert_rule_initial_ok = False\\n    for row in alert_rule_rows_initial:\\n        _, _, _, _, enter, exit_, enabled = row\\n        if enter == 1 and exit_ == 1 and enabled == 1:\\n            alert_rule_initial_ok = True\\n            break\\n    # Accept completion if alert rule exists in final DB, even if already present initially (task is not about creating, just enabling)\\n\\n    # Defensive: if multiple geofences found, only accept exact matching one\\n    # Defensive: if vehicle_id is missing or ambiguous, fail\\n    # Defensive: malformed/missing records = fail\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 3, "task": "Configure safety thresholds for vehicle 'Truck-12' to trigger an alert when speeding exceeds 70 mph for 30 seconds and when idling exceeds 8 minutes, and set alert severity to 'medium'.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Step 1. Get vehicle_id for 'Truck-12' (user_id==1)\n    vehicle_row = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name = ? AND user_id = ?\", (\"Truck-12\", 1))\n    if not vehicle_row or not isinstance(vehicle_row, list) or len(vehicle_row) != 1:\n        return {\"result\": \"others\"}\n    vehicle_id = vehicle_row[0][0]\n    # Step 2. Confirm in initial db the record did NOT already exist\n    initial_check = safe_query(\n        initial_db_path,\n        \"SELECT id FROM vehicle_safety_settings WHERE vehicle_id = ? AND user_id = ? AND enabled = 1 AND \"\n        \"ABS(speeding_threshold_mph - ?) < 1e-5 AND speeding_min_duration_seconds = ? AND idling_threshold_minutes = ? AND severity = ?\",\n        (vehicle_id, 1, 70.0, 30, 8, 'medium')\n    )\n    if isinstance(initial_check, list) and len(initial_check) > 0:\n        return {\"result\": \"others\"}  # already set, agent did not do new work\n    # Step 3. Confirm in final db the correct record EXISTS\n    final_records = safe_query(\n        final_db_path,\n        \"SELECT speeding_threshold_mph, speeding_min_duration_seconds, idling_threshold_minutes, severity, enabled FROM vehicle_safety_settings \"\n        \"WHERE vehicle_id = ? AND user_id = ?\",\n        (vehicle_id, 1)\n    )\n    if not final_records or not isinstance(final_records, list):\n        return {\"result\": \"others\"}\n    # There must be exactly ONE enabled record with all the strict settings. Ignore disabled records.\n    found = False\n    for rec in final_records:\n        # rec: (speeding_threshold_mph, speeding_min_duration_seconds, idling_threshold_minutes, severity, enabled)\n        try:\n            s_mph = rec[0]\n            s_sec = rec[1]\n            i_min = rec[2]\n            severity = rec[3]\n            enabled = rec[4]\n            # Defensive: skip disabled, NULL/missing\n            if enabled != 1:\n                continue\n            if s_mph is None or s_sec is None or i_min is None or severity is None:\n                continue\n            if abs(float(s_mph) - 70.0) > 1e-5:\n                continue\n            if int(s_sec) != 30:\n                continue\n            if int(i_min) != 8:\n                continue\n            if severity != 'medium':\n                continue\n            # All good\n            if found:  # more than one matching record: ambiguous\n                return {\"result\": \"others\"}\n            found = True\n        except Exception:\n            continue\n    if found:\n        return {\"result\": \"complete\"}\n    return {\"result\": \"others\"}\n", "raw_response": "{\n    \"reasoning\": \"The user task requests configuring safety thresholds for vehicle 'Truck-12' such that (1) an alert triggers when speeding exceeds 70 mph for 30 seconds, (2) an alert triggers when idling exceeds 8 minutes, and (3) the alert severity is set to 'medium'. This is a strict modification task. The verification requires confirming that the 'vehicle_safety_settings' record for 'Truck-12' (pre-existing or inserted/modified) matches exactly: speeding_threshold_mph=70.0, speeding_min_duration_seconds=30, idling_threshold_minutes=8, severity='medium', enabled=1. We must verify (a) the initial database did NOT already have these settings for 'Truck-12', and (b) the final database DOES, with no accidental off-by-one errors, type mismatches, or alternative vehicle updates. Defensive programming is required in case of missing vehicles, duplicate records, or wrong vehicle. No check is needed on any alerts actually triggered, just the configuration, since these reflect thresholds. The final_answer is ignored unless the prompt requests a textual confirmation. Only when the final state has exactly one record for 'Truck-12', user 1, enabled, and with the proper values, and the initial state does NOT, do we return complete. Any ambiguity, error, or lack of evidence is 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Get the vehicle_id for 'Truck-12' from the 'vehicles' table (must exist, match user_id 1)\",\n        \"Verify that in the initial database there is NOT an enabled ('enabled'==1) 'vehicle_safety_settings' record for that vehicle with exactly: speeding_threshold_mph=70.0, speeding_min_duration_seconds=30, idling_threshold_minutes=8, severity='medium'\",\n        \"Verify that in the final database there is exactly one enabled 'vehicle_safety_settings' record for that vehicle with all of: speeding_threshold_mph=70.0, speeding_min_duration_seconds=30, idling_threshold_minutes=8, severity='medium', user_id=1, enabled=1\",\n        \"Handle cases where vehicle is missing, multiple records, or fields are malformed/NULL\",\n        \"Ensure there are no off-by-one, type, or partial-set errors (all settings must match exactly)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Step 1. Get vehicle_id for 'Truck-12' (user_id==1)\\n    vehicle_row = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name = ? AND user_id = ?\\\", (\\\"Truck-12\\\", 1))\\n    if not vehicle_row or not isinstance(vehicle_row, list) or len(vehicle_row) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vehicle_row[0][0]\\n    # Step 2. Confirm in initial db the record did NOT already exist\\n    initial_check = safe_query(\\n        initial_db_path,\\n        \\\"SELECT id FROM vehicle_safety_settings WHERE vehicle_id = ? AND user_id = ? AND enabled = 1 AND \\\"\\n        \\\"ABS(speeding_threshold_mph - ?) < 1e-5 AND speeding_min_duration_seconds = ? AND idling_threshold_minutes = ? AND severity = ?\\\",\\n        (vehicle_id, 1, 70.0, 30, 8, 'medium')\\n    )\\n    if isinstance(initial_check, list) and len(initial_check) > 0:\\n        return {\\\"result\\\": \\\"others\\\"}  # already set, agent did not do new work\\n    # Step 3. Confirm in final db the correct record EXISTS\\n    final_records = safe_query(\\n        final_db_path,\\n        \\\"SELECT speeding_threshold_mph, speeding_min_duration_seconds, idling_threshold_minutes, severity, enabled FROM vehicle_safety_settings \\\"\\n        \\\"WHERE vehicle_id = ? AND user_id = ?\\\",\\n        (vehicle_id, 1)\\n    )\\n    if not final_records or not isinstance(final_records, list):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # There must be exactly ONE enabled record with all the strict settings. Ignore disabled records.\\n    found = False\\n    for rec in final_records:\\n        # rec: (speeding_threshold_mph, speeding_min_duration_seconds, idling_threshold_minutes, severity, enabled)\\n        try:\\n            s_mph = rec[0]\\n            s_sec = rec[1]\\n            i_min = rec[2]\\n            severity = rec[3]\\n            enabled = rec[4]\\n            # Defensive: skip disabled, NULL/missing\\n            if enabled != 1:\\n                continue\\n            if s_mph is None or s_sec is None or i_min is None or severity is None:\\n                continue\\n            if abs(float(s_mph) - 70.0) > 1e-5:\\n                continue\\n            if int(s_sec) != 30:\\n                continue\\n            if int(i_min) != 8:\\n                continue\\n            if severity != 'medium':\\n                continue\\n            # All good\\n            if found:  # more than one matching record: ambiguous\\n                return {\\\"result\\\": \\\"others\\\"}\\n            found = True\\n        except Exception:\\n            continue\\n    if found:\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    return {\\\"result\\\": \\\"others\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 4, "task": "Simulate a completed trip for 'Truck-12' driven by 'Maria Lopez' starting '2026-02-17T06:10:00-08:00' in San Jose (37.3382, -121.8863) and ending '2026-02-17T08:05:00-08:00' in Oakland (37.8044, -122.2711) with an 18-point GPS trace, average speed 52 mph, max speed 78 mph, and 2 speeding events.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    # Defensive DB query helper\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Get Maria Lopez's driver_id and Truck-12's vehicle_id in both DBs\n    driver_row = safe_query(final_db_path, \"SELECT id FROM drivers WHERE full_name = ?\", (\"Maria Lopez\",))\n    if not driver_row or not isinstance(driver_row[0][0], int):\n        return {\"result\": \"others\"}\n    driver_id = driver_row[0][0]\n\n    vehicle_row = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name = ?\", (\"Truck-12\",))\n    if not vehicle_row or not isinstance(vehicle_row[0][0], int):\n        return {\"result\": \"others\"}\n    vehicle_id = vehicle_row[0][0]\n\n    # 2. Create set of (id, start_at, end_at) for trips in initial and final DB\n    initial_trips = set(safe_query(\n        initial_db_path,\n        \"SELECT id, start_at, end_at FROM trips WHERE vehicle_id = ? AND driver_id = ?\",\n        (vehicle_id, driver_id)\n    ))\n    final_trips_full = safe_query(\n        final_db_path,\n        \"SELECT id, start_at, end_at, avg_speed_mph, max_speed_mph, speeding_event_count, \"\n        \"start_lat, start_lng, end_lat, end_lng FROM trips WHERE vehicle_id = ? AND driver_id = ?\",\n        (vehicle_id, driver_id)\n    )\n    # Find new trips in final_db not present in initial_db\n    # We'll use start_at, end_at fields to match strictly.\n    initial_trip_sig = set((row[1], row[2]) for row in initial_trips)\n    candidate_new_trips = [\n        row for row in final_trips_full\n        if (row[1], row[2]) not in initial_trip_sig\n    ]\n    # Must be exactly one new matching trip\n    if len(candidate_new_trips) != 1:\n        return {\"result\": \"others\"}\n\n    new_trip = candidate_new_trips[0]  # tuple order per SELECT: id, start_at, end_at, ...\n    trip_id = new_trip[0]\n    start_at, end_at = new_trip[1], new_trip[2]\n    avg_speed, max_speed, speeding_event_count = new_trip[3], new_trip[4], new_trip[5]\n    start_lat, start_lng, end_lat, end_lng = new_trip[6], new_trip[7], new_trip[8], new_trip[9]\n\n    # Task required parameters\n    required = {\n        \"start_at\": \"2026-02-17T06:10:00-08:00\",\n        \"end_at\": \"2026-02-17T08:05:00-08:00\",\n        \"start_lat\": 37.3382,\n        \"start_lng\": -121.8863,\n        \"end_lat\": 37.8044,\n        \"end_lng\": -122.2711,\n        \"avg_speed\": 52.0,\n        \"max_speed\": 78.0,\n        \"speeding_event_count\": 2\n    }\n    # Allow minor floating point rounding for lat/lng/speed but require strict start/end time\n    def almost_equal(a, b, tol=1e-4):\n        try:\n            return abs(float(a) - float(b)) < tol\n        except Exception:\n            return False\n    if start_at != required[\"start_at\"]:\n        return {\"result\": \"others\"}\n    if end_at != required[\"end_at\"]:\n        return {\"result\": \"others\"}\n    if not (almost_equal(start_lat, required[\"start_lat\"]) and almost_equal(start_lng, required[\"start_lng\"])):\n        return {\"result\": \"others\"}\n    if not (almost_equal(end_lat, required[\"end_lat\"]) and almost_equal(end_lng, required[\"end_lng\"])):\n        return {\"result\": \"others\"}\n    if not almost_equal(avg_speed, required[\"avg_speed\"], tol=0.1):\n        return {\"result\": \"others\"}\n    if not almost_equal(max_speed, required[\"max_speed\"], tol=0.1):\n        return {\"result\": \"others\"}\n    if speeding_event_count != required[\"speeding_event_count\"]:\n        return {\"result\": \"others\"}\n\n    # 3. Check 18 GPS points for this trip, sequential, proper start and end match, all new in final_db\n    gps_points = safe_query(\n        final_db_path,\n        \"SELECT seq, recorded_at, lat, lng FROM trip_gps_points WHERE trip_id = ? ORDER BY seq\",\n        (trip_id,)\n    )\n    if len(gps_points) != 18:\n        return {\"result\": \"others\"}\n    # Expected start = seq 0, correct time/lat/lng; end = seq 17, correct\n    gps_start = gps_points[0]\n    gps_end = gps_points[-1]\n    # Start\n    if gps_start[0] != 0 or gps_start[1] != required[\"start_at\"]:\n        return {\"result\": \"others\"}\n    if not (almost_equal(gps_start[2], required[\"start_lat\"]) and almost_equal(gps_start[3], required[\"start_lng\"])):\n        return {\"result\": \"others\"}\n    # End\n    if gps_end[0] != 17 or gps_end[1] != required[\"end_at\"]:\n        return {\"result\": \"others\"}\n    if not (almost_equal(gps_end[2], required[\"end_lat\"]) and almost_equal(gps_end[3], required[\"end_lng\"])):\n        return {\"result\": \"others\"}\n    # Ensure these gps points are not present in initial_db for this trip (i.e. the trip really is new)\n    initial_gps_ids = set(r[0] for r in safe_query(initial_db_path,\n                                                  \"SELECT trip_id FROM trip_gps_points\"))\n    if trip_id in initial_gps_ids:\n        return {\"result\": \"others\"}\n\n    # 4. Check for two new 'speeding' vehicle_alerts for this trip, not present in initial_db\n    final_alerts = safe_query(final_db_path, \"SELECT id FROM vehicle_alerts WHERE trip_id = ? AND type = 'speeding'\", (trip_id,))\n    if len(final_alerts) != 2:\n        return {\"result\": \"others\"}\n    # Make sure these alerts are new i.e. not present in initial_db\n    initial_alerts = set([x[0] for x in safe_query(initial_db_path, \"SELECT id FROM vehicle_alerts\", ())])\n    if any((a[0] in initial_alerts) for a in final_alerts):\n        return {\"result\": \"others\"}\n\n    # 5. Defensive catch: check for any ambiguity in ids\n    # Ensure only one new trip, one set of GPS points, exact two vehicle alerts for this trip\n    # Also, check that the trip is only for the specified vehicle and driver\n    check_trip = safe_query(final_db_path, \"SELECT id FROM trips WHERE id = ? AND vehicle_id = ? AND driver_id = ?\",\n                                            (trip_id, vehicle_id, driver_id))\n    if len(check_trip) != 1:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must determine with certainty that the agent simulated a completed trip for 'Truck-12' driven by 'Maria Lopez', specifically: (1) A new trip record exists in the 'trips' table (not present in the initial state), with vehicle Truck-12 and driver Maria Lopez, exact start and end times, locations, average speed, max speed, and speeding events as specified; (2) The 'trip_gps_points' table contains exactly 18 sequential points for this trip, with proper begin/end locations and timestamps; (3) The 'vehicle_alerts' table contains precisely two 'speeding' events attached to this trip. Additionally, all these new records must not exist in the initial database, and all referenced IDs must match the correct driver and vehicle. If any check is uncertain, missing, or mismatched, the result must be 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find a new trip in 'trips' table in final_db (compared to initial_db) for Truck-12 (vehicle), Maria Lopez (driver), exact start/end time/location, avg 52.0 mph, max 78.0 mph, speeding_event_count=2\",\n        \"Check this trip's id is new and not present in initial_db\",\n        \"Verify exactly 18 'trip_gps_points' linked to this trip, sequential (0-17), matching start/end coordinates/timestamps\",\n        \"Check two new 'speeding' vehicle_alerts linked to this trip, not present in initial_db\",\n        \"IDs for vehicle (Truck-12) and driver (Maria Lopez) must match between records\",\n        \"No ambiguities or partial matches allowed\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    # Defensive DB query helper\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Get Maria Lopez's driver_id and Truck-12's vehicle_id in both DBs\\n    driver_row = safe_query(final_db_path, \\\"SELECT id FROM drivers WHERE full_name = ?\\\", (\\\"Maria Lopez\\\",))\\n    if not driver_row or not isinstance(driver_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    driver_id = driver_row[0][0]\\n\\n    vehicle_row = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name = ?\\\", (\\\"Truck-12\\\",))\\n    if not vehicle_row or not isinstance(vehicle_row[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vehicle_row[0][0]\\n\\n    # 2. Create set of (id, start_at, end_at) for trips in initial and final DB\\n    initial_trips = set(safe_query(\\n        initial_db_path,\\n        \\\"SELECT id, start_at, end_at FROM trips WHERE vehicle_id = ? AND driver_id = ?\\\",\\n        (vehicle_id, driver_id)\\n    ))\\n    final_trips_full = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, start_at, end_at, avg_speed_mph, max_speed_mph, speeding_event_count, \\\"\\n        \\\"start_lat, start_lng, end_lat, end_lng FROM trips WHERE vehicle_id = ? AND driver_id = ?\\\",\\n        (vehicle_id, driver_id)\\n    )\\n    # Find new trips in final_db not present in initial_db\\n    # We'll use start_at, end_at fields to match strictly.\\n    initial_trip_sig = set((row[1], row[2]) for row in initial_trips)\\n    candidate_new_trips = [\\n        row for row in final_trips_full\\n        if (row[1], row[2]) not in initial_trip_sig\\n    ]\\n    # Must be exactly one new matching trip\\n    if len(candidate_new_trips) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    new_trip = candidate_new_trips[0]  # tuple order per SELECT: id, start_at, end_at, ...\\n    trip_id = new_trip[0]\\n    start_at, end_at = new_trip[1], new_trip[2]\\n    avg_speed, max_speed, speeding_event_count = new_trip[3], new_trip[4], new_trip[5]\\n    start_lat, start_lng, end_lat, end_lng = new_trip[6], new_trip[7], new_trip[8], new_trip[9]\\n\\n    # Task required parameters\\n    required = {\\n        \\\"start_at\\\": \\\"2026-02-17T06:10:00-08:00\\\",\\n        \\\"end_at\\\": \\\"2026-02-17T08:05:00-08:00\\\",\\n        \\\"start_lat\\\": 37.3382,\\n        \\\"start_lng\\\": -121.8863,\\n        \\\"end_lat\\\": 37.8044,\\n        \\\"end_lng\\\": -122.2711,\\n        \\\"avg_speed\\\": 52.0,\\n        \\\"max_speed\\\": 78.0,\\n        \\\"speeding_event_count\\\": 2\\n    }\\n    # Allow minor floating point rounding for lat/lng/speed but require strict start/end time\\n    def almost_equal(a, b, tol=1e-4):\\n        try:\\n            return abs(float(a) - float(b)) < tol\\n        except Exception:\\n            return False\\n    if start_at != required[\\\"start_at\\\"]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if end_at != required[\\\"end_at\\\"]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (almost_equal(start_lat, required[\\\"start_lat\\\"]) and almost_equal(start_lng, required[\\\"start_lng\\\"])):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (almost_equal(end_lat, required[\\\"end_lat\\\"]) and almost_equal(end_lng, required[\\\"end_lng\\\"])):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not almost_equal(avg_speed, required[\\\"avg_speed\\\"], tol=0.1):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not almost_equal(max_speed, required[\\\"max_speed\\\"], tol=0.1):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if speeding_event_count != required[\\\"speeding_event_count\\\"]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Check 18 GPS points for this trip, sequential, proper start and end match, all new in final_db\\n    gps_points = safe_query(\\n        final_db_path,\\n        \\\"SELECT seq, recorded_at, lat, lng FROM trip_gps_points WHERE trip_id = ? ORDER BY seq\\\",\\n        (trip_id,)\\n    )\\n    if len(gps_points) != 18:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Expected start = seq 0, correct time/lat/lng; end = seq 17, correct\\n    gps_start = gps_points[0]\\n    gps_end = gps_points[-1]\\n    # Start\\n    if gps_start[0] != 0 or gps_start[1] != required[\\\"start_at\\\"]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (almost_equal(gps_start[2], required[\\\"start_lat\\\"]) and almost_equal(gps_start[3], required[\\\"start_lng\\\"])):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # End\\n    if gps_end[0] != 17 or gps_end[1] != required[\\\"end_at\\\"]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (almost_equal(gps_end[2], required[\\\"end_lat\\\"]) and almost_equal(gps_end[3], required[\\\"end_lng\\\"])):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Ensure these gps points are not present in initial_db for this trip (i.e. the trip really is new)\\n    initial_gps_ids = set(r[0] for r in safe_query(initial_db_path,\\n                                                  \\\"SELECT trip_id FROM trip_gps_points\\\"))\\n    if trip_id in initial_gps_ids:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check for two new 'speeding' vehicle_alerts for this trip, not present in initial_db\\n    final_alerts = safe_query(final_db_path, \\\"SELECT id FROM vehicle_alerts WHERE trip_id = ? AND type = 'speeding'\\\", (trip_id,))\\n    if len(final_alerts) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Make sure these alerts are new i.e. not present in initial_db\\n    initial_alerts = set([x[0] for x in safe_query(initial_db_path, \\\"SELECT id FROM vehicle_alerts\\\", ())])\\n    if any((a[0] in initial_alerts) for a in final_alerts):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Defensive catch: check for any ambiguity in ids\\n    # Ensure only one new trip, one set of GPS points, exact two vehicle alerts for this trip\\n    # Also, check that the trip is only for the specified vehicle and driver\\n    check_trip = safe_query(final_db_path, \\\"SELECT id FROM trips WHERE id = ? AND vehicle_id = ? AND driver_id = ?\\\",\\n                                            (trip_id, vehicle_id, driver_id))\\n    if len(check_trip) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 5, "task": "Generate time-series sensor readings for 'Truck-12' every 5 minutes from '2026-02-17T06:10:00-08:00' to '2026-02-17T08:05:00-08:00' including fuel level dropping from 62% to 55% and engine temperature ranging from 188F to 212F, and mark one engine-temp alert when it exceeds 210F for 10 minutes.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Find vehicle_id for 'Truck-12'\n    def get_vehicle_id(db_path):\n        rows = safe_query(db_path, \"SELECT id FROM vehicles WHERE name = ?\", (\"Truck-12\",))\n        return rows[0][0] if rows and isinstance(rows[0][0], int) else None\n\n    vehicle_id_initial = get_vehicle_id(initial_db_path)\n    vehicle_id_final = get_vehicle_id(final_db_path)\n    if vehicle_id_initial != vehicle_id_final or vehicle_id_final is None:\n        return {\"result\": \"others\"}\n    vehicle_id = vehicle_id_final\n\n    # Define expected time range\n    start_ts_str = \"2026-02-17T06:10:00-08:00\"\n    end_ts_str = \"2026-02-17T08:05:00-08:00\"\n    try:\n        dt_start = datetime.strptime(start_ts_str[:-6], \"%Y-%m-%dT%H:%M:%S\")\n        dt_end = datetime.strptime(end_ts_str[:-6], \"%Y-%m-%dT%H:%M:%S\")\n        tz_shift = int(start_ts_str[-5:-3]) * 60 + int(start_ts_str[-2:])\n    except Exception:\n        return {\"result\": \"others\"}\n    # Generate expected timestamps (every 5 minutes)\n    expected_times = []\n    dt = dt_start\n    while dt <= dt_end:\n        expected_times.append(dt.strftime(\"%Y-%m-%dT%H:%M:%S\") + \"-08:00\")\n        dt += timedelta(minutes=5)\n    n_expected = len(expected_times)\n    if n_expected < 1:\n        return {\"result\": \"others\"}\n\n    # Sensor readings for Truck-12 in initial and final db\n    readings_initial = safe_query(\n        initial_db_path,\n        \"SELECT recorded_at, fuel_level_pct, engine_temp_f FROM sensor_readings WHERE vehicle_id = ?\",\n        (vehicle_id,)\n    )\n    readings_final = safe_query(\n        final_db_path,\n        \"SELECT recorded_at, fuel_level_pct, engine_temp_f FROM sensor_readings WHERE vehicle_id = ?\",\n        (vehicle_id,)\n    )\n    if not isinstance(readings_final, list):\n        return {\"result\": \"others\"}\n\n    # Map readings by time\n    readings_final_dict = {r[0]: (r[1], r[2]) for r in readings_final if isinstance(r[0], str)}\n    # Check all expected timestamps present\n    missing = [t for t in expected_times if t not in readings_final_dict]\n    if missing:\n        return {\"result\": \"others\"}\n\n    # Check no extra timestamps in final readings for Truck-12 in the interval\n    extra = [t for t in readings_final_dict.keys() if t not in expected_times and (\n        t >= expected_times[0] and t <= expected_times[-1])]\n    if extra:\n        return {\"result\": \"others\"}\n\n    # Check fuel and temp values\n    fuel_values = [readings_final_dict[t][0] for t in expected_times]\n    temp_values = [readings_final_dict[t][1] for t in expected_times]\n    # Defensive: All must be floats, non-null\n    if any((not isinstance(f, (int, float))) for f in fuel_values) or any((not isinstance(e, (int, float))) for e in temp_values):\n        return {\"result\": \"others\"}\n\n    # Check fuel drops from ~62% to ~55%, and monotonic non-increasing\n    first_fuel = fuel_values[0]\n    last_fuel = fuel_values[-1]\n    if not (61.9 <= first_fuel <= 62.1 and 54.9 <= last_fuel <= 55.1):\n        return {\"result\": \"others\"}\n    # Monotonic\n    for i in range(1, len(fuel_values)):\n        if fuel_values[i] > fuel_values[i-1]+0.11: # allow <0.11 increase for rounding\n            return {\"result\": \"others\"}\n\n    # Engine temp range\n    min_temp = min(temp_values)\n    max_temp = max(temp_values)\n    if min_temp > 188 or max_temp < 212:\n        return {\"result\": \"others\"}\n    # All temps within [188, 212]\n    if any(e < 188 or e > 212 for e in temp_values):\n        return {\"result\": \"others\"}\n\n    # Check for engine temp alert\n    alerts_final = safe_query(final_db_path, \"SELECT type, severity, start_at, end_at, message FROM vehicle_alerts WHERE vehicle_id = ?\", (vehicle_id,))\n    engine_alerts = [a for a in alerts_final if a[0] == 'engine_temp']\n    # Must be exactly one\n    if len(engine_alerts) != 1:\n        return {\"result\": \"others\"}\n\n    alert = engine_alerts[0]\n    # Alert severity is not specified, but should be medium/high\n    if alert[1] not in ('medium', 'high'):\n        return {\"result\": \"others\"}\n    # Alert must cover exactly the period engine temp >210 for 10 minutes\n    # Find windows in temp_values where temp>210\n    over_210_indices = [i for i, v in enumerate(temp_values) if v > 210]\n    if not over_210_indices:\n        return {\"result\": \"others\"}\n    # Find contiguous block >=2 readings (two 5-min intervals = 10 min)\n    runs = []\n    run = []\n    for idx in over_210_indices:\n        if not run or idx == run[-1]+1:\n            run.append(idx)\n        else:\n            runs.append(run)\n            run = [idx]\n    if run:\n        runs.append(run)\n    ten_min_run = [r for r in runs if len(r) >= 2]\n    if not ten_min_run:\n        return {\"result\": \"others\"}\n    block = ten_min_run[0]\n    alert_start_expected = expected_times[block[0]]\n    alert_end_expected = expected_times[block[-1]]\n    # Alert start_at and end_at\n    try:\n        alert_start = alert[2]\n        alert_end = alert[3]\n        # Defensive: both present, valid\n        if not (isinstance(alert_start, str) and isinstance(alert_end, str)):\n            return {\"result\": \"others\"}\n    except Exception:\n        return {\"result\": \"others\"}\n    # Alert start/end must match window\n    if alert_start != alert_start_expected:\n        return {\"result\": \"others\"}\n    # Allow end_at to be either last over-210 reading or next reading after run\n    if alert_end != alert_end_expected and (\n        block[-1]+1 < n_expected and alert_end != expected_times[block[-1]+1]\n    ):\n        return {\"result\": \"others\"}\n    # Message references 'engine temperature exceeded 210F for ~10 minutes'\n    if not (alert[4] and re.search(r\"temperature exceeded 210.*10 minute\", alert[4], re.IGNORECASE)):\n        return {\"result\": \"others\"}\n\n    # Finally ensure these readings and alert were not present in initial db\n    # Readings: compare initial timestamps in interval\n    readings_initial_times = set(r[0] for r in readings_initial if isinstance(r[0], str))\n    new_readings = [t for t in expected_times if t not in readings_initial_times]\n    if len(new_readings) != n_expected:\n        # (If already present, no actual change)\n        return {\"result\": \"others\"}\n\n    alert_initial = safe_query(initial_db_path, \"SELECT type FROM vehicle_alerts WHERE vehicle_id = ? AND type = 'engine_temp'\", (vehicle_id,))\n    if alert_initial:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The task requires the agent to generate time-series sensor readings for 'Truck-12' (vehicle name), every 5 minutes from '2026-02-17T06:10:00-08:00' to '2026-02-17T08:05:00-08:00' (inclusive). The readings must cover: (1) fuel level dropping from 62% to 55%, (2) engine temperature ranging from 188F to 212F, and (3) one engine-temp alert when the temperature exceeds 210F for 10 minutes. The modified database must be checked for: correct vehicle identification, exact time interval and frequency, monotonic fuel drop in the correct range, engine temp in the correct range, and exactly one alert covering the correct duration and severity/type. All relevant edge cases (such as missing records, wrong vehicle, measurement out of bounds, incomplete intervals, alert type/severity/duration mismatch, etc.) must be checked. If anything is ambiguous, partial, missing, or incorrect, the result is 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify vehicle_id for 'Truck-12' in both initial and final db\",\n        \"Count sensor_readings for Truck-12 in both dbs and verify new readings added for each 5-minute interval from 06:10 to 08:05 (inclusive)\",\n        \"Check recorded_at timestamps for exact frequency (every 5 minutes), no gaps, and correct start/end\",\n        \"Verify fuel_level_pct readings start at 62.0 (0.1), end at 55.0 (0.1), strictly decrease or non-increasing, span full range\",\n        \"Verify engine_temp_f readings span at least 188F to 212F (inclusive), all readings are within specified bounds\",\n        \"Check in vehicle_alerts for exactly one 'engine_temp' alert for Truck-12: start when temp first exceeds 210F, end after 10 minutes, and message referencing the correct duration\",\n        \"All added data must be valid, complete, and match requirements with 100% certainty\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Find vehicle_id for 'Truck-12'\\n    def get_vehicle_id(db_path):\\n        rows = safe_query(db_path, \\\"SELECT id FROM vehicles WHERE name = ?\\\", (\\\"Truck-12\\\",))\\n        return rows[0][0] if rows and isinstance(rows[0][0], int) else None\\n\\n    vehicle_id_initial = get_vehicle_id(initial_db_path)\\n    vehicle_id_final = get_vehicle_id(final_db_path)\\n    if vehicle_id_initial != vehicle_id_final or vehicle_id_final is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vehicle_id_final\\n\\n    # Define expected time range\\n    start_ts_str = \\\"2026-02-17T06:10:00-08:00\\\"\\n    end_ts_str = \\\"2026-02-17T08:05:00-08:00\\\"\\n    try:\\n        dt_start = datetime.strptime(start_ts_str[:-6], \\\"%Y-%m-%dT%H:%M:%S\\\")\\n        dt_end = datetime.strptime(end_ts_str[:-6], \\\"%Y-%m-%dT%H:%M:%S\\\")\\n        tz_shift = int(start_ts_str[-5:-3]) * 60 + int(start_ts_str[-2:])\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Generate expected timestamps (every 5 minutes)\\n    expected_times = []\\n    dt = dt_start\\n    while dt <= dt_end:\\n        expected_times.append(dt.strftime(\\\"%Y-%m-%dT%H:%M:%S\\\") + \\\"-08:00\\\")\\n        dt += timedelta(minutes=5)\\n    n_expected = len(expected_times)\\n    if n_expected < 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Sensor readings for Truck-12 in initial and final db\\n    readings_initial = safe_query(\\n        initial_db_path,\\n        \\\"SELECT recorded_at, fuel_level_pct, engine_temp_f FROM sensor_readings WHERE vehicle_id = ?\\\",\\n        (vehicle_id,)\\n    )\\n    readings_final = safe_query(\\n        final_db_path,\\n        \\\"SELECT recorded_at, fuel_level_pct, engine_temp_f FROM sensor_readings WHERE vehicle_id = ?\\\",\\n        (vehicle_id,)\\n    )\\n    if not isinstance(readings_final, list):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Map readings by time\\n    readings_final_dict = {r[0]: (r[1], r[2]) for r in readings_final if isinstance(r[0], str)}\\n    # Check all expected timestamps present\\n    missing = [t for t in expected_times if t not in readings_final_dict]\\n    if missing:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check no extra timestamps in final readings for Truck-12 in the interval\\n    extra = [t for t in readings_final_dict.keys() if t not in expected_times and (\\n        t >= expected_times[0] and t <= expected_times[-1])]\\n    if extra:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check fuel and temp values\\n    fuel_values = [readings_final_dict[t][0] for t in expected_times]\\n    temp_values = [readings_final_dict[t][1] for t in expected_times]\\n    # Defensive: All must be floats, non-null\\n    if any((not isinstance(f, (int, float))) for f in fuel_values) or any((not isinstance(e, (int, float))) for e in temp_values):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check fuel drops from ~62% to ~55%, and monotonic non-increasing\\n    first_fuel = fuel_values[0]\\n    last_fuel = fuel_values[-1]\\n    if not (61.9 <= first_fuel <= 62.1 and 54.9 <= last_fuel <= 55.1):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Monotonic\\n    for i in range(1, len(fuel_values)):\\n        if fuel_values[i] > fuel_values[i-1]+0.11: # allow <0.11 increase for rounding\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Engine temp range\\n    min_temp = min(temp_values)\\n    max_temp = max(temp_values)\\n    if min_temp > 188 or max_temp < 212:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All temps within [188, 212]\\n    if any(e < 188 or e > 212 for e in temp_values):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check for engine temp alert\\n    alerts_final = safe_query(final_db_path, \\\"SELECT type, severity, start_at, end_at, message FROM vehicle_alerts WHERE vehicle_id = ?\\\", (vehicle_id,))\\n    engine_alerts = [a for a in alerts_final if a[0] == 'engine_temp']\\n    # Must be exactly one\\n    if len(engine_alerts) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    alert = engine_alerts[0]\\n    # Alert severity is not specified, but should be medium/high\\n    if alert[1] not in ('medium', 'high'):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Alert must cover exactly the period engine temp >210 for 10 minutes\\n    # Find windows in temp_values where temp>210\\n    over_210_indices = [i for i, v in enumerate(temp_values) if v > 210]\\n    if not over_210_indices:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Find contiguous block >=2 readings (two 5-min intervals = 10 min)\\n    runs = []\\n    run = []\\n    for idx in over_210_indices:\\n        if not run or idx == run[-1]+1:\\n            run.append(idx)\\n        else:\\n            runs.append(run)\\n            run = [idx]\\n    if run:\\n        runs.append(run)\\n    ten_min_run = [r for r in runs if len(r) >= 2]\\n    if not ten_min_run:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    block = ten_min_run[0]\\n    alert_start_expected = expected_times[block[0]]\\n    alert_end_expected = expected_times[block[-1]]\\n    # Alert start_at and end_at\\n    try:\\n        alert_start = alert[2]\\n        alert_end = alert[3]\\n        # Defensive: both present, valid\\n        if not (isinstance(alert_start, str) and isinstance(alert_end, str)):\\n            return {\\\"result\\\": \\\"others\\\"}\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Alert start/end must match window\\n    if alert_start != alert_start_expected:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Allow end_at to be either last over-210 reading or next reading after run\\n    if alert_end != alert_end_expected and (\\n        block[-1]+1 < n_expected and alert_end != expected_times[block[-1]+1]\\n    ):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Message references 'engine temperature exceeded 210F for ~10 minutes'\\n    if not (alert[4] and re.search(r\\\"temperature exceeded 210.*10 minute\\\", alert[4], re.IGNORECASE)):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Finally ensure these readings and alert were not present in initial db\\n    # Readings: compare initial timestamps in interval\\n    readings_initial_times = set(r[0] for r in readings_initial if isinstance(r[0], str))\\n    new_readings = [t for t in expected_times if t not in readings_initial_times]\\n    if len(new_readings) != n_expected:\\n        # (If already present, no actual change)\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    alert_initial = safe_query(initial_db_path, \\\"SELECT type FROM vehicle_alerts WHERE vehicle_id = ? AND type = 'engine_temp'\\\", (vehicle_id,))\\n    if alert_initial:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 7, "task": "Create a work order for 'Truck-12' titled 'Front brake pads replacement' with priority 'high', reported issue 'squealing when braking', open date '2026-02-16', assigned vendor 'Bay Area Fleet Service', and estimated labor cost $420 and parts cost $180.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # returns list of rows\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            res = cur.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n\n    # Find vehicle_id for 'Truck-12'\n    vrows = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name = ?\", (\"Truck-12\",))\n    if len(vrows) != 1 or not isinstance(vrows[0][0], int):\n        return {\"result\": \"others\"}\n    vehicle_id = vrows[0][0]\n\n    # Find vendor_id for 'Bay Area Fleet Service'\n    vendrows = safe_query(final_db_path, \"SELECT id FROM vendors WHERE name = ?\", (\"Bay Area Fleet Service\",))\n    if len(vendrows) != 1 or not isinstance(vendrows[0][0], int):\n        return {\"result\": \"others\"}\n    vendor_id = vendrows[0][0]\n\n    # Required work order fields (for match)\n    required = {\n        \"vehicle_id\": vehicle_id,\n        \"vendor_id\": vendor_id,\n        \"title\": \"Front brake pads replacement\",\n        \"priority\": \"high\",\n        \"reported_issue\": \"squealing when braking\",\n        \"open_date\": \"2026-02-16\",\n        \"estimated_labor_cost\": 420.0,\n        \"estimated_parts_cost\": 180.0\n    }\n\n    # Helper to search work_orders for a matching record in a db\n    def work_order_exists(db_path):\n        # Defensive: status may be open or closed, ignore others (relaxed)\n        query = (\"SELECT id FROM work_orders WHERE \"\n                 \"vehicle_id = ? AND vendor_id = ? AND \"\n                 \"title = ? AND priority = ? AND \"\n                 \"reported_issue = ? AND open_date = ? AND \"\n                 \"CAST(estimated_labor_cost AS FLOAT) = ? AND CAST(estimated_parts_cost AS FLOAT) = ?\")\n        params = (\n            required[\"vehicle_id\"],\n            required[\"vendor_id\"],\n            required[\"title\"],\n            required[\"priority\"],\n            required[\"reported_issue\"],\n            required[\"open_date\"],\n            required[\"estimated_labor_cost\"],\n            required[\"estimated_parts_cost\"]\n        )\n        rows = safe_query(db_path, query, params)\n        return set(row[0] for row in rows if isinstance(row[0], int))\n\n    # Helper to get relevant work_order records (all that match vehicle and title, for edge case analysis)\n    def get_candidate_work_orders(db_path):\n        q = (\"SELECT id, vendor_id, title, priority, reported_issue, open_date, estimated_labor_cost, estimated_parts_cost \"\n             \"FROM work_orders WHERE vehicle_id = ?\")\n        return safe_query(db_path, q, (vehicle_id,))\n\n    # Step 1: Confirm not present in initial_db\n    pre_ids = work_order_exists(initial_db_path)\n    if len(pre_ids) > 0:\n        # Already existed before >> not an agent creation\n        return {\"result\": \"others\"}\n\n    # Step 2: Must be present in final_db, and must be unique (no more than one such exactly matching work order)\n    post_ids = work_order_exists(final_db_path)\n    if len(post_ids) != 1:\n        return {\"result\": \"others\"}\n    the_id = list(post_ids)[0]\n\n    # Step 3: Check for possible overmatches/partial/fuzzy records (e.g., more than one similar, fields slightly differ)\n    # We allow other work orders for the vehicle, but only one must match EXACTLY (full set of specified fields)\n    # Defensive: enumerate candidate work orders for the vehicle after\n    cands = get_candidate_work_orders(final_db_path)\n    exact_matches = []\n    for row in cands:\n        _, cand_vendor_id, cand_title, cand_priority, cand_reported_issue, cand_open_date, cand_lab, cand_parts = row\n        if (\n            cand_vendor_id == required[\"vendor_id\"] and\n            (isinstance(cand_title, str) and cand_title.strip() == required[\"title\"]) and\n            (isinstance(cand_priority, str) and cand_priority.strip().lower() == required[\"priority\"]) and\n            (isinstance(cand_reported_issue, str) and cand_reported_issue.strip() == required[\"reported_issue\"]) and\n            (isinstance(cand_open_date, str) and cand_open_date.strip().split()[0] == required[\"open_date\"]) and\n            (cand_lab is not None and float(cand_lab) == required[\"estimated_labor_cost\"]) and\n            (cand_parts is not None and float(cand_parts) == required[\"estimated_parts_cost\"])\n        ):\n            exact_matches.append(row)\n    if len(exact_matches) != 1:\n        return {\"result\": \"others\"}\n\n    # Step 4: (No text response is required for the task, so we ignore final_answer)\n    # Do basic sanity guard on the rest of the work_order fields: we do not care about their other fields (status, etc.) for requirement\n    # If all checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify successful completion of this task, we must ensure that the agent created a new work order in the final database (not present in the initial) for vehicle 'Truck-12' (vehicle_id determined by name lookup), with title 'Front brake pads replacement', priority 'high', reported issue 'squealing when braking', open date '2026-02-16', and assigned vendor 'Bay Area Fleet Service'. Additionally, the estimated labor cost must be $420 and estimated parts cost $180. The new work order must have the exact required values, must not have existed in the initial database, and each referenced entity (vehicle, vendor) must exist and be correctly associated. No extraneous or partially matching records should be counted as complete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Lookup vehicle_id for 'Truck-12' in the vehicles table\",\n        \"Lookup vendor_id for 'Bay Area Fleet Service' in the vendors table\",\n        \"Ensure initial_db has no work_orders record matching all required fields for this work order and vehicle\",\n        \"In final_db, ensure exactly one new work_orders record exists for the vehicle, vendor, title, priority, reported_issue, open_date, estimated_labor_cost, and estimated_parts_cost\",\n        \"Ensure all the following fields match EXACTLY: vehicle_id, vendor_id, title, priority, reported_issue, open_date, estimated_labor_cost, estimated_parts_cost\",\n        \"Ignore status/close_date/odometer/notes unless explicitly part of the requirements\",\n        \"Handle possible field type variations and whitespace discrepancies\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # returns list of rows\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            res = cur.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n\\n    # Find vehicle_id for 'Truck-12'\\n    vrows = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name = ?\\\", (\\\"Truck-12\\\",))\\n    if len(vrows) != 1 or not isinstance(vrows[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vrows[0][0]\\n\\n    # Find vendor_id for 'Bay Area Fleet Service'\\n    vendrows = safe_query(final_db_path, \\\"SELECT id FROM vendors WHERE name = ?\\\", (\\\"Bay Area Fleet Service\\\",))\\n    if len(vendrows) != 1 or not isinstance(vendrows[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vendor_id = vendrows[0][0]\\n\\n    # Required work order fields (for match)\\n    required = {\\n        \\\"vehicle_id\\\": vehicle_id,\\n        \\\"vendor_id\\\": vendor_id,\\n        \\\"title\\\": \\\"Front brake pads replacement\\\",\\n        \\\"priority\\\": \\\"high\\\",\\n        \\\"reported_issue\\\": \\\"squealing when braking\\\",\\n        \\\"open_date\\\": \\\"2026-02-16\\\",\\n        \\\"estimated_labor_cost\\\": 420.0,\\n        \\\"estimated_parts_cost\\\": 180.0\\n    }\\n\\n    # Helper to search work_orders for a matching record in a db\\n    def work_order_exists(db_path):\\n        # Defensive: status may be open or closed, ignore others (relaxed)\\n        query = (\\\"SELECT id FROM work_orders WHERE \\\"\\n                 \\\"vehicle_id = ? AND vendor_id = ? AND \\\"\\n                 \\\"title = ? AND priority = ? AND \\\"\\n                 \\\"reported_issue = ? AND open_date = ? AND \\\"\\n                 \\\"CAST(estimated_labor_cost AS FLOAT) = ? AND CAST(estimated_parts_cost AS FLOAT) = ?\\\")\\n        params = (\\n            required[\\\"vehicle_id\\\"],\\n            required[\\\"vendor_id\\\"],\\n            required[\\\"title\\\"],\\n            required[\\\"priority\\\"],\\n            required[\\\"reported_issue\\\"],\\n            required[\\\"open_date\\\"],\\n            required[\\\"estimated_labor_cost\\\"],\\n            required[\\\"estimated_parts_cost\\\"]\\n        )\\n        rows = safe_query(db_path, query, params)\\n        return set(row[0] for row in rows if isinstance(row[0], int))\\n\\n    # Helper to get relevant work_order records (all that match vehicle and title, for edge case analysis)\\n    def get_candidate_work_orders(db_path):\\n        q = (\\\"SELECT id, vendor_id, title, priority, reported_issue, open_date, estimated_labor_cost, estimated_parts_cost \\\"\\n             \\\"FROM work_orders WHERE vehicle_id = ?\\\")\\n        return safe_query(db_path, q, (vehicle_id,))\\n\\n    # Step 1: Confirm not present in initial_db\\n    pre_ids = work_order_exists(initial_db_path)\\n    if len(pre_ids) > 0:\\n        # Already existed before >> not an agent creation\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 2: Must be present in final_db, and must be unique (no more than one such exactly matching work order)\\n    post_ids = work_order_exists(final_db_path)\\n    if len(post_ids) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    the_id = list(post_ids)[0]\\n\\n    # Step 3: Check for possible overmatches/partial/fuzzy records (e.g., more than one similar, fields slightly differ)\\n    # We allow other work orders for the vehicle, but only one must match EXACTLY (full set of specified fields)\\n    # Defensive: enumerate candidate work orders for the vehicle after\\n    cands = get_candidate_work_orders(final_db_path)\\n    exact_matches = []\\n    for row in cands:\\n        _, cand_vendor_id, cand_title, cand_priority, cand_reported_issue, cand_open_date, cand_lab, cand_parts = row\\n        if (\\n            cand_vendor_id == required[\\\"vendor_id\\\"] and\\n            (isinstance(cand_title, str) and cand_title.strip() == required[\\\"title\\\"]) and\\n            (isinstance(cand_priority, str) and cand_priority.strip().lower() == required[\\\"priority\\\"]) and\\n            (isinstance(cand_reported_issue, str) and cand_reported_issue.strip() == required[\\\"reported_issue\\\"]) and\\n            (isinstance(cand_open_date, str) and cand_open_date.strip().split()[0] == required[\\\"open_date\\\"]) and\\n            (cand_lab is not None and float(cand_lab) == required[\\\"estimated_labor_cost\\\"]) and\\n            (cand_parts is not None and float(cand_parts) == required[\\\"estimated_parts_cost\\\"])\\n        ):\\n            exact_matches.append(row)\\n    if len(exact_matches) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: (No text response is required for the task, so we ignore final_answer)\\n    # Do basic sanity guard on the rest of the work_order fields: we do not care about their other fields (status, etc.) for requirement\\n    # If all checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 8, "task": "Add parts usage to the 'Front brake pads replacement' work order with line items 'Brake pads set (PN BP-4421) qty 1 unit cost $165' and 'Brake cleaner qty 2 unit cost $7.50', then close the work order with actual labor cost $395, odometer at repair 49,020 miles, completion date '2026-02-18', and notes 'test drive OK'.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    def safe_query(db_path: str, query: str, params: tuple = ()): \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Step 1: Locate work order titled 'Front brake pads replacement'\n    work_orders = safe_query(\n        final_db_path,\n        \"SELECT id, status, actual_labor_cost, odometer_at_repair_miles, close_date, notes FROM work_orders WHERE title = ? ORDER BY id\",\n        (\"Front brake pads replacement\",)\n    )\n    if len(work_orders) != 1:\n        return {\"result\": \"others\"}\n    (wo_id, status, actual_labor_cost, odo_at_repair, close_date, notes) = work_orders[0]\n\n    # Step 2: Check work order is closed with correct details\n    if status != \"closed\":\n        return {\"result\": \"others\"}\n    if actual_labor_cost is None or float(actual_labor_cost) != 395.0:\n        return {\"result\": \"others\"}\n    if odo_at_repair is None or int(odo_at_repair) != 49020:\n        return {\"result\": \"others\"}\n    # Accept both date only or ISO timestamp, but must start with 2026-02-18\n    if not (isinstance(close_date,str) and close_date.startswith(\"2026-02-18\")):\n        return {\"result\": \"others\"}\n    if not (isinstance(notes, str) and notes.strip() == \"test drive OK\"):\n        return {\"result\": \"others\"}\n\n    # Step 3: Confirm line items for the work order\n    line_items = safe_query(\n        final_db_path,\n        \"SELECT description, part_number, quantity, unit_cost FROM work_order_line_items WHERE work_order_id = ? \",\n        (wo_id,)\n    )\n    # For this task, expect exactly 2 line items (not more, not less)\n    if len(line_items) != 2:\n        return {\"result\": \"others\"}\n\n    # Identify both required line items\n    found_brake_pads = False\n    found_brake_cleaner = False\n    for desc, part_num, qty, unit_cost in line_items:\n        desc_lc = (desc or '').strip().lower()\n        # Check for brake pads set\n        if desc_lc == 'brake pads set':\n            if part_num != 'BP-4421':\n                return {\"result\": \"others\"}\n            if qty is None or float(qty) != 1.0:\n                return {\"result\": \"others\"}\n            if unit_cost is None or float(unit_cost) != 165.0:\n                return {\"result\": \"others\"}\n            found_brake_pads = True\n        # Check for brake cleaner (case-insensitive)\n        elif desc_lc == 'brake cleaner':\n            if part_num is not None:  # Should be NULL\n                return {\"result\": \"others\"}\n            if qty is None or float(qty) != 2.0:\n                return {\"result\": \"others\"}\n            if unit_cost is None or float(unit_cost) != 7.5:\n                return {\"result\": \"others\"}\n            found_brake_cleaner = True\n        else:\n            # Any other description is not permitted\n            return {\"result\": \"others\"}\n    if not (found_brake_pads and found_brake_cleaner):\n        return {\"result\": \"others\"}\n\n    # Step 4: Check for any extraneous line items in this work order (should only have 2)\n    line_items_count = safe_query(final_db_path, \"SELECT COUNT(*) FROM work_order_line_items WHERE work_order_id = ?\", (wo_id,))\n    if not line_items_count or line_items_count[0][0] != 2:\n        return {\"result\": \"others\"}\n\n    # All modification checks passed with 100% certainty\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task requires verifying two types of changes: (1) MODIFICATION of work order line items for the work order titled 'Front brake pads replacement'specifically, the addition of two line items: 'Brake pads set' with part number BP-4421, quantity 1, and unit cost $165, and 'Brake cleaner' with quantity 2 and unit cost $7.50; (2) MODIFICATION to CLOSE the work order with precise updates: actual labor cost $395, odometer at repair 49,020 miles, completion date '2026-02-18', and notes 'test drive OK'. All values must match exactly, and the final state of the work order and its line items must fully and exclusively satisfy the requested details.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Locate the work order whose title is exactly 'Front brake pads replacement'.\",\n        \"Confirm the work order is in status 'closed'.\",\n        \"Confirm work order actual_labor_cost is 395.0.\",\n        \"Confirm work order odometer_at_repair_miles is 49020.\",\n        \"Confirm work order close_date is '2026-02-18'.\",\n        \"Confirm work order notes is exactly 'test drive OK'.\",\n        \"Confirm there is EXACTLY one line item for 'Brake pads set' with part number 'BP-4421', quantity 1.0, unit cost 165.0.\",\n        \"Confirm there is EXACTLY one line item for 'Brake cleaner' (case-insensitive), quantity 2.0, unit cost 7.5, and part_number is NULL.\",\n        \"Make sure there are no extraneous line items on this work order.\",\n        \"Ensure all values are present and data types are as expected.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    def safe_query(db_path: str, query: str, params: tuple = ()): \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Step 1: Locate work order titled 'Front brake pads replacement'\\n    work_orders = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, status, actual_labor_cost, odometer_at_repair_miles, close_date, notes FROM work_orders WHERE title = ? ORDER BY id\\\",\\n        (\\\"Front brake pads replacement\\\",)\\n    )\\n    if len(work_orders) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    (wo_id, status, actual_labor_cost, odo_at_repair, close_date, notes) = work_orders[0]\\n\\n    # Step 2: Check work order is closed with correct details\\n    if status != \\\"closed\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if actual_labor_cost is None or float(actual_labor_cost) != 395.0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if odo_at_repair is None or int(odo_at_repair) != 49020:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Accept both date only or ISO timestamp, but must start with 2026-02-18\\n    if not (isinstance(close_date,str) and close_date.startswith(\\\"2026-02-18\\\")):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (isinstance(notes, str) and notes.strip() == \\\"test drive OK\\\"):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Confirm line items for the work order\\n    line_items = safe_query(\\n        final_db_path,\\n        \\\"SELECT description, part_number, quantity, unit_cost FROM work_order_line_items WHERE work_order_id = ? \\\",\\n        (wo_id,)\\n    )\\n    # For this task, expect exactly 2 line items (not more, not less)\\n    if len(line_items) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Identify both required line items\\n    found_brake_pads = False\\n    found_brake_cleaner = False\\n    for desc, part_num, qty, unit_cost in line_items:\\n        desc_lc = (desc or '').strip().lower()\\n        # Check for brake pads set\\n        if desc_lc == 'brake pads set':\\n            if part_num != 'BP-4421':\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if qty is None or float(qty) != 1.0:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if unit_cost is None or float(unit_cost) != 165.0:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            found_brake_pads = True\\n        # Check for brake cleaner (case-insensitive)\\n        elif desc_lc == 'brake cleaner':\\n            if part_num is not None:  # Should be NULL\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if qty is None or float(qty) != 2.0:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            if unit_cost is None or float(unit_cost) != 7.5:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            found_brake_cleaner = True\\n        else:\\n            # Any other description is not permitted\\n            return {\\\"result\\\": \\\"others\\\"}\\n    if not (found_brake_pads and found_brake_cleaner):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: Check for any extraneous line items in this work order (should only have 2)\\n    line_items_count = safe_query(final_db_path, \\\"SELECT COUNT(*) FROM work_order_line_items WHERE work_order_id = ?\\\", (wo_id,))\\n    if not line_items_count or line_items_count[0][0] != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All modification checks passed with 100% certainty\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 9, "task": "Submit a DVIR for driver 'Maria Lopez' on vehicle 'Truck-12' for date '2026-02-18' marking defects 'left headlight out (severity: major)' and 'windshield washer low (severity: minor)', then record manager acknowledgment 'maintenance scheduled' and later add repair verification for the headlight with vendor 'Bay Area Fleet Service' and cost $48.00.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Get Maria Lopez's driver_id and Truck-12's vehicle_id from both DBs\n    driver_results = safe_query(final_db_path, \"SELECT id FROM drivers WHERE full_name = ?\", ('Maria Lopez',))\n    vehicle_results = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name = ?\", ('Truck-12',))\n    if len(driver_results) != 1 or len(vehicle_results) != 1:\n        return {\"result\": \"others\"}\n    driver_id = driver_results[0][0]\n    vehicle_id = vehicle_results[0][0]\n    dvir_date = '2026-02-18'\n\n    # 1. Check initial_db for existing DVIR\n    initial_dvirs = safe_query(initial_db_path, \"SELECT id, manager_ack_notes FROM dvirs WHERE driver_id = ? AND vehicle_id = ? AND dvir_date = ?\", (driver_id, vehicle_id, dvir_date))\n    if initial_dvirs:\n        return {\"result\": \"others\"}  # DVIR already existed before\n\n    # 2. Check final_db for DVIR with correct info\n    final_dvirs = safe_query(final_db_path, \"SELECT id, manager_ack_at, manager_ack_notes FROM dvirs WHERE driver_id = ? AND vehicle_id = ? AND dvir_date = ?\", (driver_id, vehicle_id, dvir_date))\n    if len(final_dvirs) != 1:\n        return {\"result\": \"others\"}\n    dvir_id, manager_ack_at, manager_ack_notes = final_dvirs[0]\n    if manager_ack_notes != 'maintenance scheduled' or manager_ack_at is None:\n        return {\"result\": \"others\"}\n\n    # 3. Check final_db for defects for DVIR\n    defects = safe_query(final_db_path, \"SELECT id, description, severity FROM dvir_defects WHERE dvir_id = ?\", (dvir_id,))\n    # Find the two precise defects\n    found_headlight = False\n    found_washer = False\n    defect_ids = {}\n    for defect in defects:\n        d_id, desc, sev = defect\n        if desc == 'left headlight out' and sev == 'major':\n            found_headlight = True\n            defect_ids['headlight'] = d_id\n        if desc == 'windshield washer low' and sev == 'minor':\n            found_washer = True\n            defect_ids['washer'] = d_id\n    if not (found_headlight and found_washer):\n        return {\"result\": \"others\"}\n    # Ensure no extra defects for DVIR\n    if len(defects) != 2:\n        return {\"result\": \"others\"}\n\n    # 4. Ensure defects were NOT present in initial_db\n    initial_defects = safe_query(initial_db_path, \"SELECT id FROM dvir_defects WHERE dvir_id = ?\", (dvir_id,))\n    if initial_defects:\n        return {\"result\": \"others\"}  # Defects already existed before\n\n    # 5. Check final_db for repair of 'left headlight out' with vendor and cost\n    # Get Bay Area Fleet Service vendor id\n    vendor_results = safe_query(final_db_path, \"SELECT id FROM vendors WHERE name = ?\", ('Bay Area Fleet Service',))\n    if len(vendor_results) != 1:\n        return {\"result\": \"others\"}\n    vendor_id = vendor_results[0][0]\n    headlight_defect_id = defect_ids['headlight']\n    repairs = safe_query(final_db_path, \"SELECT vendor_id, cost, repaired_at, verified_at FROM dvir_defect_repairs WHERE dvir_defect_id = ?\", (headlight_defect_id,))\n    correct_repair = False\n    for r in repairs:\n        v_id, cost, repaired_at, verified_at = r\n        if (v_id == vendor_id and\n           cost == 48.0 and\n           repaired_at is not None and\n           verified_at is not None):\n            correct_repair = True\n    if not correct_repair:\n        return {\"result\": \"others\"}\n\n    # 6. Ensure this defect repair did NOT exist in initial_db\n    initial_repairs = safe_query(initial_db_path, \"SELECT vendor_id, cost FROM dvir_defect_repairs WHERE dvir_defect_id = ?\", (headlight_defect_id,))\n    if initial_repairs:\n        return {\"result\": \"others\"}\n\n    # 7. Ensure no extra repairs for headlight defect\n    if len(repairs) != 1:\n        return {\"result\": \"others\"}\n\n    # 8. Ensure no repairs for washer defect (as task requires repair only for headlight)\n    washer_repairs = safe_query(final_db_path, \"SELECT id FROM dvir_defect_repairs WHERE dvir_defect_id = ?\", (defect_ids['washer'],))\n    if washer_repairs:\n        # Might be uncertain, but if task only asked for headlight repair, others if washer repair exists\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must confirm that (1) a DVIR was submitted for Maria Lopez on Truck-12 for date 2026-02-18 containing exactly two defects: 'left headlight out (major)' and 'windshield washer low (minor)', (2) a manager acknowledgement with the note 'maintenance scheduled' was recorded, and (3) a repair verification for the headlight was added with vendor 'Bay Area Fleet Service' and cost $48.00. We must ensure these new records exist in final_db and did not exist in initial_db, and no spurious/unrequested changes occurred. All associations must be consistent (vehicle/driver/date matches, defect descriptions and severities precise, manager note exact, defect repair links and values exact). The task is modification-based, as it purely involves database changes. Answer text is not needed for verification, so only DB state is checked.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Verify Maria Lopez's driver_id and Truck-12's vehicle_id in the database\",\n        \"Check initial_db to see that a DVIR for driver_id on vehicle_id for 2026-02-18 does NOT exist\",\n        \"Check final_db for a DVIR for driver_id, vehicle_id, date 2026-02-18 with manager_ack_notes='maintenance scheduled' and non-null manager_ack_at\",\n        \"Ensure the DVIR record has exactly two defects: (1) 'left headlight out', severity 'major', (2) 'windshield washer low', severity 'minor'\",\n        \"Verify that dvir_defect_repairs in final_db contains a record for the 'left headlight out' defect, linked to vendor 'Bay Area Fleet Service', cost $48.00, and repaired/verified timestamps\",\n        \"Check these new DVIR, defects, and defect repair records do NOT exist in initial_db\",\n        \"Ensure all links are correct: defect->DVIR, defect repair->defect, vendor->repair; no extra defects or repairs for this DVIR in final_db\",\n        \"Handle malformed/missing data gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Get Maria Lopez's driver_id and Truck-12's vehicle_id from both DBs\\n    driver_results = safe_query(final_db_path, \\\"SELECT id FROM drivers WHERE full_name = ?\\\", ('Maria Lopez',))\\n    vehicle_results = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name = ?\\\", ('Truck-12',))\\n    if len(driver_results) != 1 or len(vehicle_results) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    driver_id = driver_results[0][0]\\n    vehicle_id = vehicle_results[0][0]\\n    dvir_date = '2026-02-18'\\n\\n    # 1. Check initial_db for existing DVIR\\n    initial_dvirs = safe_query(initial_db_path, \\\"SELECT id, manager_ack_notes FROM dvirs WHERE driver_id = ? AND vehicle_id = ? AND dvir_date = ?\\\", (driver_id, vehicle_id, dvir_date))\\n    if initial_dvirs:\\n        return {\\\"result\\\": \\\"others\\\"}  # DVIR already existed before\\n\\n    # 2. Check final_db for DVIR with correct info\\n    final_dvirs = safe_query(final_db_path, \\\"SELECT id, manager_ack_at, manager_ack_notes FROM dvirs WHERE driver_id = ? AND vehicle_id = ? AND dvir_date = ?\\\", (driver_id, vehicle_id, dvir_date))\\n    if len(final_dvirs) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    dvir_id, manager_ack_at, manager_ack_notes = final_dvirs[0]\\n    if manager_ack_notes != 'maintenance scheduled' or manager_ack_at is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Check final_db for defects for DVIR\\n    defects = safe_query(final_db_path, \\\"SELECT id, description, severity FROM dvir_defects WHERE dvir_id = ?\\\", (dvir_id,))\\n    # Find the two precise defects\\n    found_headlight = False\\n    found_washer = False\\n    defect_ids = {}\\n    for defect in defects:\\n        d_id, desc, sev = defect\\n        if desc == 'left headlight out' and sev == 'major':\\n            found_headlight = True\\n            defect_ids['headlight'] = d_id\\n        if desc == 'windshield washer low' and sev == 'minor':\\n            found_washer = True\\n            defect_ids['washer'] = d_id\\n    if not (found_headlight and found_washer):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Ensure no extra defects for DVIR\\n    if len(defects) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Ensure defects were NOT present in initial_db\\n    initial_defects = safe_query(initial_db_path, \\\"SELECT id FROM dvir_defects WHERE dvir_id = ?\\\", (dvir_id,))\\n    if initial_defects:\\n        return {\\\"result\\\": \\\"others\\\"}  # Defects already existed before\\n\\n    # 5. Check final_db for repair of 'left headlight out' with vendor and cost\\n    # Get Bay Area Fleet Service vendor id\\n    vendor_results = safe_query(final_db_path, \\\"SELECT id FROM vendors WHERE name = ?\\\", ('Bay Area Fleet Service',))\\n    if len(vendor_results) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vendor_id = vendor_results[0][0]\\n    headlight_defect_id = defect_ids['headlight']\\n    repairs = safe_query(final_db_path, \\\"SELECT vendor_id, cost, repaired_at, verified_at FROM dvir_defect_repairs WHERE dvir_defect_id = ?\\\", (headlight_defect_id,))\\n    correct_repair = False\\n    for r in repairs:\\n        v_id, cost, repaired_at, verified_at = r\\n        if (v_id == vendor_id and\\n           cost == 48.0 and\\n           repaired_at is not None and\\n           verified_at is not None):\\n            correct_repair = True\\n    if not correct_repair:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Ensure this defect repair did NOT exist in initial_db\\n    initial_repairs = safe_query(initial_db_path, \\\"SELECT vendor_id, cost FROM dvir_defect_repairs WHERE dvir_defect_id = ?\\\", (headlight_defect_id,))\\n    if initial_repairs:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. Ensure no extra repairs for headlight defect\\n    if len(repairs) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 8. Ensure no repairs for washer defect (as task requires repair only for headlight)\\n    washer_repairs = safe_query(final_db_path, \\\"SELECT id FROM dvir_defect_repairs WHERE dvir_defect_id = ?\\\", (defect_ids['washer'],))\\n    if washer_repairs:\\n        # Might be uncertain, but if task only asked for headlight repair, others if washer repair exists\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 0, "task": "List all current Item Shop offers for the NA-East region at the current timestamp and return each offers item/bundle name, rarity, category, price in V-Bucks, and time remaining in the rotation.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    import datetime\n\n    # Helper to get rows from DB safely\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Helper to get item info by id\n    def get_item_info(db_path: str, item_id: int) -> dict:\n        rows = safe_query(db_path, \"SELECT name, rarity, category FROM items WHERE id = ?\", (item_id,))\n        if rows:\n            name, rarity, category = rows[0]\n            return {\"name\": name, \"rarity\": rarity, \"category\": category}\n        return {}\n\n    # Helper to get region id for NA-East\n    region_rows = safe_query(final_db_path, \"SELECT id FROM regions WHERE code = ?\", (\"NA-EAST\",))\n    if not region_rows or len(region_rows) != 1:\n        return {\"result\": \"others\"}\n    region_id = region_rows[0][0]\n\n    # Get all current shop_offers for NA-East at now\n    # We'll take \"now\" as max(updated_at) from regions table to avoid time ambiguity\n    now_rows = safe_query(final_db_path, \"SELECT MAX(updated_at) FROM regions WHERE id = ?\", (region_id,))\n    if not now_rows or not now_rows[0][0]:\n        return {\"result\": \"others\"}\n    now_str = now_rows[0][0]\n    try:\n        now_dt = datetime.datetime.strptime(now_str, \"%Y-%m-%d %H:%M:%S\")\n    except Exception:\n        return {\"result\": \"others\"}\n\n    # Get all offers active at now for NA-East\n    offers = safe_query(\n        final_db_path,\n        \"SELECT id, offered_item_id, price_vbucks, starts_at, ends_at, title_override FROM shop_offers WHERE region_id = ? AND starts_at <= ? AND ends_at > ?\",\n        (region_id, now_str, now_str)\n    )\n    if not offers:\n        # No offers, but user should have noted that\n        if final_answer and re.search(r\"no offers|shop is empty\", final_answer, re.IGNORECASE):\n            return {\"result\": \"complete\"}\n        return {\"result\": \"others\"}\n\n    # Build expected list\n    expected_offers = []\n    for offer in offers:\n        offer_id, item_id, price, starts_at, ends_at, title_override = offer\n        item_info = get_item_info(final_db_path, item_id)\n        if not item_info or not item_info.get(\"name\") or not item_info.get(\"rarity\") or not item_info.get(\"category\"):\n            return {\"result\": \"others\"}\n        # Use title_override if present for display name\n        display_name = title_override if title_override and str(title_override).strip() != \"\" else item_info[\"name\"]\n        # Time remaining in seconds\n        try:\n            end_dt = datetime.datetime.strptime(ends_at, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            return {\"result\": \"others\"}\n        time_remaining = (end_dt - now_dt).total_seconds()\n        expected_offers.append({\n            \"display_name\": display_name,\n            \"rarity\": item_info[\"rarity\"],\n            \"category\": item_info[\"category\"],\n            \"price\": price,\n            \"time_remaining\": time_remaining,\n            \"ends_at\": ends_at\n        })\n\n    # Defensive: Check reasonable time_remaining for all offers\n    if any(o[\"time_remaining\"] <= 0 for o in expected_offers):\n        return {\"result\": \"others\"}\n\n    # Defensive: Check answer provided\n    if final_answer is None or len(str(final_answer).strip()) == 0:\n        return {\"result\": \"others\"}\n\n    # Regex patterns to extract entries: try to match individual offers (robust, ignore formatting)\n    # Each offer must have name, rarity, category, price, and time\n    # Example: 'name: Galaxy Scout, rarity: Epic, category: Outfit, price: 1500 V-Bucks, time remaining: ...'\n    # Allow for optional field order, so build a flexible pattern\n    offer_pattern = re.compile(\n        r\"(?:name\\s*[:=]\\s*(?P<name>[\\w \\-']+)[,;])?\\s*\"\n        r\"rarity\\s*[:=]\\s*(?P<rarity>Legendary|Epic|Rare|Uncommon|Common|Mythic)[,;]?\\s*\"\n        r\"category\\s*[:=]\\s*(?P<category>Outfit|Emote|Wrap|Bundle)[,;]?\\s*\"\n        r\"price\\s*[:=]\\s*(?P<price>\\d+)\\s*V-?Bucks[,;]?\\s*\"\n        r\"time\\s*remaining\\s*[:=]\\s*(?P<time_remaining>[\\w :.-]+)\",\n        re.IGNORECASE\n    )\n\n    # Find all offers presented in final_answer\n    found_offers = []\n    for m in offer_pattern.finditer(final_answer):\n        offer_dict = {\n            \"display_name\": m.group(\"name\").strip() if m.group(\"name\") else None,\n            \"rarity\": m.group(\"rarity\").strip() if m.group(\"rarity\") else None,\n            \"category\": m.group(\"category\").strip() if m.group(\"category\") else None,\n            \"price\": int(m.group(\"price\")) if m.group(\"price\") and m.group(\"price\").isdigit() else None,\n            \"time_remaining_text\": m.group(\"time_remaining\").strip() if m.group(\"time_remaining\") else None\n        }\n        found_offers.append(offer_dict)\n\n    # If no offers found, or not all fields present per offer, fail\n    if len(found_offers) == 0:\n        return {\"result\": \"others\"}\n\n    # Check each expected offer is matched by an entry in found_offers\n    matched_count = 0\n    used_indices = set()\n    for expected in expected_offers:\n        match_found = False\n        for idx, found in enumerate(found_offers):\n            if idx in used_indices:\n                continue\n            # Match display name flexibly: exact or case-insensitive\n            answer_name = (found[\"display_name\"] or \"\").strip()\n            db_name = expected[\"display_name\"].strip()\n            if answer_name.lower() != db_name.lower():\n                continue\n            if found[\"rarity\"] != expected[\"rarity\"]:\n                continue\n            if found[\"category\"] != expected[\"category\"]:\n                continue\n            if found[\"price\"] != expected[\"price\"]:\n                continue\n            # Try to match time remaining\n            answer_time = found[\"time_remaining_text\"]\n            if answer_time is None or len(answer_time) == 0:\n                continue\n            # Acceptable answer formats: '23h 59m', '1d 1h', '86399s', etc.\n            # Convert expected time_remaining to human format for comparison\n            secs = int(round(expected[\"time_remaining\"]))\n            # Build multiple possible representations (hours/minutes/seconds)\n            def format_time(secs: int) -> list:\n                out = []\n                # Option 1: xh ym zs\n                h = secs // 3600\n                m = (secs % 3600) // 60\n                s = secs % 60\n                if h > 0:\n                    out.append(f\"{h}h {m}m\")\n                    if s > 0:\n                        out.append(f\"{h}h {m}m {s}s\")\n                elif m > 0:\n                    out.append(f\"{m}m {s}s\")\n                else:\n                    out.append(f\"{s}s\")\n                # Option 2: x days y hours\n                d = secs // 86400\n                hr = (secs % 86400) // 3600\n                if d > 0:\n                    out.append(f\"{d}d {hr}h\")\n                    if m > 0:\n                        out.append(f\"{d}d {hr}h {m}m\")\n                # Option 3: \"{secs}s\"\n                out.append(f\"{secs}s\")\n                # Option 4: \"{secs} seconds\"\n                out.append(f\"{secs} seconds\")\n                return out\n            expected_time_variants = [s.lower() for s in format_time(secs)]\n            # Accept if answer_time matches any variant (flexible, ignore whitespace)\n            answer_time_normalized = re.sub(r\"\\s+\", \" \", answer_time.lower().strip())\n            variant_matched = any(v in answer_time_normalized for v in expected_time_variants)\n            if not variant_matched:\n                continue\n            match_found = True\n            used_indices.add(idx)\n            break\n        if match_found:\n            matched_count += 1\n\n    # All expected offers must be matched, and no extra offers (strict)\n    if matched_count == len(expected_offers) and len(found_offers) == len(expected_offers):\n        return {\"result\": \"complete\"}\n\n    return {\"result\": \"others\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure that the agent listed all current Fortnite Item Shop offers for the NA-East region at the current timestamp and accurately reported for each offer: item/bundle name, rarity, category, price in V-Bucks, and time remaining in the rotation. This is a query-based task: the agent must have extracted and presented information from the shop_offers table (joined with items) for region NA-East (id=1) where current timestamp ('now') is between starts_at and ends_at. The final_answer must mention every offer and all required attributes for each. Verification consists of extracting offer information from the final_answer and cross-referencing it deterministically with what is present in the final_db.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Validate final_answer is non-empty and includes NA-East shop offers\",\n        \"Extract all offers listed in final_answer and their item/bundle name, rarity, category, price in V-Bucks, and time remaining\",\n        \"For the current timestamp, query shop_offers in region NA-East that are active (starts_at <= now < ends_at)\",\n        \"Cross-verify each offer in final_answer with database contents for: name, rarity, category, price\",\n        \"Check the 'time remaining' calculation in the answer is correct (ends_at - now)\",\n        \"Ensure no offers are missing, extra, or incorrect in final_answer\",\n        \"Return complete only if all conditions 100% met\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    import datetime\\n\\n    # Helper to get rows from DB safely\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Helper to get item info by id\\n    def get_item_info(db_path: str, item_id: int) -> dict:\\n        rows = safe_query(db_path, \\\"SELECT name, rarity, category FROM items WHERE id = ?\\\", (item_id,))\\n        if rows:\\n            name, rarity, category = rows[0]\\n            return {\\\"name\\\": name, \\\"rarity\\\": rarity, \\\"category\\\": category}\\n        return {}\\n\\n    # Helper to get region id for NA-East\\n    region_rows = safe_query(final_db_path, \\\"SELECT id FROM regions WHERE code = ?\\\", (\\\"NA-EAST\\\",))\\n    if not region_rows or len(region_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    region_id = region_rows[0][0]\\n\\n    # Get all current shop_offers for NA-East at now\\n    # We'll take \\\"now\\\" as max(updated_at) from regions table to avoid time ambiguity\\n    now_rows = safe_query(final_db_path, \\\"SELECT MAX(updated_at) FROM regions WHERE id = ?\\\", (region_id,))\\n    if not now_rows or not now_rows[0][0]:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    now_str = now_rows[0][0]\\n    try:\\n        now_dt = datetime.datetime.strptime(now_str, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Get all offers active at now for NA-East\\n    offers = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, offered_item_id, price_vbucks, starts_at, ends_at, title_override FROM shop_offers WHERE region_id = ? AND starts_at <= ? AND ends_at > ?\\\",\\n        (region_id, now_str, now_str)\\n    )\\n    if not offers:\\n        # No offers, but user should have noted that\\n        if final_answer and re.search(r\\\"no offers|shop is empty\\\", final_answer, re.IGNORECASE):\\n            return {\\\"result\\\": \\\"complete\\\"}\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Build expected list\\n    expected_offers = []\\n    for offer in offers:\\n        offer_id, item_id, price, starts_at, ends_at, title_override = offer\\n        item_info = get_item_info(final_db_path, item_id)\\n        if not item_info or not item_info.get(\\\"name\\\") or not item_info.get(\\\"rarity\\\") or not item_info.get(\\\"category\\\"):\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # Use title_override if present for display name\\n        display_name = title_override if title_override and str(title_override).strip() != \\\"\\\" else item_info[\\\"name\\\"]\\n        # Time remaining in seconds\\n        try:\\n            end_dt = datetime.datetime.strptime(ends_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        except Exception:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        time_remaining = (end_dt - now_dt).total_seconds()\\n        expected_offers.append({\\n            \\\"display_name\\\": display_name,\\n            \\\"rarity\\\": item_info[\\\"rarity\\\"],\\n            \\\"category\\\": item_info[\\\"category\\\"],\\n            \\\"price\\\": price,\\n            \\\"time_remaining\\\": time_remaining,\\n            \\\"ends_at\\\": ends_at\\n        })\\n\\n    # Defensive: Check reasonable time_remaining for all offers\\n    if any(o[\\\"time_remaining\\\"] <= 0 for o in expected_offers):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Defensive: Check answer provided\\n    if final_answer is None or len(str(final_answer).strip()) == 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Regex patterns to extract entries: try to match individual offers (robust, ignore formatting)\\n    # Each offer must have name, rarity, category, price, and time\\n    # Example: 'name: Galaxy Scout, rarity: Epic, category: Outfit, price: 1500 V-Bucks, time remaining: ...'\\n    # Allow for optional field order, so build a flexible pattern\\n    offer_pattern = re.compile(\\n        r\\\"(?:name\\\\s*[:=]\\\\s*(?P<name>[\\\\w \\\\-']+)[,;])?\\\\s*\\\"\\n        r\\\"rarity\\\\s*[:=]\\\\s*(?P<rarity>Legendary|Epic|Rare|Uncommon|Common|Mythic)[,;]?\\\\s*\\\"\\n        r\\\"category\\\\s*[:=]\\\\s*(?P<category>Outfit|Emote|Wrap|Bundle)[,;]?\\\\s*\\\"\\n        r\\\"price\\\\s*[:=]\\\\s*(?P<price>\\\\d+)\\\\s*V-?Bucks[,;]?\\\\s*\\\"\\n        r\\\"time\\\\s*remaining\\\\s*[:=]\\\\s*(?P<time_remaining>[\\\\w :.-]+)\\\",\\n        re.IGNORECASE\\n    )\\n\\n    # Find all offers presented in final_answer\\n    found_offers = []\\n    for m in offer_pattern.finditer(final_answer):\\n        offer_dict = {\\n            \\\"display_name\\\": m.group(\\\"name\\\").strip() if m.group(\\\"name\\\") else None,\\n            \\\"rarity\\\": m.group(\\\"rarity\\\").strip() if m.group(\\\"rarity\\\") else None,\\n            \\\"category\\\": m.group(\\\"category\\\").strip() if m.group(\\\"category\\\") else None,\\n            \\\"price\\\": int(m.group(\\\"price\\\")) if m.group(\\\"price\\\") and m.group(\\\"price\\\").isdigit() else None,\\n            \\\"time_remaining_text\\\": m.group(\\\"time_remaining\\\").strip() if m.group(\\\"time_remaining\\\") else None\\n        }\\n        found_offers.append(offer_dict)\\n\\n    # If no offers found, or not all fields present per offer, fail\\n    if len(found_offers) == 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check each expected offer is matched by an entry in found_offers\\n    matched_count = 0\\n    used_indices = set()\\n    for expected in expected_offers:\\n        match_found = False\\n        for idx, found in enumerate(found_offers):\\n            if idx in used_indices:\\n                continue\\n            # Match display name flexibly: exact or case-insensitive\\n            answer_name = (found[\\\"display_name\\\"] or \\\"\\\").strip()\\n            db_name = expected[\\\"display_name\\\"].strip()\\n            if answer_name.lower() != db_name.lower():\\n                continue\\n            if found[\\\"rarity\\\"] != expected[\\\"rarity\\\"]:\\n                continue\\n            if found[\\\"category\\\"] != expected[\\\"category\\\"]:\\n                continue\\n            if found[\\\"price\\\"] != expected[\\\"price\\\"]:\\n                continue\\n            # Try to match time remaining\\n            answer_time = found[\\\"time_remaining_text\\\"]\\n            if answer_time is None or len(answer_time) == 0:\\n                continue\\n            # Acceptable answer formats: '23h 59m', '1d 1h', '86399s', etc.\\n            # Convert expected time_remaining to human format for comparison\\n            secs = int(round(expected[\\\"time_remaining\\\"]))\\n            # Build multiple possible representations (hours/minutes/seconds)\\n            def format_time(secs: int) -> list:\\n                out = []\\n                # Option 1: xh ym zs\\n                h = secs // 3600\\n                m = (secs % 3600) // 60\\n                s = secs % 60\\n                if h > 0:\\n                    out.append(f\\\"{h}h {m}m\\\")\\n                    if s > 0:\\n                        out.append(f\\\"{h}h {m}m {s}s\\\")\\n                elif m > 0:\\n                    out.append(f\\\"{m}m {s}s\\\")\\n                else:\\n                    out.append(f\\\"{s}s\\\")\\n                # Option 2: x days y hours\\n                d = secs // 86400\\n                hr = (secs % 86400) // 3600\\n                if d > 0:\\n                    out.append(f\\\"{d}d {hr}h\\\")\\n                    if m > 0:\\n                        out.append(f\\\"{d}d {hr}h {m}m\\\")\\n                # Option 3: \\\"{secs}s\\\"\\n                out.append(f\\\"{secs}s\\\")\\n                # Option 4: \\\"{secs} seconds\\\"\\n                out.append(f\\\"{secs} seconds\\\")\\n                return out\\n            expected_time_variants = [s.lower() for s in format_time(secs)]\\n            # Accept if answer_time matches any variant (flexible, ignore whitespace)\\n            answer_time_normalized = re.sub(r\\\"\\\\s+\\\", \\\" \\\", answer_time.lower().strip())\\n            variant_matched = any(v in answer_time_normalized for v in expected_time_variants)\\n            if not variant_matched:\\n                continue\\n            match_found = True\\n            used_indices.add(idx)\\n            break\\n        if match_found:\\n            matched_count += 1\\n\\n    # All expected offers must be matched, and no extra offers (strict)\\n    if matched_count == len(expected_offers) and len(found_offers) == len(expected_offers):\\n        return {\\\"result\\\": \\\"complete\\\"}\\n\\n    return {\\\"result\\\": \\\"others\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 1, "task": "Filter the current shop to only show Outfit (skin) offers with rarity Epic or Legendary, sort them by price ascending, and return the cheapest three offer IDs with their names and prices.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime\n\n    # Helper: DB query using read-only mode\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Helper: Parse answer for a list of offers with offer ID, name, price\n    def parse_offers(answer: str) -> list:\n        if not answer or not isinstance(answer, str):\n            return []\n        # Acceptable formats:\n        # 1. Table: ID | Name | Price\n        # 2. List: Offer ID: ..., Name: ..., Price: ...\n        offer_pattern = re.compile(\n            r\"(?:Offer ID[:=]\\s*(\\d+)[,;\\s]*)?Name[:=]\\s*([^,\\n]+)[,;\\s]*Price[:=]\\s*(\\d+)\", re.IGNORECASE\n        )\n        simple_table_pattern = re.compile(\n            r\"(\\d+)\\s*[|\\t]\\s*([^|\\n]+)\\s*[|\\t]\\s*(\\d+)\", re.IGNORECASE\n        )\n        offers = []\n        # Try detailed pattern\n        for m in offer_pattern.finditer(answer):\n            offer_id = m.group(1)\n            name = m.group(2)\n            price = m.group(3)\n            # Defensive: Only keep if all present\n            if offer_id and name and price:\n                offers.append((int(offer_id), name.strip(), int(price)))\n        # If empty, try simple table pattern\n        if not offers:\n            for m in simple_table_pattern.finditer(answer):\n                offer_id = m.group(1)\n                name = m.group(2)\n                price = m.group(3)\n                if offer_id and name and price:\n                    offers.append((int(offer_id), name.strip(), int(price)))\n        return offers\n\n    # Step 1: Parse offers from final_answer\n    answer_offers = parse_offers(final_answer)\n    if len(answer_offers) != 3:\n        return {\"result\": \"others\"}\n\n    # Step 2: Get the list of valid shop offers from DB\n    # Only offers for region_id=1, currently active, category='Outfit', rarity in Epic/Legendary\n    current_time = safe_query(final_db_path, \"SELECT datetime('now')\")\n    now_str = current_time[0][0] if current_time and current_time[0][0] else None\n    if not now_str:\n        # Use a fallback fixed date\n        now_str = \"2026-02-18 06:18:36\"\n    try:\n        now_dt = datetime.strptime(now_str, \"%Y-%m-%d %H:%M:%S\")\n    except Exception:\n        now_dt = datetime.strptime(\"2026-02-18 06:18:36\", \"%Y-%m-%d %H:%M:%S\")\n\n    # Query valid Outfit offers\n    db_query = \"\"\"\n        SELECT s.id, i.name, s.price_vbucks\n        FROM shop_offers s\n        JOIN items i ON s.offered_item_id = i.id\n        WHERE s.region_id = 1\n          AND s.starts_at <= ? AND s.ends_at > ?\n          AND i.category = 'Outfit'\n          AND i.rarity IN ('Epic','Legendary')\n        ORDER BY s.price_vbucks ASC, s.id ASC\n    \"\"\"\n    shop_offers = safe_query(final_db_path, db_query, (now_str, now_str))\n    # Defensive: If fewer than 3 such offers, cannot match task\n    if len(shop_offers) < 3:\n        return {\"result\": \"others\"}\n\n    # Step 3: Get the three cheapest offers\n    cheapest_three = shop_offers[:3]\n\n    # Step 4: Compare with answer_offers: all fields must match, must be sorted by price ascending\n    for idx in range(3):\n        db_offer = cheapest_three[idx]\n        ans_offer = answer_offers[idx]\n        # DB has (offer_id, name, price), ans_offer has same\n        if (db_offer[0] != ans_offer[0]\n            or db_offer[1].strip().lower() != ans_offer[1].strip().lower()\n            or db_offer[2] != ans_offer[2]):\n            return {\"result\": \"others\"}\n    # Also, check ascending sort in answer_offers\n    prices = [price for (_, _, price) in answer_offers]\n    if prices != sorted(prices):\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task is a query-only operation. The user expects, as a response, a list of the cheapest three Outfit (skin) offers with rarity Epic or Legendary from the current shop, sorted by price ascending, including each: offer ID, name, and price. To verify completion: (1) Parse and validate final_answer for exactly three offers, each containing the requested fields in the correct order and format. (2) Cross-check that these offers are indeed present and active in the 'shop_offers' table at the current time for region_id 1, correspond to items in the 'items' table matching category 'Outfit' and rarity in ('Epic', 'Legendary'), and are sorted by price ascending. (3) Validate the cheapest three offers (by price ascending) match those returned in final_answer with exact ID, name, and price. If all conditions are met, return complete. Otherwise or if any ambiguity exists, return others.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Parse final_answer for exactly three records of offer ID, name, and price.\",\n        \"Verify each offer ID, name, and price matches current shop_offers for Outfits with rarity Epic or Legendary.\",\n        \"Ensure answers are sorted by price ascending and are the three cheapest.\",\n        \"Confirm output format and types (integers for IDs/prices, string for names) are valid.\",\n        \"Handle missing, malformed, or ambiguous responses defensively.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime\\n\\n    # Helper: DB query using read-only mode\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Helper: Parse answer for a list of offers with offer ID, name, price\\n    def parse_offers(answer: str) -> list:\\n        if not answer or not isinstance(answer, str):\\n            return []\\n        # Acceptable formats:\\n        # 1. Table: ID | Name | Price\\n        # 2. List: Offer ID: ..., Name: ..., Price: ...\\n        offer_pattern = re.compile(\\n            r\\\"(?:Offer ID[:=]\\\\s*(\\\\d+)[,;\\\\s]*)?Name[:=]\\\\s*([^,\\\\n]+)[,;\\\\s]*Price[:=]\\\\s*(\\\\d+)\\\", re.IGNORECASE\\n        )\\n        simple_table_pattern = re.compile(\\n            r\\\"(\\\\d+)\\\\s*[|\\\\t]\\\\s*([^|\\\\n]+)\\\\s*[|\\\\t]\\\\s*(\\\\d+)\\\", re.IGNORECASE\\n        )\\n        offers = []\\n        # Try detailed pattern\\n        for m in offer_pattern.finditer(answer):\\n            offer_id = m.group(1)\\n            name = m.group(2)\\n            price = m.group(3)\\n            # Defensive: Only keep if all present\\n            if offer_id and name and price:\\n                offers.append((int(offer_id), name.strip(), int(price)))\\n        # If empty, try simple table pattern\\n        if not offers:\\n            for m in simple_table_pattern.finditer(answer):\\n                offer_id = m.group(1)\\n                name = m.group(2)\\n                price = m.group(3)\\n                if offer_id and name and price:\\n                    offers.append((int(offer_id), name.strip(), int(price)))\\n        return offers\\n\\n    # Step 1: Parse offers from final_answer\\n    answer_offers = parse_offers(final_answer)\\n    if len(answer_offers) != 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 2: Get the list of valid shop offers from DB\\n    # Only offers for region_id=1, currently active, category='Outfit', rarity in Epic/Legendary\\n    current_time = safe_query(final_db_path, \\\"SELECT datetime('now')\\\")\\n    now_str = current_time[0][0] if current_time and current_time[0][0] else None\\n    if not now_str:\\n        # Use a fallback fixed date\\n        now_str = \\\"2026-02-18 06:18:36\\\"\\n    try:\\n        now_dt = datetime.strptime(now_str, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    except Exception:\\n        now_dt = datetime.strptime(\\\"2026-02-18 06:18:36\\\", \\\"%Y-%m-%d %H:%M:%S\\\")\\n\\n    # Query valid Outfit offers\\n    db_query = \\\"\\\"\\\"\\n        SELECT s.id, i.name, s.price_vbucks\\n        FROM shop_offers s\\n        JOIN items i ON s.offered_item_id = i.id\\n        WHERE s.region_id = 1\\n          AND s.starts_at <= ? AND s.ends_at > ?\\n          AND i.category = 'Outfit'\\n          AND i.rarity IN ('Epic','Legendary')\\n        ORDER BY s.price_vbucks ASC, s.id ASC\\n    \\\"\\\"\\\"\\n    shop_offers = safe_query(final_db_path, db_query, (now_str, now_str))\\n    # Defensive: If fewer than 3 such offers, cannot match task\\n    if len(shop_offers) < 3:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: Get the three cheapest offers\\n    cheapest_three = shop_offers[:3]\\n\\n    # Step 4: Compare with answer_offers: all fields must match, must be sorted by price ascending\\n    for idx in range(3):\\n        db_offer = cheapest_three[idx]\\n        ans_offer = answer_offers[idx]\\n        # DB has (offer_id, name, price), ans_offer has same\\n        if (db_offer[0] != ans_offer[0]\\n            or db_offer[1].strip().lower() != ans_offer[1].strip().lower()\\n            or db_offer[2] != ans_offer[2]):\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Also, check ascending sort in answer_offers\\n    prices = [price for (_, _, price) in answer_offers]\\n    if prices != sorted(prices):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 3, "task": "Purchase the single-item offer 'Nebula Wrap' using my V-Bucks wallet, then return the purchase receipt ID, total charged, wallet balance after purchase, and the new entitlement/inventory item ID.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    # Helper: query database, returns list of rows\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # 1. Locate 'Nebula Wrap' item and offer\n    item_res = safe_query(final_db_path, \"SELECT id FROM items WHERE name=? AND category='Wrap'\", (\"Nebula Wrap\",))\n    if not item_res or not isinstance(item_res[0][0], int):\n        return {\"result\": \"others\"}\n    nebula_item_id = item_res[0][0]\n    offer_res = safe_query(final_db_path, \"SELECT id, price_vbucks FROM shop_offers WHERE offered_item_id=? ORDER BY starts_at DESC LIMIT 1\", (nebula_item_id,))\n    if not offer_res or not isinstance(offer_res[0][0], int):\n        return {\"result\": \"others\"}\n    nebula_offer_id, nebula_price = offer_res[0][0], offer_res[0][1]\n\n    # 2. Find new purchase_receipt for user 1, for correct offer\n    receipts_before = set([r[0] for r in safe_query(initial_db_path, \"SELECT id FROM purchase_receipts WHERE user_id=?\", (1,))])\n    receipts_after = safe_query(final_db_path, \"SELECT id, offer_id, status FROM purchase_receipts WHERE user_id=?\", (1,))\n    # Find new receipts w/ correct offer_id and status 'completed'\n    new_receipts = [r for r in receipts_after if r[0] not in receipts_before and r[1]==nebula_offer_id and r[2]=='completed']\n    if len(new_receipts)!=1:\n        return {\"result\": \"others\"}\n    receipt_id = new_receipts[0][0]\n\n    # 3. Check receipt_items for Nebula Wrap purchase\n    pi_res = safe_query(final_db_path, \"SELECT item_id FROM purchase_receipt_items WHERE receipt_id=?\", (receipt_id,))\n    nebula_item_ids = [row[0] for row in pi_res]\n    if nebula_item_id not in nebula_item_ids or len(nebula_item_ids)!=1:\n        return {\"result\": \"others\"}\n\n    # 4. Check purchase_receipt amount\n    pr_res = safe_query(final_db_path, \"SELECT total_charged_vbucks FROM purchase_receipts WHERE id=?\", (receipt_id,))\n    if not pr_res or not isinstance(pr_res[0][0], int):\n        return {\"result\": \"others\"}\n    charged = pr_res[0][0]\n    if charged!=nebula_price:\n        return {\"result\": \"others\"}\n\n    # 5. Wallet ledger: new entry for this receipt\n    ledger_before = set([row[0] for row in safe_query(initial_db_path, \"SELECT id FROM wallet_ledger WHERE user_id=?\", (1,))])\n    ledger_after = safe_query(final_db_path, \"SELECT id, entry_type, amount_vbucks, balance_after_vbucks, reference_type, reference_id FROM wallet_ledger WHERE user_id=?\", (1,))\n    ledger_entry = [row for row in ledger_after if row[0] not in ledger_before and row[1]=='purchase' and row[4]=='purchase_receipt' and row[5]==receipt_id]\n    if len(ledger_entry)!=1:\n        return {\"result\": \"others\"}\n    charged_entry = ledger_entry[0][2]\n    if charged_entry != -charged:\n        return {\"result\": \"others\"}\n    ledger_final_balance = ledger_entry[0][3]\n\n    # 6. Wallet table: balance should match ledger\n    w_final = safe_query(final_db_path, \"SELECT balance_vbucks FROM wallets WHERE user_id=?\", (1,))\n    if not w_final or not isinstance(w_final[0][0], int):\n        return {\"result\": \"others\"}\n    wallet_after = w_final[0][0]\n    if wallet_after != ledger_final_balance:\n        return {\"result\": \"others\"}\n\n    # 7. Entitlements: new entitlement for Nebula Wrap\n    ent_before = set([row[0] for row in safe_query(initial_db_path, \"SELECT id FROM entitlements WHERE user_id=? AND item_id=?\", (1, nebula_item_id))])\n    ent_after = safe_query(final_db_path, \"SELECT id, item_id, source_type, source_id FROM entitlements WHERE user_id=? AND item_id=? AND revoked_at IS NULL\", (1, nebula_item_id))\n    new_entitlements = [row for row in ent_after if row[0] not in ent_before and row[2]=='purchase' and row[3]==receipt_id]\n    if len(new_entitlements)!=1:\n        return {\"result\": \"others\"}\n    entitlement_id = new_entitlements[0][0]\n\n    # 8. Parental controls/compliance check: no compliance/purchase errors for this receipt\n    comp_res = safe_query(final_db_path, \"SELECT id FROM compliance_errors WHERE user_id=? AND offer_id=? AND action_type='purchase'\", (1, nebula_offer_id))\n    if comp_res:\n        return {\"result\": \"others\"}\n    # Make sure parental_controls spend_remaining is not negative\n    pc_res = safe_query(final_db_path, \"SELECT spend_remaining_vbucks FROM parental_controls WHERE user_id=?\", (1,))\n    if pc_res and isinstance(pc_res[0][0], int) and pc_res[0][0]<0:\n        return {\"result\": \"others\"}\n\n    # 9. Validate agent's answer: extract 4 fields from text\n    fields = {\"receipt_id\": None, \"total_charged\": None, \"wallet_balance\": None, \"entitlement_id\": None}\n    ftext = final_answer if final_answer else ''\n    # receipt id: look for 4/5 digit int (matches DB receipt_id)\n    rec_id_match = re.search(r'receipt[ _-]?id[^\\d]*(\\d{4,6})', ftext, re.IGNORECASE)\n    if rec_id_match:\n        fields[\"receipt_id\"] = int(rec_id_match.group(1))\n    # total charged: vbucks pattern\n    charged_match = re.search(r'(total|charge[d]?|amount)[^\\d]*([\\d]{1,5})\\s*vbucks', ftext, re.IGNORECASE)\n    if charged_match:\n        fields[\"total_charged\"] = int(charged_match.group(2))\n    # wallet balance: vbucks\n    bal_match = re.search(r'(wallet|balance)[^\\d]*([\\d]{1,5})\\s*vbucks', ftext, re.IGNORECASE)\n    if bal_match:\n        fields[\"wallet_balance\"] = int(bal_match.group(2))\n    # entitlement id\n    ent_id_match = re.search(r'entitlement[ _-]?id[^\\d]*(\\d{4,6})', ftext, re.IGNORECASE)\n    if ent_id_match:\n        fields[\"entitlement_id\"] = int(ent_id_match.group(1))\n\n    # All fields required and must match DB\n    expect = {\n        \"receipt_id\": receipt_id,\n        \"total_charged\": charged,\n        \"wallet_balance\": wallet_after,\n        \"entitlement_id\": entitlement_id\n    }\n    # Defensive: All present and match\n    for k in fields:\n        if fields[k] is None or fields[k] != expect[k]:\n            return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task requires the agent to purchase the single-item offer 'Nebula Wrap' using the user's V-Bucks wallet, and return the purchase receipt ID, total charged V-Bucks, wallet balance after purchase, and the new entitlement item ID in their answer. To verify successful completion, we must: 1) Check that a new purchase was actually made for 'Nebula Wrap', with correct offer/receipt in the database; 2) Ensure the wallet was debited accordingly, balance updated; 3) Confirm a new entitlement was added for the user for the correct item, and its source matches the purchase; 4) Cross-check these fields (receipt ID, charged, balance, entitlement ID) with the agent's answer. All conditions must be matched exactly; otherwise, return 'others'.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Identify shop_offers record for 'Nebula Wrap', get its offer_id (single-item, category == 'Wrap', name == 'Nebula Wrap').\",\n        \"Compare purchase_receipts for user 1 in initial and final DB: find a new, completed 'purchase' receipt for this offer_id.\",\n        \"Check the new purchase_receipt_items: confirm a new record for receipt_id and item_id = Nebula Wrap.\",\n        \"Check wallet_ledger: ensure user 1 has a new purchase entry linked to the new receipt, amount matches offer price, balance_after matches wallet table.\",\n        \"Check wallets table: verify balance reflects deduction.\",\n        \"Check entitlements: confirm a new entitlement for user 1 and item_id = Nebula Wrap, source_type = 'purchase', and source_id = receipt_id.\",\n        \"Extract purchase receipt ID, total charged, final wallet balance, and new entitlement ID from final_answer using regex; verify all values match database records.\",\n        \"Handle edge cases: multiple new purchases, malformed answer, missing fields, parental controls, compliance errors.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    # Helper: query database, returns list of rows\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # 1. Locate 'Nebula Wrap' item and offer\\n    item_res = safe_query(final_db_path, \\\"SELECT id FROM items WHERE name=? AND category='Wrap'\\\", (\\\"Nebula Wrap\\\",))\\n    if not item_res or not isinstance(item_res[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    nebula_item_id = item_res[0][0]\\n    offer_res = safe_query(final_db_path, \\\"SELECT id, price_vbucks FROM shop_offers WHERE offered_item_id=? ORDER BY starts_at DESC LIMIT 1\\\", (nebula_item_id,))\\n    if not offer_res or not isinstance(offer_res[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    nebula_offer_id, nebula_price = offer_res[0][0], offer_res[0][1]\\n\\n    # 2. Find new purchase_receipt for user 1, for correct offer\\n    receipts_before = set([r[0] for r in safe_query(initial_db_path, \\\"SELECT id FROM purchase_receipts WHERE user_id=?\\\", (1,))])\\n    receipts_after = safe_query(final_db_path, \\\"SELECT id, offer_id, status FROM purchase_receipts WHERE user_id=?\\\", (1,))\\n    # Find new receipts w/ correct offer_id and status 'completed'\\n    new_receipts = [r for r in receipts_after if r[0] not in receipts_before and r[1]==nebula_offer_id and r[2]=='completed']\\n    if len(new_receipts)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    receipt_id = new_receipts[0][0]\\n\\n    # 3. Check receipt_items for Nebula Wrap purchase\\n    pi_res = safe_query(final_db_path, \\\"SELECT item_id FROM purchase_receipt_items WHERE receipt_id=?\\\", (receipt_id,))\\n    nebula_item_ids = [row[0] for row in pi_res]\\n    if nebula_item_id not in nebula_item_ids or len(nebula_item_ids)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check purchase_receipt amount\\n    pr_res = safe_query(final_db_path, \\\"SELECT total_charged_vbucks FROM purchase_receipts WHERE id=?\\\", (receipt_id,))\\n    if not pr_res or not isinstance(pr_res[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    charged = pr_res[0][0]\\n    if charged!=nebula_price:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Wallet ledger: new entry for this receipt\\n    ledger_before = set([row[0] for row in safe_query(initial_db_path, \\\"SELECT id FROM wallet_ledger WHERE user_id=?\\\", (1,))])\\n    ledger_after = safe_query(final_db_path, \\\"SELECT id, entry_type, amount_vbucks, balance_after_vbucks, reference_type, reference_id FROM wallet_ledger WHERE user_id=?\\\", (1,))\\n    ledger_entry = [row for row in ledger_after if row[0] not in ledger_before and row[1]=='purchase' and row[4]=='purchase_receipt' and row[5]==receipt_id]\\n    if len(ledger_entry)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    charged_entry = ledger_entry[0][2]\\n    if charged_entry != -charged:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    ledger_final_balance = ledger_entry[0][3]\\n\\n    # 6. Wallet table: balance should match ledger\\n    w_final = safe_query(final_db_path, \\\"SELECT balance_vbucks FROM wallets WHERE user_id=?\\\", (1,))\\n    if not w_final or not isinstance(w_final[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    wallet_after = w_final[0][0]\\n    if wallet_after != ledger_final_balance:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. Entitlements: new entitlement for Nebula Wrap\\n    ent_before = set([row[0] for row in safe_query(initial_db_path, \\\"SELECT id FROM entitlements WHERE user_id=? AND item_id=?\\\", (1, nebula_item_id))])\\n    ent_after = safe_query(final_db_path, \\\"SELECT id, item_id, source_type, source_id FROM entitlements WHERE user_id=? AND item_id=? AND revoked_at IS NULL\\\", (1, nebula_item_id))\\n    new_entitlements = [row for row in ent_after if row[0] not in ent_before and row[2]=='purchase' and row[3]==receipt_id]\\n    if len(new_entitlements)!=1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    entitlement_id = new_entitlements[0][0]\\n\\n    # 8. Parental controls/compliance check: no compliance/purchase errors for this receipt\\n    comp_res = safe_query(final_db_path, \\\"SELECT id FROM compliance_errors WHERE user_id=? AND offer_id=? AND action_type='purchase'\\\", (1, nebula_offer_id))\\n    if comp_res:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Make sure parental_controls spend_remaining is not negative\\n    pc_res = safe_query(final_db_path, \\\"SELECT spend_remaining_vbucks FROM parental_controls WHERE user_id=?\\\", (1,))\\n    if pc_res and isinstance(pc_res[0][0], int) and pc_res[0][0]<0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 9. Validate agent's answer: extract 4 fields from text\\n    fields = {\\\"receipt_id\\\": None, \\\"total_charged\\\": None, \\\"wallet_balance\\\": None, \\\"entitlement_id\\\": None}\\n    ftext = final_answer if final_answer else ''\\n    # receipt id: look for 4/5 digit int (matches DB receipt_id)\\n    rec_id_match = re.search(r'receipt[ _-]?id[^\\\\d]*(\\\\d{4,6})', ftext, re.IGNORECASE)\\n    if rec_id_match:\\n        fields[\\\"receipt_id\\\"] = int(rec_id_match.group(1))\\n    # total charged: vbucks pattern\\n    charged_match = re.search(r'(total|charge[d]?|amount)[^\\\\d]*([\\\\d]{1,5})\\\\s*vbucks', ftext, re.IGNORECASE)\\n    if charged_match:\\n        fields[\\\"total_charged\\\"] = int(charged_match.group(2))\\n    # wallet balance: vbucks\\n    bal_match = re.search(r'(wallet|balance)[^\\\\d]*([\\\\d]{1,5})\\\\s*vbucks', ftext, re.IGNORECASE)\\n    if bal_match:\\n        fields[\\\"wallet_balance\\\"] = int(bal_match.group(2))\\n    # entitlement id\\n    ent_id_match = re.search(r'entitlement[ _-]?id[^\\\\d]*(\\\\d{4,6})', ftext, re.IGNORECASE)\\n    if ent_id_match:\\n        fields[\\\"entitlement_id\\\"] = int(ent_id_match.group(1))\\n\\n    # All fields required and must match DB\\n    expect = {\\n        \\\"receipt_id\\\": receipt_id,\\n        \\\"total_charged\\\": charged,\\n        \\\"wallet_balance\\\": wallet_after,\\n        \\\"entitlement_id\\\": entitlement_id\\n    }\\n    # Defensive: All present and match\\n    for k in fields:\\n        if fields[k] is None or fields[k] != expect[k]:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 4, "task": "Gift the emote offer 'Electro Shuffle' to my friend account 'PlayerTwo42' with the message 'Happy drops! Enjoy this emote.', and return the gifting transaction ID and delivery status.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ()):      \n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            c = conn.cursor()\n            c.execute(query, params)\n            rows = c.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Step 1: Get ids for actors and item(s)\n    sender_username = 'PlayerOne'\n    recipient_username = 'PlayerTwo42'\n    emote_name = 'Electro Shuffle'\n    gift_message = 'Happy drops! Enjoy this emote.'\n    required_status = 'delivered'\n    \n    # Get user ids\n    sender_rows = safe_query(final_db_path, \"SELECT id FROM users WHERE username = ?\", (sender_username,))\n    sender_id = sender_rows[0][0] if sender_rows else None\n    recipient_rows = safe_query(final_db_path, \"SELECT id FROM users WHERE username = ?\", (recipient_username,))\n    recipient_id = recipient_rows[0][0] if recipient_rows else None\n    if not (sender_id and recipient_id):\n        return {\"result\": \"others\"}\n\n    # Get item_id for Electro Shuffle and validate\n    item_rows = safe_query(final_db_path, \"SELECT id FROM items WHERE name = ? AND category = 'Emote'\", (emote_name,))\n    if not item_rows:\n        return {\"result\": \"others\"}\n    item_id = item_rows[0][0]\n\n    # Find shop offer(s) for Electro Shuffle in region NA-EAST (region_id=1 or region doesn't matter as long as offer matches)\n    offer_rows = safe_query(final_db_path, \"SELECT id FROM shop_offers WHERE offered_item_id = ?\", (item_id,))\n    if not offer_rows:\n        return {\"result\": \"others\"}\n    offer_ids = set([r[0] for r in offer_rows])\n\n    # Step 2: Find new gift transaction in final DB but not initial DB for this sender/recipient/offer/message\n    # First, get all gift transaction ids for sender in initial DB\n    initial_gift_ids = set([r[0] for r in safe_query(initial_db_path, \"SELECT id FROM gift_transactions WHERE sender_user_id = ?\", (sender_id,))])\n    \n    # Now, get all matching gift_transactions in final DB with exact match\n    gift_tx_rows = safe_query(final_db_path, \\\n        \"SELECT id, offer_id, recipient_user_id, message, status FROM gift_transactions WHERE sender_user_id = ?\", (sender_id,))\n    matching_gift_ids = []\n    for tx in gift_tx_rows:\n        tx_id, tx_offer, tx_recipient, tx_message, tx_status = tx\n        if tx_id in initial_gift_ids:\n            continue  # existed before\n        if tx_offer not in offer_ids:\n            continue\n        if tx_recipient != recipient_id:\n            continue\n        if (tx_message or '').strip() != gift_message:\n            continue\n        if tx_status != required_status:\n            continue\n        matching_gift_ids.append(tx_id)\n    # If not exactly one clear candidate, ambiguous or not complete\n    if len(matching_gift_ids) != 1:\n        return {\"result\": \"others\"}\n    gift_transaction_id = matching_gift_ids[0]\n\n    # Step 3: Check gift_transaction_items links this transaction to Electro Shuffle (item_id)\n    tx_item_rows = safe_query(final_db_path, \"SELECT item_id FROM gift_transaction_items WHERE gift_transaction_id = ?\", (gift_transaction_id,))\n    if not any(iid[0] == item_id for iid in tx_item_rows):\n        return {\"result\": \"others\"}\n\n    # Step 4: Check entitlements granted\n    initial_entitlements = set([r[0] for r in safe_query(initial_db_path, \\\n        \"SELECT id FROM entitlements WHERE user_id = ? AND item_id = ? AND source_type = 'gift' AND revoked_at IS NULL\", (recipient_id, item_id))])\n    # In final DB, find all entitlements for player2, item, source_type='gift', revoked_at is NULL\n    # There must be exactly one new entitlement; source_id must point to the gift_transaction_id\n    final_entitlements = safe_query(final_db_path, \\\n        \"SELECT id, source_id FROM entitlements WHERE user_id = ? AND item_id = ? AND source_type = 'gift' AND revoked_at IS NULL\", (recipient_id, item_id))\n    new_entitlements = [row for row in final_entitlements if row[0] not in initial_entitlements]\n    if len(new_entitlements) != 1:\n        return {\"result\": \"others\"}\n    entitlement_source_id = new_entitlements[0][1]\n    if entitlement_source_id != gift_transaction_id:\n        return {\"result\": \"others\"}\n\n    # Step 5: If final_answer is present, must extract transaction id and status and confirm correctness\n    if final_answer:\n        # Allow for variations like id, transaction id, etc, and delivered/delivery status\n        txid_patterns = [\n            r\"transaction\\s*[iI][dD]\\s*[:#]?\\s*(\\d+)\",\n            r\"gift\\s*[iI][dD]\\s*[:#]?\\s*(\\d+)\"\n        ]\n        status_patterns = [\n            r\"delivery\\s*status\\s*[:#]?\\s*['\\\"]?([a-zA-Z]+)['\\\"]?\",\n            r\"status\\s*[:#]?\\s*['\\\"]?([a-zA-Z]+)['\\\"]?\",\n            r\"delivered\"\n        ]\n        found_id = None\n        for pat in txid_patterns:\n            m = re.search(pat, final_answer, re.IGNORECASE)\n            if m:\n                try:\n                    found_id = int(m.group(1))\n                except Exception:\n                    return {\"result\": \"others\"}\n                break\n        if found_id is not None:\n            if found_id != gift_transaction_id:\n                return {\"result\": \"others\"}\n        else:\n            # If no explicit id in answer, fail\n            return {\"result\": \"others\"}\n        # For delivery status: must match case-insensitive 'delivered' exactly\n        found_status = None\n        for pat in status_patterns:\n            m = re.search(pat, final_answer, re.IGNORECASE)\n            if m:\n                found_status = m.group(1).strip().lower() if m.lastindex else 'delivered'  # for last plain match\n                break\n        if found_status != 'delivered':\n            return {\"result\": \"others\"}\n\n    # All checks passed\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"The task is to gift the emote offer 'Electro Shuffle' to the friend account 'PlayerTwo42' with the exact message 'Happy drops! Enjoy this emote.', and to return the gifting transaction ID and delivery status. This requires verifying: (1) that after the agent acted, a new gift transaction exists where sender is 'PlayerOne', recipient is 'PlayerTwo42', offer matches 'Electro Shuffle', the message is exactly as given, and status is 'delivered'; (2) that this transaction is associated with gifting the 'Electro Shuffle' item; (3) an entitlement of 'gift' source for 'Electro Shuffle' is added for 'PlayerTwo42' and references this transaction; (4) final_answer, if present, includes the transaction ID and the actual delivery status reported (matching the DB). It is not sufficient for only the DB or only the answer to indicate success: they must agree and the task must be 100% fulfilled without ambiguity. Any missing, mismatched, or ambiguous detail results in failure.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Verify in items table that 'Electro Shuffle' exists and get the item_id (category='Emote')\",\n        \"Find exact matching shop_offers record for item 'Electro Shuffle' (check region, time window irrelevant as we just need the offer id used in gift)\",\n        \"Get user ids for 'PlayerOne' (sender) and 'PlayerTwo42' (recipient)\",\n        \"Compare initial and final DB gift_transactions: find a new transaction where sender is PlayerOne, recipient PlayerTwo42, offer matches 'Electro Shuffle', and message is exactly 'Happy drops! Enjoy this emote.', and status is 'delivered'\",\n        \"Check that a corresponding gift_transaction_items row exists linking this transaction id to the correct item_id\",\n        \"Check that the entitlements for PlayerTwo42 have a new row with item_id = 'Electro Shuffle', source_type='gift', source_id = the new transaction id, revoked_at is NULL (i.e. active)\",\n        \"If final_answer is provided, extract transaction id and delivery status, and ensure these match exactly what is in the DB\",\n        \"If any part is missing, ambiguous, or inconsistent, return {'result': 'others'}\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ()):      \\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            rows = c.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Step 1: Get ids for actors and item(s)\\n    sender_username = 'PlayerOne'\\n    recipient_username = 'PlayerTwo42'\\n    emote_name = 'Electro Shuffle'\\n    gift_message = 'Happy drops! Enjoy this emote.'\\n    required_status = 'delivered'\\n    \\n    # Get user ids\\n    sender_rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE username = ?\\\", (sender_username,))\\n    sender_id = sender_rows[0][0] if sender_rows else None\\n    recipient_rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE username = ?\\\", (recipient_username,))\\n    recipient_id = recipient_rows[0][0] if recipient_rows else None\\n    if not (sender_id and recipient_id):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Get item_id for Electro Shuffle and validate\\n    item_rows = safe_query(final_db_path, \\\"SELECT id FROM items WHERE name = ? AND category = 'Emote'\\\", (emote_name,))\\n    if not item_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    item_id = item_rows[0][0]\\n\\n    # Find shop offer(s) for Electro Shuffle in region NA-EAST (region_id=1 or region doesn't matter as long as offer matches)\\n    offer_rows = safe_query(final_db_path, \\\"SELECT id FROM shop_offers WHERE offered_item_id = ?\\\", (item_id,))\\n    if not offer_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    offer_ids = set([r[0] for r in offer_rows])\\n\\n    # Step 2: Find new gift transaction in final DB but not initial DB for this sender/recipient/offer/message\\n    # First, get all gift transaction ids for sender in initial DB\\n    initial_gift_ids = set([r[0] for r in safe_query(initial_db_path, \\\"SELECT id FROM gift_transactions WHERE sender_user_id = ?\\\", (sender_id,))])\\n    \\n    # Now, get all matching gift_transactions in final DB with exact match\\n    gift_tx_rows = safe_query(final_db_path, \\\\\\n        \\\"SELECT id, offer_id, recipient_user_id, message, status FROM gift_transactions WHERE sender_user_id = ?\\\", (sender_id,))\\n    matching_gift_ids = []\\n    for tx in gift_tx_rows:\\n        tx_id, tx_offer, tx_recipient, tx_message, tx_status = tx\\n        if tx_id in initial_gift_ids:\\n            continue  # existed before\\n        if tx_offer not in offer_ids:\\n            continue\\n        if tx_recipient != recipient_id:\\n            continue\\n        if (tx_message or '').strip() != gift_message:\\n            continue\\n        if tx_status != required_status:\\n            continue\\n        matching_gift_ids.append(tx_id)\\n    # If not exactly one clear candidate, ambiguous or not complete\\n    if len(matching_gift_ids) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    gift_transaction_id = matching_gift_ids[0]\\n\\n    # Step 3: Check gift_transaction_items links this transaction to Electro Shuffle (item_id)\\n    tx_item_rows = safe_query(final_db_path, \\\"SELECT item_id FROM gift_transaction_items WHERE gift_transaction_id = ?\\\", (gift_transaction_id,))\\n    if not any(iid[0] == item_id for iid in tx_item_rows):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: Check entitlements granted\\n    initial_entitlements = set([r[0] for r in safe_query(initial_db_path, \\\\\\n        \\\"SELECT id FROM entitlements WHERE user_id = ? AND item_id = ? AND source_type = 'gift' AND revoked_at IS NULL\\\", (recipient_id, item_id))])\\n    # In final DB, find all entitlements for player2, item, source_type='gift', revoked_at is NULL\\n    # There must be exactly one new entitlement; source_id must point to the gift_transaction_id\\n    final_entitlements = safe_query(final_db_path, \\\\\\n        \\\"SELECT id, source_id FROM entitlements WHERE user_id = ? AND item_id = ? AND source_type = 'gift' AND revoked_at IS NULL\\\", (recipient_id, item_id))\\n    new_entitlements = [row for row in final_entitlements if row[0] not in initial_entitlements]\\n    if len(new_entitlements) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    entitlement_source_id = new_entitlements[0][1]\\n    if entitlement_source_id != gift_transaction_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 5: If final_answer is present, must extract transaction id and status and confirm correctness\\n    if final_answer:\\n        # Allow for variations like id, transaction id, etc, and delivered/delivery status\\n        txid_patterns = [\\n            r\\\"transaction\\\\s*[iI][dD]\\\\s*[:#]?\\\\s*(\\\\d+)\\\",\\n            r\\\"gift\\\\s*[iI][dD]\\\\s*[:#]?\\\\s*(\\\\d+)\\\"\\n        ]\\n        status_patterns = [\\n            r\\\"delivery\\\\s*status\\\\s*[:#]?\\\\s*['\\\\\\\"]?([a-zA-Z]+)['\\\\\\\"]?\\\",\\n            r\\\"status\\\\s*[:#]?\\\\s*['\\\\\\\"]?([a-zA-Z]+)['\\\\\\\"]?\\\",\\n            r\\\"delivered\\\"\\n        ]\\n        found_id = None\\n        for pat in txid_patterns:\\n            m = re.search(pat, final_answer, re.IGNORECASE)\\n            if m:\\n                try:\\n                    found_id = int(m.group(1))\\n                except Exception:\\n                    return {\\\"result\\\": \\\"others\\\"}\\n                break\\n        if found_id is not None:\\n            if found_id != gift_transaction_id:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        else:\\n            # If no explicit id in answer, fail\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # For delivery status: must match case-insensitive 'delivered' exactly\\n        found_status = None\\n        for pat in status_patterns:\\n            m = re.search(pat, final_answer, re.IGNORECASE)\\n            if m:\\n                found_status = m.group(1).strip().lower() if m.lastindex else 'delivered'  # for last plain match\\n                break\\n        if found_status != 'delivered':\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 5, "task": "Add the items 'Galaxy Scout' and 'Star Wand' to my wishlist, then return my updated wishlist with item IDs, names, and whether each is currently in the shop.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime\n    \n    # Use a fixed timestamp for 'now' matching when agent would be acting (based on shop_offers/parental_controls/wallets update times),\n    # since we do not have wallclock and must be deterministic. We choose 2026-02-18 07:18:36 (from 'parental_controls', 'wallets').\n    NOW = '2026-02-18 07:18:36'\n    # Helper: get wishlist_id for user 1\n    def get_wishlist_id(db_path):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT id FROM wishlists WHERE user_id = 1\")\n            row = cursor.fetchone()\n            conn.close()\n            return row[0] if row else None\n        except Exception:\n            return None\n    # Helper: get wishlist items for a wishlist\n    def get_wishlist_items(db_path, wishlist_id):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT item_id FROM wishlist_items WHERE wishlist_id = ?\", (wishlist_id,))\n            rows = cursor.fetchall()\n            conn.close()\n            return set(r[0] for r in rows)\n        except Exception:\n            return set()\n    # Helper: get item details for supplied ids\n    def get_item_names(db_path, item_ids):\n        if not item_ids:\n            return {}\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            qmarks = ','.join(['?']*len(item_ids))\n            cursor.execute(f\"SELECT id, name FROM items WHERE id IN ({qmarks})\", tuple(item_ids))\n            res = {row[0]: row[1] for row in cursor.fetchall()}\n            conn.close()\n            return res\n        except Exception:\n            return {}\n    # Helper: Get shop availability for item_ids\n    def get_is_in_shop(db_path, item_ids, current_time):\n        # current_time: str 'YYYY-MM-DD HH:MM:SS'\n        result = {}\n        if not item_ids:\n            return result\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            # Only for region_id = 1\n            for item_id in item_ids:\n                cursor.execute(\"\"\"\n                    SELECT COUNT(*) FROM shop_offers \n                    WHERE offered_item_id = ? AND region_id = 1 AND ? >= starts_at AND ? < ends_at\n                \"\"\", (item_id, current_time, current_time))\n                in_shop = cursor.fetchone()[0] > 0\n                result[item_id] = in_shop\n            conn.close()\n            return result\n        except Exception:\n            # Defensive: mark as not in shop\n            for item_id in item_ids:\n                result[item_id] = False\n            return result\n    # Helper: Parse boolean from string\n    def str_to_bool(val):\n        if val is None:\n            return None\n        val = val.strip().lower()\n        if val in {'true','yes','1'}:\n            return True\n        if val in {'false','no','0'}:\n            return False\n        return None\n    # Get initial and final wishlist ids\n    initial_wishlist_id = get_wishlist_id(initial_db_path)\n    final_wishlist_id = get_wishlist_id(final_db_path)\n    # If user lost their wishlist or gained a new one, fail\n    if not final_wishlist_id or not initial_wishlist_id or final_wishlist_id != initial_wishlist_id:\n        return {\"result\": \"others\"}\n    # Get wishlist items before and after\n    initial_items = get_wishlist_items(initial_db_path, initial_wishlist_id)\n    final_items = get_wishlist_items(final_db_path, final_wishlist_id)\n    # Map names to IDs for 'Galaxy Scout' and 'Star Wand'\n    try:\n        conn = sqlite3.connect(f\"file:{final_db_path}?mode=ro\", uri=True)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT id FROM items WHERE name = 'Galaxy Scout'\")\n        row1 = cursor.fetchone()\n        cursor.execute(\"SELECT id FROM items WHERE name = 'Star Wand'\")\n        row2 = cursor.fetchone()\n        conn.close()\n        galaxy_id = row1[0] if row1 else None\n        star_wand_id = row2[0] if row2 else None\n    except Exception:\n        return {\"result\": \"others\"}\n    if not galaxy_id or not star_wand_id:\n        return {\"result\": \"others\"}\n    target_item_ids = {galaxy_id, star_wand_id}\n    # Check item 104 was already in wishlist, 105 must be newly added, and no other changes except this\n    expected_final_items = initial_items | {star_wand_id}\n    if final_items != expected_final_items:\n        # Allow: if galaxy_id already present, and only star_wand added, OK. Any extra additions/deletions is fail.\n        return {\"result\": \"others\"}\n    # Must have both items after\n    if not target_item_ids.issubset(final_items):\n        return {\"result\": \"others\"}\n    # Now collect details for all wishlist items in final state\n    wishlist_details = []\n    item_names = get_item_names(final_db_path, final_items)\n    in_shop_map = get_is_in_shop(final_db_path, final_items, NOW)\n    # Build expected list: [{id, name, is_in_shop}, ...]\n    for iid in sorted(final_items):  # sort for deterministic order\n        wishlist_details.append({\n            \"id\": iid,\n            \"name\": item_names.get(iid, \"\"),\n            \"is_in_shop\": in_shop_map.get(iid, False)\n        })\n    # Parse final_answer, look for a list/dict or table that includes id, name, is_in_shop for each item in final wishlist\n    # Try to extract tuples (id, name, is_in_shop) from final_answer\n    if not final_answer:\n        return {\"result\": \"others\"}\n    # Regex to find groupings of id+name+is_in_shop per item. Allow for tabular or bullet/JSON style.\n    # We look for id (number), name (exact string match ignoring case/space), is_in_shop (bool/yes/no/true/false/1/0)\n    # Build mapping for validation\n    answer_items = []\n    # Try simple JSONish pattern first\n    pattern = r\"id\\D*(\\d+)\\D*name\\D*([A-Za-z0-9 \\-']+)\\D*is[_ ]?in[_ ]?shop\\D*(true|false|yes|no|1|0)\"\n    for m in re.finditer(pattern, final_answer, re.IGNORECASE):\n        iid = None\n        try:\n            iid = int(m.group(1))\n        except:\n            continue\n        iname = m.group(2).strip()\n        ishop = m.group(3)\n        answer_items.append({\n            \"id\": iid,\n            \"name\": iname,\n            \"is_in_shop\": str_to_bool(ishop)\n        })\n    # If pattern did not work, try linewise parsing looking for rows with three columns: id, name, shop\n    if not answer_items:\n        # Accept pipes, commas, tabs\n        lines = final_answer.splitlines()\n        for line in lines:\n            line = line.strip()\n            # Accept: (id) (name) (is_in_shop); id,name,is_in_shop; etc\n            col_pat = r\"^(\\d+)\\s*[,|\\t]\\s*([A-Za-z0-9 \\-']+)\\s*[,|\\t]\\s*(true|false|yes|no|1|0)\"\n            m = re.match(col_pat, line, re.IGNORECASE)\n            if m:\n                try:\n                    iid = int(m.group(1))\n                    iname = m.group(2).strip()\n                    ishop = m.group(3)\n                    answer_items.append({\n                        \"id\": iid,\n                        \"name\": iname,\n                        \"is_in_shop\": str_to_bool(ishop)\n                    })\n                except:\n                    continue\n    # If still nothing found, fail\n    if not answer_items:\n        return {\"result\": \"others\"}\n    # Now validate that answer_items matches exactly all items in wishlist_details (by id, name, is_in_shop), and no extras\n    # Build mapping by id for both\n    expected_map = {d['id']:(d['name'].lower().strip(), d['is_in_shop']) for d in wishlist_details}\n    answer_map = {d['id']:(d['name'].lower().strip(), d['is_in_shop']) for d in answer_items}\n    # Must have same ids\n    if set(expected_map.keys()) != set(answer_map.keys()):\n        return {\"result\": \"others\"}\n    for iid in expected_map:\n        ename, eshop = expected_map[iid]\n        aname, ashop = answer_map[iid]\n        # Allow for whitespace/case insensitivity in name, but must match\n        if ename != aname:\n            return {\"result\": \"others\"}\n        if eshop != ashop:\n            return {\"result\": \"others\"}\n    # All checks succeeded\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task is a combined action and query: (1) Add the items 'Galaxy Scout' and 'Star Wand' to the wishlist, (2) Return the updated wishlist with item IDs, names, and a boolean flag indicating whether each is currently in the shop. To be 100% certain the task was completed successfully, the function must: a) detect that exactly these two items were newly added to the wishlist for the user, without undesired additions/removals/duplicates, and b) verify that the final_answer exactly and correctly reflects the resulting wishlist, including for all wishlist items: their id, name, and the accurate current-in-shop boolean, with no discrepancies. All checks must be robust to malformed or missing data.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Extract wishlist_id for user_id=1 in both initial and final DB\",\n        \"Determine item_ids for 'Galaxy Scout' and 'Star Wand' ('Galaxy Scout': 104, 'Star Wand': 105)\",\n        \"Ensure in final DB that wishlist_items for user's wishlist includes both item_id 104 and 105\",\n        \"Ensure neither item 104 nor 105 was present (for this wishlist) in the initial DB except for item 104 (which already was, so only 105 must be newly added)\",\n        \"Ensure no other wishlist items were added or removed for that wishlist (except 105 as newly added, 104 as already present)\",\n        \"Extract all current wishlist items for user_id=1 in the final DB (expecting 104, 105)\",\n        \"For each item in the wishlist, look up 'is_in_shop' status: does shop_offers exist for offered_item_id = item_id with region_id=1 and current time within [starts_at, ends_at)\",\n        \"Parse final_answer to extract a list or table showing id, name, is_in_shop for all wishlist items\",\n        \"For each wishlist item, verify that its id, name, and is_in_shop match DB state (case-insensitive, allow for boolean representations yes/no/true/false/1/0)\",\n        \"Return {'result': 'complete'} exclusively if and only if all the above are met; otherwise, return {'result': 'others'}\"\n    ],\n    \"python_code\":\n\"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime\\n    \\n    # Use a fixed timestamp for 'now' matching when agent would be acting (based on shop_offers/parental_controls/wallets update times),\\n    # since we do not have wallclock and must be deterministic. We choose 2026-02-18 07:18:36 (from 'parental_controls', 'wallets').\\n    NOW = '2026-02-18 07:18:36'\\n    # Helper: get wishlist_id for user 1\\n    def get_wishlist_id(db_path):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(\\\"SELECT id FROM wishlists WHERE user_id = 1\\\")\\n            row = cursor.fetchone()\\n            conn.close()\\n            return row[0] if row else None\\n        except Exception:\\n            return None\\n    # Helper: get wishlist items for a wishlist\\n    def get_wishlist_items(db_path, wishlist_id):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(\\\"SELECT item_id FROM wishlist_items WHERE wishlist_id = ?\\\", (wishlist_id,))\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return set(r[0] for r in rows)\\n        except Exception:\\n            return set()\\n    # Helper: get item details for supplied ids\\n    def get_item_names(db_path, item_ids):\\n        if not item_ids:\\n            return {}\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            qmarks = ','.join(['?']*len(item_ids))\\n            cursor.execute(f\\\"SELECT id, name FROM items WHERE id IN ({qmarks})\\\", tuple(item_ids))\\n            res = {row[0]: row[1] for row in cursor.fetchall()}\\n            conn.close()\\n            return res\\n        except Exception:\\n            return {}\\n    # Helper: Get shop availability for item_ids\\n    def get_is_in_shop(db_path, item_ids, current_time):\\n        # current_time: str 'YYYY-MM-DD HH:MM:SS'\\n        result = {}\\n        if not item_ids:\\n            return result\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            # Only for region_id = 1\\n            for item_id in item_ids:\\n                cursor.execute(\\\"\\\"\\\"\\n                    SELECT COUNT(*) FROM shop_offers \\n                    WHERE offered_item_id = ? AND region_id = 1 AND ? >= starts_at AND ? < ends_at\\n                \\\"\\\"\\\", (item_id, current_time, current_time))\\n                in_shop = cursor.fetchone()[0] > 0\\n                result[item_id] = in_shop\\n            conn.close()\\n            return result\\n        except Exception:\\n            # Defensive: mark as not in shop\\n            for item_id in item_ids:\\n                result[item_id] = False\\n            return result\\n    # Helper: Parse boolean from string\\n    def str_to_bool(val):\\n        if val is None:\\n            return None\\n        val = val.strip().lower()\\n        if val in {'true','yes','1'}:\\n            return True\\n        if val in {'false','no','0'}:\\n            return False\\n        return None\\n    # Get initial and final wishlist ids\\n    initial_wishlist_id = get_wishlist_id(initial_db_path)\\n    final_wishlist_id = get_wishlist_id(final_db_path)\\n    # If user lost their wishlist or gained a new one, fail\\n    if not final_wishlist_id or not initial_wishlist_id or final_wishlist_id != initial_wishlist_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Get wishlist items before and after\\n    initial_items = get_wishlist_items(initial_db_path, initial_wishlist_id)\\n    final_items = get_wishlist_items(final_db_path, final_wishlist_id)\\n    # Map names to IDs for 'Galaxy Scout' and 'Star Wand'\\n    try:\\n        conn = sqlite3.connect(f\\\"file:{final_db_path}?mode=ro\\\", uri=True)\\n        cursor = conn.cursor()\\n        cursor.execute(\\\"SELECT id FROM items WHERE name = 'Galaxy Scout'\\\")\\n        row1 = cursor.fetchone()\\n        cursor.execute(\\\"SELECT id FROM items WHERE name = 'Star Wand'\\\")\\n        row2 = cursor.fetchone()\\n        conn.close()\\n        galaxy_id = row1[0] if row1 else None\\n        star_wand_id = row2[0] if row2 else None\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not galaxy_id or not star_wand_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    target_item_ids = {galaxy_id, star_wand_id}\\n    # Check item 104 was already in wishlist, 105 must be newly added, and no other changes except this\\n    expected_final_items = initial_items | {star_wand_id}\\n    if final_items != expected_final_items:\\n        # Allow: if galaxy_id already present, and only star_wand added, OK. Any extra additions/deletions is fail.\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Must have both items after\\n    if not target_item_ids.issubset(final_items):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Now collect details for all wishlist items in final state\\n    wishlist_details = []\\n    item_names = get_item_names(final_db_path, final_items)\\n    in_shop_map = get_is_in_shop(final_db_path, final_items, NOW)\\n    # Build expected list: [{id, name, is_in_shop}, ...]\\n    for iid in sorted(final_items):  # sort for deterministic order\\n        wishlist_details.append({\\n            \\\"id\\\": iid,\\n            \\\"name\\\": item_names.get(iid, \\\"\\\"),\\n            \\\"is_in_shop\\\": in_shop_map.get(iid, False)\\n        })\\n    # Parse final_answer, look for a list/dict or table that includes id, name, is_in_shop for each item in final wishlist\\n    # Try to extract tuples (id, name, is_in_shop) from final_answer\\n    if not final_answer:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Regex to find groupings of id+name+is_in_shop per item. Allow for tabular or bullet/JSON style.\\n    # We look for id (number), name (exact string match ignoring case/space), is_in_shop (bool/yes/no/true/false/1/0)\\n    # Build mapping for validation\\n    answer_items = []\\n    # Try simple JSONish pattern first\\n    pattern = r\\\"id\\\\D*(\\\\d+)\\\\D*name\\\\D*([A-Za-z0-9 \\\\-']+)\\\\D*is[_ ]?in[_ ]?shop\\\\D*(true|false|yes|no|1|0)\\\"\\n    for m in re.finditer(pattern, final_answer, re.IGNORECASE):\\n        iid = None\\n        try:\\n            iid = int(m.group(1))\\n        except:\\n            continue\\n        iname = m.group(2).strip()\\n        ishop = m.group(3)\\n        answer_items.append({\\n            \\\"id\\\": iid,\\n            \\\"name\\\": iname,\\n            \\\"is_in_shop\\\": str_to_bool(ishop)\\n        })\\n    # If pattern did not work, try linewise parsing looking for rows with three columns: id, name, shop\\n    if not answer_items:\\n        # Accept pipes, commas, tabs\\n        lines = final_answer.splitlines()\\n        for line in lines:\\n            line = line.strip()\\n            # Accept: (id) (name) (is_in_shop); id,name,is_in_shop; etc\\n            col_pat = r\\\"^(\\\\d+)\\\\s*[,|\\\\t]\\\\s*([A-Za-z0-9 \\\\-']+)\\\\s*[,|\\\\t]\\\\s*(true|false|yes|no|1|0)\\\"\\n            m = re.match(col_pat, line, re.IGNORECASE)\\n            if m:\\n                try:\\n                    iid = int(m.group(1))\\n                    iname = m.group(2).strip()\\n                    ishop = m.group(3)\\n                    answer_items.append({\\n                        \\\"id\\\": iid,\\n                        \\\"name\\\": iname,\\n                        \\\"is_in_shop\\\": str_to_bool(ishop)\\n                    })\\n                except:\\n                    continue\\n    # If still nothing found, fail\\n    if not answer_items:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Now validate that answer_items matches exactly all items in wishlist_details (by id, name, is_in_shop), and no extras\\n    # Build mapping by id for both\\n    expected_map = {d['id']:(d['name'].lower().strip(), d['is_in_shop']) for d in wishlist_details}\\n    answer_map = {d['id']:(d['name'].lower().strip(), d['is_in_shop']) for d in answer_items}\\n    # Must have same ids\\n    if set(expected_map.keys()) != set(answer_map.keys()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    for iid in expected_map:\\n        ename, eshop = expected_map[iid]\\n        aname, ashop = answer_map[iid]\\n        # Allow for whitespace/case insensitivity in name, but must match\\n        if ename != aname:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if eshop != ashop:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # All checks succeeded\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 6, "task": "Attempt to buy the bundle 'Starter Pack Alpha' when my parental control spending limit is 500 V-Bucks remaining and the bundle costs 600 V-Bucks, and return the compliance error details including which rule blocked the purchase.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Queries for relevant compliance error\n    ERROR_RULE_CODE = 'PARENTAL_SPEND_LIMIT_EXCEEDED'\n    OFFER_ITEM_ID = 106  # Starter Pack Alpha\n    OFFER_ID = 1011      # From shop_offers, for Starter Pack Alpha\n    USER_ID = 1\n    ATTEMPTED_TOTAL_VBUCKS = 600\n    SPEND_REMAINING_VBUCKS = 500\n    ACTION_TYPE = 'purchase'\n\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Check for compliance error in final DB\n    error_rows = safe_query(final_db_path,\n        \"\"\"\n        SELECT id, user_id, action_type, offer_id, attempted_total_vbucks, rule_code, rule_description, context_json\n        FROM compliance_errors\n        WHERE user_id=? AND action_type=? AND offer_id=? AND attempted_total_vbucks=? AND rule_code=?\n        \"\"\",\n        (USER_ID, ACTION_TYPE, OFFER_ID, ATTEMPTED_TOTAL_VBUCKS, ERROR_RULE_CODE)\n    )\n\n    if not error_rows or len(error_rows) == 0:\n        return {\"result\": \"others\"}\n\n    # There may be multiple errors; require new error entry compared to initial DB\n    initial_error_rows = safe_query(initial_db_path,\n        \"\"\"\n        SELECT id\n        FROM compliance_errors\n        WHERE user_id=? AND action_type=? AND offer_id=? AND attempted_total_vbucks=? AND rule_code=?\n        \"\"\",\n        (USER_ID, ACTION_TYPE, OFFER_ID, ATTEMPTED_TOTAL_VBUCKS, ERROR_RULE_CODE)\n    )\n    if len(error_rows) <= len(initial_error_rows):\n        return {\"result\": \"others\"}\n\n    # Confirm error details\n    found_correct_error = False\n    for row in error_rows:\n        _, user_id, action_type, offer_id, attempted_total_vbucks, rule_code, rule_description, context_json = row\n        if (user_id != USER_ID or action_type != ACTION_TYPE or offer_id != OFFER_ID or \n            attempted_total_vbucks != ATTEMPTED_TOTAL_VBUCKS or rule_code != ERROR_RULE_CODE):\n            continue\n        if not rule_description or 'parental control' not in rule_description.lower():\n            continue\n        if not context_json:\n            continue\n        # Defensive check for spend values in context_json\n        spend_val_match = re.search(r'\"spend_remaining_vbucks\"\\s*:\\s*(\\d+)', context_json)\n        attempted_val_match = re.search(r'\"attempted_total_vbucks\"\\s*:\\s*(\\d+)', context_json)\n        if not spend_val_match or not attempted_val_match:\n            continue\n        if int(spend_val_match.group(1)) != SPEND_REMAINING_VBUCKS:\n            continue\n        if int(attempted_val_match.group(1)) != ATTEMPTED_TOTAL_VBUCKS:\n            continue\n        found_correct_error = True\n        break\n    if not found_correct_error:\n        return {\"result\": \"others\"}\n\n    # Confirm NO completed purchase for the bundle\n    purchase_rows = safe_query(final_db_path,\n        \"\"\"\n        SELECT id FROM purchase_receipts WHERE user_id=? AND offer_id=? AND status='completed'\n        \"\"\",\n        (USER_ID, OFFER_ID)\n    )\n    if purchase_rows:\n        return {\"result\": \"others\"}\n\n    # Check final_answer for compliance error details\n    if not final_answer or not isinstance(final_answer, str):\n        return {\"result\": \"others\"}\n\n    # Must mention rule code and describe which rule blocked the purchase\n    error_rule_pattern = re.compile(r\"parental[^.]*spend[^.]*limit[^.]*exceeded\", re.IGNORECASE)\n    desc_pattern = re.compile(r\"insufficient.*spend limit|blocked.*spend limit\", re.IGNORECASE)\n    code_pattern = re.compile(r\"PARENTAL_SPEND_LIMIT_EXCEEDED\", re.IGNORECASE)\n    vbucks_pattern = re.compile(r\"(?:remaining|spend(ing)? limit).*?(500)\", re.IGNORECASE)\n    attempted_pattern = re.compile(r\"(?:attempt(ed)?|purchase).*?(600).*?V[-]?Bucks\", re.IGNORECASE)\n\n    has_code = bool(code_pattern.search(final_answer))\n    has_desc = bool(error_rule_pattern.search(final_answer)) or bool(desc_pattern.search(final_answer))\n    has_remaining = bool(vbucks_pattern.search(final_answer))\n    has_attempted = bool(attempted_pattern.search(final_answer))\n    # Must mention which rule blocked purchase\n    blocked_pattern = re.compile(r\"block(ed)?|prevent(ed)?|failed|not permitted\", re.IGNORECASE)\n    has_blocked = bool(blocked_pattern.search(final_answer))\n    \n    if not (has_code and has_desc and has_remaining and has_attempted and has_blocked):\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The user attempted to buy the bundle 'Starter Pack Alpha' (item_id=106) when their parental control spending limit was 500 V-Bucks remaining and the bundle costs 600 V-Bucks. The task is to return compliance error details including which rule blocked the purchase. The verification requires checking that the database state after agent execution shows evidence that (1) a purchase was attempted, (2) it failed due to the parental spend limit, (3) the compliance error contains the correct rule and data, and (4) the agent's final answer returns these compliance error details including the rule code (PARENTAL_SPEND_LIMIT_EXCEEDED) and description. This is a combined query and modification task: both the compliance_errors table and the agent's final answer must be checked.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Check that the compliance_errors table in the final database contains a new entry for user_id=1, action_type='purchase', offer_id for 'Starter Pack Alpha' (item_id=106), attempted_total_vbucks=600, rule_code='PARENTAL_SPEND_LIMIT_EXCEEDED', rule_description indicating parental spend limit was insufficient, and a context with spend_remaining_vbucks=500 and attempted_total_vbucks=600.\",\n        \"Check that the compliance_errors entry did not exist in the initial database (new error entry).\",\n        \"Verify that no purchase_receipts entry for offer_id=1011 (Starter Pack Alpha) and user_id=1 was created in the final database (no completed purchase).\",\n        \"Validate that the agent's final_answer returns or mentions the compliance error details (rule code, rule description, which rule blocked the purchase).\",\n        \"Ensure all details (rule code, spend values, and block reason) are accurate and match database values.\",\n        \"Return 'complete' if and only if ALL above checks pass deterministically.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Queries for relevant compliance error\\n    ERROR_RULE_CODE = 'PARENTAL_SPEND_LIMIT_EXCEEDED'\\n    OFFER_ITEM_ID = 106  # Starter Pack Alpha\\n    OFFER_ID = 1011      # From shop_offers, for Starter Pack Alpha\\n    USER_ID = 1\\n    ATTEMPTED_TOTAL_VBUCKS = 600\\n    SPEND_REMAINING_VBUCKS = 500\\n    ACTION_TYPE = 'purchase'\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Check for compliance error in final DB\\n    error_rows = safe_query(final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id, user_id, action_type, offer_id, attempted_total_vbucks, rule_code, rule_description, context_json\\n        FROM compliance_errors\\n        WHERE user_id=? AND action_type=? AND offer_id=? AND attempted_total_vbucks=? AND rule_code=?\\n        \\\"\\\"\\\",\\n        (USER_ID, ACTION_TYPE, OFFER_ID, ATTEMPTED_TOTAL_VBUCKS, ERROR_RULE_CODE)\\n    )\\n\\n    if not error_rows or len(error_rows) == 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # There may be multiple errors; require new error entry compared to initial DB\\n    initial_error_rows = safe_query(initial_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id\\n        FROM compliance_errors\\n        WHERE user_id=? AND action_type=? AND offer_id=? AND attempted_total_vbucks=? AND rule_code=?\\n        \\\"\\\"\\\",\\n        (USER_ID, ACTION_TYPE, OFFER_ID, ATTEMPTED_TOTAL_VBUCKS, ERROR_RULE_CODE)\\n    )\\n    if len(error_rows) <= len(initial_error_rows):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Confirm error details\\n    found_correct_error = False\\n    for row in error_rows:\\n        _, user_id, action_type, offer_id, attempted_total_vbucks, rule_code, rule_description, context_json = row\\n        if (user_id != USER_ID or action_type != ACTION_TYPE or offer_id != OFFER_ID or \\n            attempted_total_vbucks != ATTEMPTED_TOTAL_VBUCKS or rule_code != ERROR_RULE_CODE):\\n            continue\\n        if not rule_description or 'parental control' not in rule_description.lower():\\n            continue\\n        if not context_json:\\n            continue\\n        # Defensive check for spend values in context_json\\n        spend_val_match = re.search(r'\\\"spend_remaining_vbucks\\\"\\\\s*:\\\\s*(\\\\d+)', context_json)\\n        attempted_val_match = re.search(r'\\\"attempted_total_vbucks\\\"\\\\s*:\\\\s*(\\\\d+)', context_json)\\n        if not spend_val_match or not attempted_val_match:\\n            continue\\n        if int(spend_val_match.group(1)) != SPEND_REMAINING_VBUCKS:\\n            continue\\n        if int(attempted_val_match.group(1)) != ATTEMPTED_TOTAL_VBUCKS:\\n            continue\\n        found_correct_error = True\\n        break\\n    if not found_correct_error:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Confirm NO completed purchase for the bundle\\n    purchase_rows = safe_query(final_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id FROM purchase_receipts WHERE user_id=? AND offer_id=? AND status='completed'\\n        \\\"\\\"\\\",\\n        (USER_ID, OFFER_ID)\\n    )\\n    if purchase_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check final_answer for compliance error details\\n    if not final_answer or not isinstance(final_answer, str):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Must mention rule code and describe which rule blocked the purchase\\n    error_rule_pattern = re.compile(r\\\"parental[^.]*spend[^.]*limit[^.]*exceeded\\\", re.IGNORECASE)\\n    desc_pattern = re.compile(r\\\"insufficient.*spend limit|blocked.*spend limit\\\", re.IGNORECASE)\\n    code_pattern = re.compile(r\\\"PARENTAL_SPEND_LIMIT_EXCEEDED\\\", re.IGNORECASE)\\n    vbucks_pattern = re.compile(r\\\"(?:remaining|spend(ing)? limit).*?(500)\\\", re.IGNORECASE)\\n    attempted_pattern = re.compile(r\\\"(?:attempt(ed)?|purchase).*?(600).*?V[-]?Bucks\\\", re.IGNORECASE)\\n\\n    has_code = bool(code_pattern.search(final_answer))\\n    has_desc = bool(error_rule_pattern.search(final_answer)) or bool(desc_pattern.search(final_answer))\\n    has_remaining = bool(vbucks_pattern.search(final_answer))\\n    has_attempted = bool(attempted_pattern.search(final_answer))\\n    # Must mention which rule blocked purchase\\n    blocked_pattern = re.compile(r\\\"block(ed)?|prevent(ed)?|failed|not permitted\\\", re.IGNORECASE)\\n    has_blocked = bool(blocked_pattern.search(final_answer))\\n    \\n    if not (has_code and has_desc and has_remaining and has_attempted and has_blocked):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 7, "task": "Request a refund for my most recent eligible purchase using one refund token, reversing entitlements and restoring V-Bucks, and return the refund transaction ID, tokens remaining, and updated wallet balance.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    USER_ID = 1\n    # 1. Find initial tokens, most recent completed purchase, and its items\n    refund_tokens_init = safe_query(initial_db_path, \"SELECT tokens_remaining FROM refund_tokens WHERE user_id=?\", (USER_ID,))\n    if not refund_tokens_init or len(refund_tokens_init[0]) != 1:\n        return {\"result\": \"others\"}\n    tokens_initial = refund_tokens_init[0][0]\n\n    init_receipts = safe_query(initial_db_path, \"SELECT id, purchased_at, status FROM purchase_receipts WHERE user_id=? ORDER BY purchased_at DESC, id DESC\", (USER_ID,))\n    eligible_receipts = [r for r in init_receipts if r[2]==\"completed\"]\n    if not eligible_receipts:\n        return {\"result\": \"others\"}\n    most_recent_receipt_id = eligible_receipts[0][0]\n    most_recent_purchased_at = eligible_receipts[0][1]\n\n    # 2. Check for new refund_transaction\n    final_refunds = safe_query(final_db_path, \"SELECT id, user_id, purchase_receipt_id, token_used, vbucks_restored, status FROM refund_transactions WHERE user_id=? ORDER BY created_at DESC, id DESC\", (USER_ID,))\n    if not final_refunds:\n        return {\"result\": \"others\"}\n    # Must be a refund on the most recent completed purchase not previously present\n    initial_refunds = safe_query(initial_db_path, \"SELECT id, purchase_receipt_id FROM refund_transactions WHERE user_id=?\", (USER_ID,))\n    initial_refunded_receipt_ids = set(r[1] for r in initial_refunds)\n    target = None\n    for row in final_refunds:\n        fid, u, receipt_id, token_used, vbucks_restored, status = row\n        if receipt_id == most_recent_receipt_id and status == 'completed' and token_used == 1 and receipt_id not in initial_refunded_receipt_ids:\n            target = row\n            break\n    if target is None:\n        return {\"result\": \"others\"}\n    refund_tx_id = target[0]\n    refund_vbucks = target[4]\n\n    # 3. Check purchase_receipt status now 'refunded'\n    final_receipt = safe_query(final_db_path, \"SELECT status FROM purchase_receipts WHERE id=?\", (most_recent_receipt_id,))\n    if not final_receipt or final_receipt[0][0] != 'refunded':\n        return {\"result\": \"others\"}\n\n    # 4. Check all entitlements for user and this purchase are revoked\n    pr_items = safe_query(initial_db_path, \"SELECT item_id FROM purchase_receipt_items WHERE receipt_id=?\", (most_recent_receipt_id,))\n    pr_item_ids = [r[0] for r in pr_items]\n    entitlements = safe_query(initial_db_path, \"SELECT id, item_id FROM entitlements WHERE user_id=? AND source_type='purchase' AND source_id=? AND revoked_at IS NULL\", (USER_ID, most_recent_receipt_id))\n    entitlement_ids = [e[0] for e in entitlements]\n    for eid in entitlement_ids:\n        # Check in final DB it's revoked\n        revoked = safe_query(final_db_path, \"SELECT revoked_at FROM entitlements WHERE id=?\", (eid,))\n        if not revoked or revoked[0][0] is None:\n            return {\"result\": \"others\"}\n\n    # 5. Refund token count - decreased by one\n    refund_tokens_final = safe_query(final_db_path, \"SELECT tokens_remaining FROM refund_tokens WHERE user_id=?\", (USER_ID,))\n    if not refund_tokens_final or len(refund_tokens_final[0]) != 1:\n        return {\"result\": \"others\"}\n    tokens_final = refund_tokens_final[0][0]\n    if tokens_final != tokens_initial - 1:\n        return {\"result\": \"others\"}\n\n    # 6. V-Bucks restored to wallet and ledger shows correct addition\n    wallet_final = safe_query(final_db_path, \"SELECT balance_vbucks FROM wallets WHERE user_id=?\", (USER_ID,))\n    if not wallet_final or len(wallet_final[0]) != 1:\n        return {\"result\": \"others\"}\n    balance_final = wallet_final[0][0]\n    wallet_init = safe_query(initial_db_path, \"SELECT balance_vbucks FROM wallets WHERE user_id=?\", (USER_ID,))\n    if not wallet_init or len(wallet_init[0]) != 1:\n        return {\"result\": \"others\"}\n    balance_initial = wallet_init[0][0]\n    expected_balance = balance_initial + refund_vbucks\n    # Accept only if final balance matches\n    if balance_final != expected_balance:\n        return {\"result\": \"others\"}\n    # There should be a 'refund' wallet_ledger entry for this refund_transaction\n    ledger = safe_query(final_db_path, \"SELECT amount_vbucks, balance_after_vbucks FROM wallet_ledger WHERE user_id=? AND reference_type='refund_transaction' AND reference_id=? AND entry_type='refund' ORDER BY created_at DESC\", (USER_ID, refund_tx_id))\n    if not ledger or ledger[0][0] != refund_vbucks or ledger[0][1] != balance_final:\n        return {\"result\": \"others\"}\n\n    # 7. Final answer: parse refund tx id, tokens remaining, balance, and validate\n    if not final_answer or not isinstance(final_answer, str):\n        return {\"result\": \"others\"}\n    # Search for refund transaction id, tokens remaining, and balance (robust, support nonstandard ordering)\n    id_matches = re.findall(r\"refund transaction id\\D*(\\d+)\", final_answer, re.IGNORECASE)\n    tokens_matches = re.findall(r\"tokens? remaining\\D*(\\d+)\", final_answer, re.IGNORECASE)\n    balance_matches = re.findall(r\"wallet balance|v-?bucks? balance|balance.*?([\\d]+)\", final_answer, re.IGNORECASE)\n    # Accept also if in JSON block\n    if not id_matches:\n        id_matches = re.findall(r'\"id\"\\s*:\\s*(\\d+)', final_answer)\n    if not tokens_matches:\n        tokens_matches = re.findall(r'\"tokens?_?remaining\"\\s*:\\s*(\\d+)', final_answer)\n    if not balance_matches:\n        # match \"balance\":1234 or \"balance_vbucks\":1234\n        balance_matches = re.findall(r'\"balance(_vbucks)?\"\\s*:\\s*(\\d+)', final_answer)\n        if balance_matches:\n            balance_matches = [bm[1] for bm in balance_matches]\n    # All must be present and correct\n    if not id_matches or not tokens_matches or not balance_matches:\n        return {\"result\": \"others\"}\n    try:\n        id_match = int(id_matches[0])\n        tokens_match = int(tokens_matches[0])\n        balance_match = int(balance_matches[0])\n    except Exception:\n        return {\"result\": \"others\"}\n    if id_match != refund_tx_id or tokens_match != tokens_final or balance_match != balance_final:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we need to confirm: (1) the user's most recent eligible purchase was refunded using a refund token, (2) entitlements from that purchase were revoked, (3) the correct amount of V-Bucks was restored to the user's wallet, (4) the refund token count decreased by one, and (5) the agent's final answer includes the refund transaction ID, refund tokens remaining, and updated wallet balance, all consistent with the post-action database state. These checks require examining both the database changes and the final answer content.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Identify the most recent eligible purchase for user_id=1 prior to agent action\",\n        \"Check a new refund_transactions entry for user_id=1 referencing the correct purchase_receipt_id with status 'completed' and token_used=1\",\n        \"Ensure the corresponding purchase_receipt is now marked as 'refunded'\",\n        \"Confirm all entitlements from that receipt are revoked (entitlements.revoked_at is not NULL in final_db for those items)\",\n        \"Verify wallet_ledger has a correct 'refund' entry tying the refund_transaction to a positive vbucks_restored and the new wallet balance matches final wallets\",\n        \"Check refund_tokens.tokens_remaining for user_id=1 decreased by exactly 1\",\n        \"Parse the final_answer and ensure it reports the correct refund_transaction id, tokens remaining, and updated V-Bucks balance, matching the DB\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    USER_ID = 1\\n    # 1. Find initial tokens, most recent completed purchase, and its items\\n    refund_tokens_init = safe_query(initial_db_path, \\\"SELECT tokens_remaining FROM refund_tokens WHERE user_id=?\\\", (USER_ID,))\\n    if not refund_tokens_init or len(refund_tokens_init[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    tokens_initial = refund_tokens_init[0][0]\\n\\n    init_receipts = safe_query(initial_db_path, \\\"SELECT id, purchased_at, status FROM purchase_receipts WHERE user_id=? ORDER BY purchased_at DESC, id DESC\\\", (USER_ID,))\\n    eligible_receipts = [r for r in init_receipts if r[2]==\\\"completed\\\"]\\n    if not eligible_receipts:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    most_recent_receipt_id = eligible_receipts[0][0]\\n    most_recent_purchased_at = eligible_receipts[0][1]\\n\\n    # 2. Check for new refund_transaction\\n    final_refunds = safe_query(final_db_path, \\\"SELECT id, user_id, purchase_receipt_id, token_used, vbucks_restored, status FROM refund_transactions WHERE user_id=? ORDER BY created_at DESC, id DESC\\\", (USER_ID,))\\n    if not final_refunds:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Must be a refund on the most recent completed purchase not previously present\\n    initial_refunds = safe_query(initial_db_path, \\\"SELECT id, purchase_receipt_id FROM refund_transactions WHERE user_id=?\\\", (USER_ID,))\\n    initial_refunded_receipt_ids = set(r[1] for r in initial_refunds)\\n    target = None\\n    for row in final_refunds:\\n        fid, u, receipt_id, token_used, vbucks_restored, status = row\\n        if receipt_id == most_recent_receipt_id and status == 'completed' and token_used == 1 and receipt_id not in initial_refunded_receipt_ids:\\n            target = row\\n            break\\n    if target is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    refund_tx_id = target[0]\\n    refund_vbucks = target[4]\\n\\n    # 3. Check purchase_receipt status now 'refunded'\\n    final_receipt = safe_query(final_db_path, \\\"SELECT status FROM purchase_receipts WHERE id=?\\\", (most_recent_receipt_id,))\\n    if not final_receipt or final_receipt[0][0] != 'refunded':\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check all entitlements for user and this purchase are revoked\\n    pr_items = safe_query(initial_db_path, \\\"SELECT item_id FROM purchase_receipt_items WHERE receipt_id=?\\\", (most_recent_receipt_id,))\\n    pr_item_ids = [r[0] for r in pr_items]\\n    entitlements = safe_query(initial_db_path, \\\"SELECT id, item_id FROM entitlements WHERE user_id=? AND source_type='purchase' AND source_id=? AND revoked_at IS NULL\\\", (USER_ID, most_recent_receipt_id))\\n    entitlement_ids = [e[0] for e in entitlements]\\n    for eid in entitlement_ids:\\n        # Check in final DB it's revoked\\n        revoked = safe_query(final_db_path, \\\"SELECT revoked_at FROM entitlements WHERE id=?\\\", (eid,))\\n        if not revoked or revoked[0][0] is None:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Refund token count - decreased by one\\n    refund_tokens_final = safe_query(final_db_path, \\\"SELECT tokens_remaining FROM refund_tokens WHERE user_id=?\\\", (USER_ID,))\\n    if not refund_tokens_final or len(refund_tokens_final[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    tokens_final = refund_tokens_final[0][0]\\n    if tokens_final != tokens_initial - 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. V-Bucks restored to wallet and ledger shows correct addition\\n    wallet_final = safe_query(final_db_path, \\\"SELECT balance_vbucks FROM wallets WHERE user_id=?\\\", (USER_ID,))\\n    if not wallet_final or len(wallet_final[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    balance_final = wallet_final[0][0]\\n    wallet_init = safe_query(initial_db_path, \\\"SELECT balance_vbucks FROM wallets WHERE user_id=?\\\", (USER_ID,))\\n    if not wallet_init or len(wallet_init[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    balance_initial = wallet_init[0][0]\\n    expected_balance = balance_initial + refund_vbucks\\n    # Accept only if final balance matches\\n    if balance_final != expected_balance:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # There should be a 'refund' wallet_ledger entry for this refund_transaction\\n    ledger = safe_query(final_db_path, \\\"SELECT amount_vbucks, balance_after_vbucks FROM wallet_ledger WHERE user_id=? AND reference_type='refund_transaction' AND reference_id=? AND entry_type='refund' ORDER BY created_at DESC\\\", (USER_ID, refund_tx_id))\\n    if not ledger or ledger[0][0] != refund_vbucks or ledger[0][1] != balance_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. Final answer: parse refund tx id, tokens remaining, balance, and validate\\n    if not final_answer or not isinstance(final_answer, str):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Search for refund transaction id, tokens remaining, and balance (robust, support nonstandard ordering)\\n    id_matches = re.findall(r\\\"refund transaction id\\\\D*(\\\\d+)\\\", final_answer, re.IGNORECASE)\\n    tokens_matches = re.findall(r\\\"tokens? remaining\\\\D*(\\\\d+)\\\", final_answer, re.IGNORECASE)\\n    balance_matches = re.findall(r\\\"wallet balance|v-?bucks? balance|balance.*?([\\\\d]+)\\\", final_answer, re.IGNORECASE)\\n    # Accept also if in JSON block\\n    if not id_matches:\\n        id_matches = re.findall(r'\\\"id\\\"\\\\s*:\\\\s*(\\\\d+)', final_answer)\\n    if not tokens_matches:\\n        tokens_matches = re.findall(r'\\\"tokens?_?remaining\\\"\\\\s*:\\\\s*(\\\\d+)', final_answer)\\n    if not balance_matches:\\n        # match \\\"balance\\\":1234 or \\\"balance_vbucks\\\":1234\\n        balance_matches = re.findall(r'\\\"balance(_vbucks)?\\\"\\\\s*:\\\\s*(\\\\d+)', final_answer)\\n        if balance_matches:\\n            balance_matches = [bm[1] for bm in balance_matches]\\n    # All must be present and correct\\n    if not id_matches or not tokens_matches or not balance_matches:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    try:\\n        id_match = int(id_matches[0])\\n        tokens_match = int(tokens_matches[0])\\n        balance_match = int(balance_matches[0])\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if id_match != refund_tx_id or tokens_match != tokens_final or balance_match != balance_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 8, "task": "Create a price alert rule for my wishlist item 'Star Wand' to notify me when it appears in the shop at 800 V-Bucks or less, and return the saved alert rule ID and parameters.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            c = conn.cursor()\n            c.execute(query, params)\n            rows = c.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Find item_id for 'Star Wand' (case-insensitive match)\n    star_wand_row = safe_query(final_db_path, \"SELECT id FROM items WHERE LOWER(name)=LOWER(?)\", (\"Star Wand\",))\n    if len(star_wand_row) != 1:\n        return {\"result\": \"others\"}\n    star_wand_id = star_wand_row[0][0]\n\n    # 2. Get user's (user_id = 1) wishlist id, just for confirming wishlist\n    wishlist_row = safe_query(final_db_path, \"SELECT id FROM wishlists WHERE user_id = ?\", (1,))\n    if len(wishlist_row) != 1:\n        return {\"result\": \"others\"}\n    wishlist_id = wishlist_row[0][0]\n    # Make sure Star Wand is on the wishlist (defense)\n    star_on_wishlist = safe_query(final_db_path, \"SELECT 1 FROM wishlist_items WHERE wishlist_id=? AND item_id=?\", (wishlist_id, star_wand_id))\n    # The task says 'my wishlist item', so it must be on the wishlist\n    if not star_on_wishlist:\n        return {\"result\": \"others\"}\n\n    # 3. Get all price_alert_rules for user=1 and item=Star Wand (id=105)\n    final_alerts = safe_query(final_db_path, \"SELECT id, user_id, item_id, region_id, max_price_vbucks, is_active FROM price_alert_rules WHERE user_id=? AND item_id=?\", (1, star_wand_id))\n    initial_alerts = safe_query(initial_db_path, \"SELECT id, user_id, item_id, region_id, max_price_vbucks, is_active FROM price_alert_rules WHERE user_id=? AND item_id=?\", (1, star_wand_id))\n    # All alert rule ids in initial\n    initial_alert_ids = set(row[0] for row in initial_alerts)\n    # 4. The new alert rule must be present in final only\n    new_rules = [row for row in final_alerts if row[0] not in initial_alert_ids and row[1]==1 and row[2]==star_wand_id]\n    # Must be exactly ONE new alert for this item and user\n    if len(new_rules) != 1:\n        return {\"result\": \"others\"}\n    new_rule = new_rules[0]\n    (alert_id, user_id, item_id, region_id, max_price, is_active) = new_rule\n\n    # 5. Must be for region_id 1 (matching all user's existing alerts) and active\n    if region_id != 1 or is_active != 1:\n        return {\"result\": \"others\"}\n    # 6. Must be max_price_vbucks <= 800\n    if max_price is None or max_price > 800 or max_price < 0:\n        return {\"result\": \"others\"}\n\n    # 7. final_answer must be present and contain returned rule ID & parameters (item name, price, etc)\n    if not final_answer or not isinstance(final_answer, str):\n        return {\"result\": \"others\"}\n    # Extract rule id (should be returned as a number)\n    id_match = re.search(r\"(alert\\s*rule\\s*id|rule\\s*id|id)\\s*[:=\\- ]*([0-9]+)\", final_answer, re.IGNORECASE)\n    if not id_match:\n        return {\"result\": \"others\"}\n    extracted_id = int(id_match.group(2))\n    if extracted_id != alert_id:\n        return {\"result\": \"others\"}\n    # Confirm answer contains 'Star Wand' (case-insensitive substring)\n    if \"star wand\" not in final_answer.lower():\n        return {\"result\": \"others\"}\n\n    # Confirm answer contains the max price vbucks (must match or be lower) - allow '800', '800 V-Bucks', etc.\n    price_pat = r\"([0-9]{2,5})\\s*(v-?bucks|vb|vbucks|vbuck)?\"\n    price_found = False\n    for m in re.finditer(price_pat, final_answer, re.IGNORECASE):\n        num = int(m.group(1))\n        if num == max_price:\n            price_found = True\n            break\n    if not price_found:\n        return {\"result\": \"others\"}\n    # Answer must indicate this is a shop price alert or notifies for price <= 800 in shop\n    alert_phrases = [\"shop\", \"price alert\", \"notify\", \"v-bucks\", \"vbucks\", \"appears\", \"price drop\"]\n    if not any(ph in final_answer.lower() for ph in alert_phrases):\n        return {\"result\": \"others\"}\n    # No duplicate alerts (if more than 1 matching new alert rule inserted, reject)\n    if len(new_rules) != 1:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task asks to create a price alert rule for the user's wishlist item 'Star Wand' (which must be item_id 105), with alerting at 800 V-Bucks or less and the alert should be for the shop appearance. The agent also needs to return the alert rule's ID and parameters. We must check (a) that a price_alert_rules entry is newly present in the final database and not the initial, for (user_id=1, item_id=105, region_id=1), with max_price_vbucks<=800 and is_active=1, (b) that it is not a duplicate of pre-existing rules, (c) that the rule is the only new matching alert for this item and user, (d) that the final_answer contains the returned alert rule ID and all relevant parameters (item, price, etc.), and (e) that the parameters in the final_answer exactly match the actual data in the new price_alert_rules row.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Identify the 'Star Wand' item_id from the items table (should be unique, by name)\",\n        \"Compare initial and final price_alert_rules tables: exactly one new row for user_id=1, item_id for 'Star Wand', region_id=1, max_price_vbucks<=800, is_active=1\",\n        \"Ensure the price_alert_rule is not present in the initial DB\",\n        \"Extract alert rule ID and parameters from final_answer; match these with the new record in final DB\",\n        \"final_answer must state the rule ID, max price (<=800), and the correct item\",\n        \"If multiple new alert rules exist for this user/item, or data mismatches, return others\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            rows = c.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Find item_id for 'Star Wand' (case-insensitive match)\\n    star_wand_row = safe_query(final_db_path, \\\"SELECT id FROM items WHERE LOWER(name)=LOWER(?)\\\", (\\\"Star Wand\\\",))\\n    if len(star_wand_row) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    star_wand_id = star_wand_row[0][0]\\n\\n    # 2. Get user's (user_id = 1) wishlist id, just for confirming wishlist\\n    wishlist_row = safe_query(final_db_path, \\\"SELECT id FROM wishlists WHERE user_id = ?\\\", (1,))\\n    if len(wishlist_row) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    wishlist_id = wishlist_row[0][0]\\n    # Make sure Star Wand is on the wishlist (defense)\\n    star_on_wishlist = safe_query(final_db_path, \\\"SELECT 1 FROM wishlist_items WHERE wishlist_id=? AND item_id=?\\\", (wishlist_id, star_wand_id))\\n    # The task says 'my wishlist item', so it must be on the wishlist\\n    if not star_on_wishlist:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Get all price_alert_rules for user=1 and item=Star Wand (id=105)\\n    final_alerts = safe_query(final_db_path, \\\"SELECT id, user_id, item_id, region_id, max_price_vbucks, is_active FROM price_alert_rules WHERE user_id=? AND item_id=?\\\", (1, star_wand_id))\\n    initial_alerts = safe_query(initial_db_path, \\\"SELECT id, user_id, item_id, region_id, max_price_vbucks, is_active FROM price_alert_rules WHERE user_id=? AND item_id=?\\\", (1, star_wand_id))\\n    # All alert rule ids in initial\\n    initial_alert_ids = set(row[0] for row in initial_alerts)\\n    # 4. The new alert rule must be present in final only\\n    new_rules = [row for row in final_alerts if row[0] not in initial_alert_ids and row[1]==1 and row[2]==star_wand_id]\\n    # Must be exactly ONE new alert for this item and user\\n    if len(new_rules) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    new_rule = new_rules[0]\\n    (alert_id, user_id, item_id, region_id, max_price, is_active) = new_rule\\n\\n    # 5. Must be for region_id 1 (matching all user's existing alerts) and active\\n    if region_id != 1 or is_active != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 6. Must be max_price_vbucks <= 800\\n    if max_price is None or max_price > 800 or max_price < 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. final_answer must be present and contain returned rule ID & parameters (item name, price, etc)\\n    if not final_answer or not isinstance(final_answer, str):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Extract rule id (should be returned as a number)\\n    id_match = re.search(r\\\"(alert\\\\s*rule\\\\s*id|rule\\\\s*id|id)\\\\s*[:=\\\\- ]*([0-9]+)\\\", final_answer, re.IGNORECASE)\\n    if not id_match:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    extracted_id = int(id_match.group(2))\\n    if extracted_id != alert_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Confirm answer contains 'Star Wand' (case-insensitive substring)\\n    if \\\"star wand\\\" not in final_answer.lower():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Confirm answer contains the max price vbucks (must match or be lower) - allow '800', '800 V-Bucks', etc.\\n    price_pat = r\\\"([0-9]{2,5})\\\\s*(v-?bucks|vb|vbucks|vbuck)?\\\"\\n    price_found = False\\n    for m in re.finditer(price_pat, final_answer, re.IGNORECASE):\\n        num = int(m.group(1))\\n        if num == max_price:\\n            price_found = True\\n            break\\n    if not price_found:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Answer must indicate this is a shop price alert or notifies for price <= 800 in shop\\n    alert_phrases = [\\\"shop\\\", \\\"price alert\\\", \\\"notify\\\", \\\"v-bucks\\\", \\\"vbucks\\\", \\\"appears\\\", \\\"price drop\\\"]\\n    if not any(ph in final_answer.lower() for ph in alert_phrases):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # No duplicate alerts (if more than 1 matching new alert rule inserted, reject)\\n    if len(new_rules) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 9, "task": "Generate a personal purchase history summary for the last 30 days showing total V-Bucks spent, number of purchases, number of gifts sent, and a breakdown by category (Outfit/Emote/Wrap/Bundle).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n\n    # Required categories for output\n    REQUIRED_CATEGORIES = set(['Outfit', 'Emote', 'Wrap', 'Bundle'])\n    USER_ID = 1\n    \n    # Helper to safely query DB (read-only)\n    def safe_query(db_path: str, query: str, params: tuple = ( )):\n        try:\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\n            c = conn.cursor()\n            c.execute(query, params)\n            rows = c.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # Helper to get cutoff date: latest used date in user data\n    def get_latest_date(db_path: str):\n        q = '''SELECT MAX(ts) FROM (\n            SELECT MAX(purchased_at) as ts FROM purchase_receipts\n            UNION SELECT MAX(created_at) as ts FROM gift_transactions\n            UNION SELECT MAX(created_at) as ts FROM wallet_ledger\n        )'''\n        results = safe_query(db_path, q)\n        if results and results[0][0]:\n            try:\n                return datetime.strptime(results[0][0], '%Y-%m-%d %H:%M:%S')\n            except Exception:\n                return None\n        return None\n\n    def parse_number(s):\n        # Utility to parse numbers, removing commas\n        if s is None:\n            return None\n        try:\n            return int(s.replace(\",\", \"\").strip())\n        except Exception:\n            try:\n                # fallback: float -> int (for wonky formatting)\n                return int(float(s.replace(\",\", \"\").strip()))\n            except Exception:\n                return None\n\n    # ------------------ DATA EXTRACTION ----------------------\n    # Step 1. Get summary data from database\n    summary = {\n        'total_vbucks_spent': 0,\n        'num_purchases': 0,\n        'num_gifts_sent': 0,\n        'category_breakdown': {cat: 0 for cat in REQUIRED_CATEGORIES}\n    }\n    latest_dt = get_latest_date(final_db_path)\n    if latest_dt is None:\n        return {'result': 'others'}\n    cutoff_dt = latest_dt - timedelta(days=30)\n    cutoff_str = cutoff_dt.strftime('%Y-%m-%d %H:%M:%S')\n    # Purchases\n    purchase_rows = safe_query(final_db_path, \n        \"\"\"\n        SELECT pr.id, pr.total_charged_vbucks, pr.status, pr.purchased_at\n        FROM purchase_receipts pr\n        WHERE pr.user_id=? AND pr.purchased_at > ?\n        \"\"\", (USER_ID, cutoff_str)\n    )\n    # Only include purchases with status 'completed' (not refunded/failed)\n    purchase_ids = set()\n    for pr_id, vbucks, status, purchased_at in purchase_rows:\n        if status == 'completed':\n            purchase_ids.add(pr_id)\n            try:\n                summary['total_vbucks_spent'] += int(vbucks)\n            except Exception:\n                return {'result': 'others'}\n    summary['num_purchases'] = len(purchase_ids)\n    # Build category breakdown\n    if purchase_ids:\n        receipt_items = safe_query(final_db_path, \n            f\"SELECT pri.receipt_id, i.category FROM purchase_receipt_items pri JOIN items i ON pri.item_id = i.id WHERE pri.receipt_id IN ({','.join(['?']*len(purchase_ids))})\",\n            tuple(purchase_ids)\n        )\n        for _, cat in receipt_items:\n            cat = cat.strip()\n            if cat in summary['category_breakdown']:\n                summary['category_breakdown'][cat] += 1\n    # Gifts sent\n    # Need status='delivered' and sender_user_id=1\n    rows = safe_query(final_db_path, \n        \"\"\"\n        SELECT id FROM gift_transactions WHERE sender_user_id=? AND created_at > ? AND status='delivered' \n        \"\"\", (USER_ID, cutoff_str))\n    summary['num_gifts_sent'] = len(rows)\n\n    # Only include categories found in the items/category table\n    # ------------------- FINAL_ANSWER EXTRACTION ----------------------\n    if not (final_answer and isinstance(final_answer, str) and final_answer.strip()):\n        return {'result': 'others'}\n\n    text = final_answer.lower()\n\n    # Four required fields -- flexible regex for 'total vbucks', 'number of purchases', 'number of gifts sent', 'breakdown by category'\n    # 1. Total V-Bucks spent\n    vbucks_spent_pat = re.compile(r\"(?:(?:total\\s*)?v-?bucks\\s*(?:spent)?\\s*[:=]?\\s*)([\\d,]+)\", re.IGNORECASE)\n    # 2. Number of purchases\n    num_pur_pat = re.compile(r\"(number\\s*of\\s*purchases|purchases)\\s*[:=]?\\s*(\\d+)\", re.IGNORECASE)\n    # 3. Number of gifts sent\n    num_gift_pat = re.compile(r\"(number\\s*of\\s*gifts\\s*sent|gifts\\s*sent)\\s*[:=]?\\s*(\\d+)\", re.IGNORECASE)\n    # 4. Breakdown by category\n    # Accept category block with lines like Outfit: N, Emote: N, etc.\n    breakdown_pat = re.compile(r\"(outfit|emote|wrap|bundle)\\s*[:=]?\\s*(\\d+)\", re.IGNORECASE)\n\n    # Extract values\n    vbucks_match = vbucks_spent_pat.search(final_answer)\n    num_pur_match = num_pur_pat.search(final_answer)\n    num_gift_match = num_gift_pat.search(final_answer)\n    breakdown_matches = breakdown_pat.findall(final_answer)\n\n    # Defensive checks\n    extracted = {\n        'total_vbucks_spent': None,\n        'num_purchases': None,\n        'num_gifts_sent': None,\n        'category_breakdown': {}\n    }\n    if vbucks_match:\n        extracted['total_vbucks_spent'] = parse_number(vbucks_match.group(1))\n    if num_pur_match:\n        extracted['num_purchases'] = parse_number(num_pur_match.group(2))\n    if num_gift_match:\n        extracted['num_gifts_sent'] = parse_number(num_gift_match.group(2))\n    # Category breakdown\n    for cat, val in breakdown_matches:\n        cat_title = cat.strip().capitalize() # canonical: Outfit/Emote/Wrap/Bundle\n        if cat_title in REQUIRED_CATEGORIES:\n            extracted['category_breakdown'][cat_title] = parse_number(val)\n    # All required fields must be present\n    if (extracted['total_vbucks_spent'] is None \n        or extracted['num_purchases'] is None \n        or extracted['num_gifts_sent'] is None):\n        return {'result': 'others'}\n    # Must cover all required categories (even if zero)\n    for rc in REQUIRED_CATEGORIES:\n        if rc not in extracted['category_breakdown']:\n            # Could be zero, but must be explicitly present\n            return {'result': 'others'}\n        if extracted['category_breakdown'][rc] is None:\n            return {'result': 'others'}\n    # No extra categories allowed\n    for cat in extracted['category_breakdown']:\n        if cat not in REQUIRED_CATEGORIES:\n            return {'result': 'others'}\n    # Now, compare extracted summary to the computed values\n    if (extracted['total_vbucks_spent'] != summary['total_vbucks_spent'] \n        or extracted['num_purchases'] != summary['num_purchases']\n        or extracted['num_gifts_sent'] != summary['num_gifts_sent']):\n        return {'result': 'others'}\n    for cat in REQUIRED_CATEGORIES:\n        # Must match exactly\n        if extracted['category_breakdown'][cat] != summary['category_breakdown'][cat]:\n            return {'result': 'others'}\n    # All checks passed\n    return {'result': 'complete'}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we need to check that the agent generated a personal purchase history summary for the last 30 days for the user (user_id=1), including: 1) total V-Bucks spent, 2) number of purchases, 3) number of gifts sent, 4) a breakdown by category (Outfit/Emote/Wrap/Bundle). Since this is a query/reporting task, only the content and structure of the final_answer are relevant, as the database is not modified by the agent. The code must extract and check all four data points from the final_answer and cross-reference the results with the actual database content for the 30-day window ending with the max date in the tables (for deterministic cutoff). All values reported must be accurate, categories must match, no extra or missing required data points can be present. Edge cases (zero purchases or zero gifts) must be handled. If any value is unconfirmed or mismatched, or if the format is wrong, or if final_answer is missing, we return 'others'.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Ensure final_answer is not None/empty and is text\",\n        \"Extract total V-Bucks spent on purchases (excluding refunds/failed)\",\n        \"Extract the number of purchases (completed purchase_receipts for user_id=1 in last 30 days)\",\n        \"Extract the number of gifts sent (delivered gift_transactions from user_id=1 in last 30 days)\",\n        \"Extract item category breakdown (number of purchases per category: Outfit, Emote, Wrap, Bundle, based on items bought in last 30 days)\",\n        \"Cross-reference all extracted values with what actually happened in the last 30 days per the database\",\n        \"Check answer format: must include all four required fields (even if some are zero), and categories listed must match those used in the database\",\n        \"If any check fails or is uncertain, return 'others'\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n\\n    # Required categories for output\\n    REQUIRED_CATEGORIES = set(['Outfit', 'Emote', 'Wrap', 'Bundle'])\\n    USER_ID = 1\\n    \\n    # Helper to safely query DB (read-only)\\n    def safe_query(db_path: str, query: str, params: tuple = ( )):\\n        try:\\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            rows = c.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # Helper to get cutoff date: latest used date in user data\\n    def get_latest_date(db_path: str):\\n        q = '''SELECT MAX(ts) FROM (\\n            SELECT MAX(purchased_at) as ts FROM purchase_receipts\\n            UNION SELECT MAX(created_at) as ts FROM gift_transactions\\n            UNION SELECT MAX(created_at) as ts FROM wallet_ledger\\n        )'''\\n        results = safe_query(db_path, q)\\n        if results and results[0][0]:\\n            try:\\n                return datetime.strptime(results[0][0], '%Y-%m-%d %H:%M:%S')\\n            except Exception:\\n                return None\\n        return None\\n\\n    def parse_number(s):\\n        # Utility to parse numbers, removing commas\\n        if s is None:\\n            return None\\n        try:\\n            return int(s.replace(\\\",\\\", \\\"\\\").strip())\\n        except Exception:\\n            try:\\n                # fallback: float -> int (for wonky formatting)\\n                return int(float(s.replace(\\\",\\\", \\\"\\\").strip()))\\n            except Exception:\\n                return None\\n\\n    # ------------------ DATA EXTRACTION ----------------------\\n    # Step 1. Get summary data from database\\n    summary = {\\n        'total_vbucks_spent': 0,\\n        'num_purchases': 0,\\n        'num_gifts_sent': 0,\\n        'category_breakdown': {cat: 0 for cat in REQUIRED_CATEGORIES}\\n    }\\n    latest_dt = get_latest_date(final_db_path)\\n    if latest_dt is None:\\n        return {'result': 'others'}\\n    cutoff_dt = latest_dt - timedelta(days=30)\\n    cutoff_str = cutoff_dt.strftime('%Y-%m-%d %H:%M:%S')\\n    # Purchases\\n    purchase_rows = safe_query(final_db_path, \\n        \\\"\\\"\\\"\\n        SELECT pr.id, pr.total_charged_vbucks, pr.status, pr.purchased_at\\n        FROM purchase_receipts pr\\n        WHERE pr.user_id=? AND pr.purchased_at > ?\\n        \\\"\\\"\\\", (USER_ID, cutoff_str)\\n    )\\n    # Only include purchases with status 'completed' (not refunded/failed)\\n    purchase_ids = set()\\n    for pr_id, vbucks, status, purchased_at in purchase_rows:\\n        if status == 'completed':\\n            purchase_ids.add(pr_id)\\n            try:\\n                summary['total_vbucks_spent'] += int(vbucks)\\n            except Exception:\\n                return {'result': 'others'}\\n    summary['num_purchases'] = len(purchase_ids)\\n    # Build category breakdown\\n    if purchase_ids:\\n        receipt_items = safe_query(final_db_path, \\n            f\\\"SELECT pri.receipt_id, i.category FROM purchase_receipt_items pri JOIN items i ON pri.item_id = i.id WHERE pri.receipt_id IN ({','.join(['?']*len(purchase_ids))})\\\",\\n            tuple(purchase_ids)\\n        )\\n        for _, cat in receipt_items:\\n            cat = cat.strip()\\n            if cat in summary['category_breakdown']:\\n                summary['category_breakdown'][cat] += 1\\n    # Gifts sent\\n    # Need status='delivered' and sender_user_id=1\\n    rows = safe_query(final_db_path, \\n        \\\"\\\"\\\"\\n        SELECT id FROM gift_transactions WHERE sender_user_id=? AND created_at > ? AND status='delivered' \\n        \\\"\\\"\\\", (USER_ID, cutoff_str))\\n    summary['num_gifts_sent'] = len(rows)\\n\\n    # Only include categories found in the items/category table\\n    # ------------------- FINAL_ANSWER EXTRACTION ----------------------\\n    if not (final_answer and isinstance(final_answer, str) and final_answer.strip()):\\n        return {'result': 'others'}\\n\\n    text = final_answer.lower()\\n\\n    # Four required fields -- flexible regex for 'total vbucks', 'number of purchases', 'number of gifts sent', 'breakdown by category'\\n    # 1. Total V-Bucks spent\\n    vbucks_spent_pat = re.compile(r\\\"(?:(?:total\\\\s*)?v-?bucks\\\\s*(?:spent)?\\\\s*[:=]?\\\\s*)([\\\\d,]+)\\\", re.IGNORECASE)\\n    # 2. Number of purchases\\n    num_pur_pat = re.compile(r\\\"(number\\\\s*of\\\\s*purchases|purchases)\\\\s*[:=]?\\\\s*(\\\\d+)\\\", re.IGNORECASE)\\n    # 3. Number of gifts sent\\n    num_gift_pat = re.compile(r\\\"(number\\\\s*of\\\\s*gifts\\\\s*sent|gifts\\\\s*sent)\\\\s*[:=]?\\\\s*(\\\\d+)\\\", re.IGNORECASE)\\n    # 4. Breakdown by category\\n    # Accept category block with lines like Outfit: N, Emote: N, etc.\\n    breakdown_pat = re.compile(r\\\"(outfit|emote|wrap|bundle)\\\\s*[:=]?\\\\s*(\\\\d+)\\\", re.IGNORECASE)\\n\\n    # Extract values\\n    vbucks_match = vbucks_spent_pat.search(final_answer)\\n    num_pur_match = num_pur_pat.search(final_answer)\\n    num_gift_match = num_gift_pat.search(final_answer)\\n    breakdown_matches = breakdown_pat.findall(final_answer)\\n\\n    # Defensive checks\\n    extracted = {\\n        'total_vbucks_spent': None,\\n        'num_purchases': None,\\n        'num_gifts_sent': None,\\n        'category_breakdown': {}\\n    }\\n    if vbucks_match:\\n        extracted['total_vbucks_spent'] = parse_number(vbucks_match.group(1))\\n    if num_pur_match:\\n        extracted['num_purchases'] = parse_number(num_pur_match.group(2))\\n    if num_gift_match:\\n        extracted['num_gifts_sent'] = parse_number(num_gift_match.group(2))\\n    # Category breakdown\\n    for cat, val in breakdown_matches:\\n        cat_title = cat.strip().capitalize() # canonical: Outfit/Emote/Wrap/Bundle\\n        if cat_title in REQUIRED_CATEGORIES:\\n            extracted['category_breakdown'][cat_title] = parse_number(val)\\n    # All required fields must be present\\n    if (extracted['total_vbucks_spent'] is None \\n        or extracted['num_purchases'] is None \\n        or extracted['num_gifts_sent'] is None):\\n        return {'result': 'others'}\\n    # Must cover all required categories (even if zero)\\n    for rc in REQUIRED_CATEGORIES:\\n        if rc not in extracted['category_breakdown']:\\n            # Could be zero, but must be explicitly present\\n            return {'result': 'others'}\\n        if extracted['category_breakdown'][rc] is None:\\n            return {'result': 'others'}\\n    # No extra categories allowed\\n    for cat in extracted['category_breakdown']:\\n        if cat not in REQUIRED_CATEGORIES:\\n            return {'result': 'others'}\\n    # Now, compare extracted summary to the computed values\\n    if (extracted['total_vbucks_spent'] != summary['total_vbucks_spent'] \\n        or extracted['num_purchases'] != summary['num_purchases']\\n        or extracted['num_gifts_sent'] != summary['num_gifts_sent']):\\n        return {'result': 'others'}\\n    for cat in REQUIRED_CATEGORIES:\\n        # Must match exactly\\n        if extracted['category_breakdown'][cat] != summary['category_breakdown'][cat]:\\n            return {'result': 'others'}\\n    # All checks passed\\n    return {'result': 'complete'}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 0, "task": "Create an envelope named 'NDA - Acme Vendor - Feb 2026' using the 'Mutual NDA v3' template, set recipients to Alice Nguyen (Signer, alice.nguyen@example.com) and Ben Ortiz (CC, ben.ortiz@example.com), and send it with the email subject 'Please sign: Mutual NDA' and message 'Hi Alice, please sign by Friday so we can proceed.'", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            c = conn.cursor()\n            c.execute(query, params)\n            rows = c.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Helper: Get template_id for 'Mutual NDA v3'\n    template_rows = safe_query(final_db_path, \"SELECT id FROM templates WHERE name=?\", (\"Mutual NDA v3\",))\n    if not template_rows or not isinstance(template_rows, list):\n        return {\"result\": \"others\"}\n    template_id = template_rows[0][0]\n\n    # 1. In final: Find envelope with exact required title\n    env_rows = safe_query(final_db_path, \"SELECT id, title, subject, email_message, status, template_id, source_type, voided_at, void_reason FROM envelopes WHERE title=?\", (\"NDA - Acme Vendor - Feb 2026\",))\n    if len(env_rows) != 1:\n        return {\"result\": \"others\"}  # Must be exactly one such envelope\n    envelope = env_rows[0]\n    env_id, title, subject, email_message, status, env_template_id, source_type, voided_at, void_reason = envelope\n\n    # 2. Envelope with same title must NOT exist in initial_db\n    init_rows = safe_query(initial_db_path, \"SELECT id FROM envelopes WHERE title=?\", (\"NDA - Acme Vendor - Feb 2026\",))\n    if init_rows:\n        return {\"result\": \"others\"}\n\n    # 3. Envelope uses correct template, subject, email_message, source_type\n    if (env_template_id != template_id or\n        subject != \"Please sign: Mutual NDA\" or\n        email_message != \"Hi Alice, please sign by Friday so we can proceed.\" or\n        source_type != \"template\"):\n        return {\"result\": \"others\"}\n\n    # 4. Envelope status must be at least 'Sent', not Voided or Declined\n    VALID_STATUSES = (\"Sent\", \"Delivered\", \"Completed\")\n    if status not in VALID_STATUSES:\n        return {\"result\": \"others\"}\n    if voided_at is not None or (void_reason is not None and len(void_reason.strip()) > 0):\n        return {\"result\": \"others\"}\n\n    # 5. Envelope recipients check (must be only Alice and Ben, correct roles/order)\n    recips = safe_query(final_db_path, \"SELECT role, routing_order, name, email FROM envelope_recipients WHERE envelope_id=? ORDER BY routing_order ASC\", (env_id,))\n    if len(recips) != 2:\n        return {\"result\": \"others\"}\n    # Validate entries\n    want = [\n        (\"Signer\", 1, \"Alice Nguyen\", \"alice.nguyen@example.com\"),\n        (\"CC\", 2, \"Ben Ortiz\", \"ben.ortiz@example.com\")\n    ]\n    for a, b in zip(recips, want):\n        if tuple(a) != b:\n            return {\"result\": \"others\"}\n    # Confirm NO other recipients for this envelope\n    recips_all = safe_query(final_db_path, \"SELECT COUNT(*) FROM envelope_recipients WHERE envelope_id=?\", (env_id,))\n    if not recips_all or recips_all[0][0] != 2:\n        return {\"result\": \"others\"}\n\n    # 6. Audit events: must have 'created' with source=template, and 'sent' with correct subject\n    events = safe_query(final_db_path, \"SELECT event_type, details_json FROM audit_events WHERE envelope_id=?\", (env_id,))\n    has_created = has_sent = False\n    for typ, details_json in events:\n        if typ == 'created' and details_json and 'template' in details_json:\n            has_created = True\n        if typ == 'sent' and details_json and 'Please sign: Mutual NDA' in details_json:\n            has_sent = True\n    if not (has_created and has_sent):\n        return {\"result\": \"others\"}\n\n    # All requirements met\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must check that after the agent executes, a new envelope has been created with the title 'NDA - Acme Vendor - Feb 2026' using the 'Mutual NDA v3' template. This envelope must have (1) correct title, (2) subject 'Please sign: Mutual NDA', (3) email message 'Hi Alice, please sign by Friday so we can proceed.', (4) source_type 'template', (5) the correct template_id for 'Mutual NDA v3', (6) at least status 'Sent' or 'Completed' (must be sent to recipients), (7) recipients: Alice Nguyen (Signer, alice.nguyen@example.com) and Ben Ortiz (CC, ben.ortiz@example.com), (8) correct routing order and roles, (9) no evidence the envelope is voided or declined, and (10) an audit_events 'sent' event referencing the envelope with subject 'Please sign: Mutual NDA'. All of this must be true in final_db, and it must not exist in initial_db, ensuring it is a new envelope. No LLM answer parsing is involved, so only database state matters.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Envelope with title 'NDA - Acme Vendor - Feb 2026' exists only in final_db (not in initial_db)\",\n        \"Envelope uses template 'Mutual NDA v3' and the correct template_id\",\n        \"Envelope subject is 'Please sign: Mutual NDA', email_message is exactly 'Hi Alice, please sign by Friday so we can proceed.'\",\n        \"Envelope status is at least 'Sent' (or later, i.e. 'Delivered', 'Completed')\",\n        \"Envelope has two recipients: Alice Nguyen as 'Signer', alice.nguyen@example.com with routing_order 1; Ben Ortiz as 'CC', ben.ortiz@example.com with routing_order 2\",\n        \"No other recipients present in the envelope\",\n        \"Matching audit_events exist for 'created' (from template) and 'sent' (with proper subject)\",\n        \"Envelope is not Voided or Declined\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            c = conn.cursor()\\n            c.execute(query, params)\\n            rows = c.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Helper: Get template_id for 'Mutual NDA v3'\\n    template_rows = safe_query(final_db_path, \\\"SELECT id FROM templates WHERE name=?\\\", (\\\"Mutual NDA v3\\\",))\\n    if not template_rows or not isinstance(template_rows, list):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    template_id = template_rows[0][0]\\n\\n    # 1. In final: Find envelope with exact required title\\n    env_rows = safe_query(final_db_path, \\\"SELECT id, title, subject, email_message, status, template_id, source_type, voided_at, void_reason FROM envelopes WHERE title=?\\\", (\\\"NDA - Acme Vendor - Feb 2026\\\",))\\n    if len(env_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}  # Must be exactly one such envelope\\n    envelope = env_rows[0]\\n    env_id, title, subject, email_message, status, env_template_id, source_type, voided_at, void_reason = envelope\\n\\n    # 2. Envelope with same title must NOT exist in initial_db\\n    init_rows = safe_query(initial_db_path, \\\"SELECT id FROM envelopes WHERE title=?\\\", (\\\"NDA - Acme Vendor - Feb 2026\\\",))\\n    if init_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Envelope uses correct template, subject, email_message, source_type\\n    if (env_template_id != template_id or\\n        subject != \\\"Please sign: Mutual NDA\\\" or\\n        email_message != \\\"Hi Alice, please sign by Friday so we can proceed.\\\" or\\n        source_type != \\\"template\\\"):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Envelope status must be at least 'Sent', not Voided or Declined\\n    VALID_STATUSES = (\\\"Sent\\\", \\\"Delivered\\\", \\\"Completed\\\")\\n    if status not in VALID_STATUSES:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if voided_at is not None or (void_reason is not None and len(void_reason.strip()) > 0):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Envelope recipients check (must be only Alice and Ben, correct roles/order)\\n    recips = safe_query(final_db_path, \\\"SELECT role, routing_order, name, email FROM envelope_recipients WHERE envelope_id=? ORDER BY routing_order ASC\\\", (env_id,))\\n    if len(recips) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Validate entries\\n    want = [\\n        (\\\"Signer\\\", 1, \\\"Alice Nguyen\\\", \\\"alice.nguyen@example.com\\\"),\\n        (\\\"CC\\\", 2, \\\"Ben Ortiz\\\", \\\"ben.ortiz@example.com\\\")\\n    ]\\n    for a, b in zip(recips, want):\\n        if tuple(a) != b:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Confirm NO other recipients for this envelope\\n    recips_all = safe_query(final_db_path, \\\"SELECT COUNT(*) FROM envelope_recipients WHERE envelope_id=?\\\", (env_id,))\\n    if not recips_all or recips_all[0][0] != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Audit events: must have 'created' with source=template, and 'sent' with correct subject\\n    events = safe_query(final_db_path, \\\"SELECT event_type, details_json FROM audit_events WHERE envelope_id=?\\\", (env_id,))\\n    has_created = has_sent = False\\n    for typ, details_json in events:\\n        if typ == 'created' and details_json and 'template' in details_json:\\n            has_created = True\\n        if typ == 'sent' and details_json and 'Please sign: Mutual NDA' in details_json:\\n            has_sent = True\\n    if not (has_created and has_sent):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All requirements met\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 1, "task": "Upload a PDF named 'Consulting_SOW_Q2_2026.pdf' to a new envelope titled 'SOW Q2 2026 - BlueSky', add recipients Carla Diaz (Signer, carla.diaz@example.com) and David Kim (Approver, david.kim@example.com) with signing order Carla=1 then David=2, place tabs for Carla (Signature, Date Signed, Text 'Company Name' required) and for David (Approve checkbox required), and send the envelope.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Defensive helper for read-only DB queries\n    def safe_query(db_path, sql, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(sql, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # 1. Find new envelope in final DB with the exact title\n    expected_title = 'SOW Q2 2026 - BlueSky'\n    # Find all envelope ids with this title in each DB\n    init_envs = safe_query(\n        initial_db_path, 'SELECT id FROM envelopes WHERE title = ?', (expected_title,))\n    init_env_ids = {row[0] for row in init_envs}\n    final_envs = safe_query(\n        final_db_path, 'SELECT id, status FROM envelopes WHERE title = ?', (expected_title,))\n    if not final_envs:\n        return {'result': 'others'}  # No such envelope\n    # Look for envelope(s) with this title not present in initial DB\n    candidate_envs = [row for row in final_envs if row[0] not in init_env_ids]\n    if len(candidate_envs) != 1:\n        return {'result': 'others'}  # None or ambiguous/multiple new envelopes\n    envelope_id = candidate_envs[0][0]\n    status = candidate_envs[0][1]\n    # Validate status\n    if status not in ('Sent', 'Delivered', 'Completed'):\n        return {'result': 'others'}\n    # Get basic envelope info\n    env = safe_query(final_db_path, 'SELECT id, title FROM envelopes WHERE id = ?', (envelope_id,))\n    if not env or env[0][1] != expected_title:\n        return {'result': 'others'}\n    # 2. Check for sent audit event\n    sent_audit = safe_query(final_db_path, \"SELECT 1 FROM audit_events WHERE envelope_id = ? AND event_type = 'sent'\", (envelope_id,))\n    if not sent_audit:\n        return {'result': 'others'}\n    # 3. Check envelope documents: must be exactly one, and filename match\n    env_docs = safe_query(final_db_path, 'SELECT document_id FROM envelope_documents WHERE envelope_id = ?', (envelope_id,))\n    if len(env_docs) != 1:\n        return {'result': 'others'}\n    doc_id = env_docs[0][0]\n    doc_info = safe_query(final_db_path, 'SELECT filename FROM documents WHERE id = ?', (doc_id,))\n    if not doc_info or doc_info[0][0] != 'Consulting_SOW_Q2_2026.pdf':\n        return {'result': 'others'}\n    # 4. Recipients: must be exactly 2, with precise roles, orders, emails\n    recips = safe_query(final_db_path, 'SELECT id, role, routing_order, name, email FROM envelope_recipients WHERE envelope_id = ? ORDER BY routing_order, id', (envelope_id,))\n    if len(recips) != 2:\n        return {'result': 'others'}\n    # Define expected recipients\n    expect_recip = [\n        {'role': 'Signer', 'routing_order': 1, 'name': 'Carla Diaz', 'email': 'carla.diaz@example.com'},\n        {'role': 'Approver', 'routing_order': 2, 'name': 'David Kim', 'email': 'david.kim@example.com'}\n    ]\n    # Exact match for all assignment fields (role, routing_order, name, email)\n    for ir, er in zip(recips, expect_recip):\n        if not (ir[1] == er['role'] and ir[2] == er['routing_order'] and ir[3] == er['name'] and ir[4].lower() == er['email']):\n            return {'result': 'others'}\n    # 5. Tab assignments for recipients, must be strict\n    recips_by_name = {(r[3], r[4].lower()): r[0] for r in recips}\n    carla_id = recips_by_name.get(('Carla Diaz', 'carla.diaz@example.com'))\n    david_id = recips_by_name.get(('David Kim', 'david.kim@example.com'))\n    if carla_id is None or david_id is None:\n        return {'result': 'others'}\n    # Tabs for Carla - must have:\n    carla_tabs = safe_query(final_db_path, 'SELECT tab_type, required, IFNULL(label, \"\"), IFNULL(anchor_text, \"\") FROM tabs WHERE envelope_id = ? AND recipient_id = ?', (envelope_id, carla_id))\n    types_labels = [(t[0], t[1], t[2], t[3]) for t in carla_tabs]\n    # At least one required signature\n    if not any(t[0] == 'signature' and t[1] == 1 for t in types_labels):\n        return {'result': 'others'}\n    # At least one required date_signed\n    if not any(t[0] == 'date_signed' and t[1] == 1 for t in types_labels):\n        return {'result': 'others'}\n    # At least one required text tab, must match 'Company Name' in label or anchor_text (case-insensitive substring)\n    found_company_tab = False\n    for t in types_labels:\n        if t[0] == 'text' and t[1] == 1:\n            label, anchor = t[2], t[3]\n            if re.search(r'company name', label, re.I) or re.search(r'company name', anchor, re.I):\n                found_company_tab = True\n                break\n    if not found_company_tab:\n        return {'result': 'others'}\n    # Tabs for David - at least one required checkbox\n    david_tabs = safe_query(final_db_path, 'SELECT tab_type, required FROM tabs WHERE envelope_id = ? AND recipient_id = ?', (envelope_id, david_id))\n    if not any(t[0] == 'checkbox' and t[1] == 1 for t in david_tabs):\n        return {'result': 'others'}\n    # 6. No extra recipients\n    recip_cnt = safe_query(final_db_path, 'SELECT COUNT(1) FROM envelope_recipients WHERE envelope_id = ?', (envelope_id,))\n    if not recip_cnt or recip_cnt[0][0] != 2:\n        return {'result': 'others'}\n    # 7. No extra docs\n    doc_cnt = safe_query(final_db_path, 'SELECT COUNT(1) FROM envelope_documents WHERE envelope_id = ?', (envelope_id,))\n    if not doc_cnt or doc_cnt[0][0] != 1:\n        return {'result': 'others'}\n    # 8. No recipient with sms auth, extra roles, etc\n    recips_full = safe_query(final_db_path, 'SELECT role, name, email, sms_phone, auth_required FROM envelope_recipients WHERE envelope_id = ?', (envelope_id,))\n    for r in recips_full:\n        if r[3] or (r[4] and r[4] != 0):\n            return {'result': 'others'}\n    # All checks passed\n    return {'result': 'complete'}\n", "raw_response": "{\n    \"reasoning\": \"To verify the agent completed the specified DocuSign e-signature workflow, we must check for creation and completion of a new envelope titled 'SOW Q2 2026 - BlueSky', containing a single PDF document named 'Consulting_SOW_Q2_2026.pdf'. The envelope must have two recipients: Carla Diaz as Signer (routing order 1, carla.diaz@example.com), David Kim as Approver (routing order 2, david.kim@example.com). Carla must have a signature, date_signed, and a required text tab labeled or hinting at 'Company Name', all required; David must have at least one required Approve checkbox tab. The envelope must be in Sent or later status, but as per the task, must have been sent, not necessarily completed/signed. All relationships, including doc-enveloping, recipient assignments, and tabs, must be correct. If any part is missing, ambiguous, or incorrect (extra recipients, missing tabs, not sent, not new), the result is 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"A new envelope exists in the final DB (not in initial DB) with exact title 'SOW Q2 2026 - BlueSky'\",\n        \"The envelope has status at least 'Sent' (Sent, Delivered, or Completed, but not Voided/Declined)\",\n        \"The envelope is linked to exactly one document with filename 'Consulting_SOW_Q2_2026.pdf'\",\n        \"The envelope has exactly two recipients: Carla Diaz (Signer, order 1, carla.diaz@example.com), David Kim (Approver, order 2, david.kim@example.com)\",\n        \"For Carla Diaz: at least one required signature tab, one required date_signed tab, and one required text tab matching 'Company Name', all required\",\n        \"For David Kim: at least one required checkbox tab\",\n        \"All routing orders and roles must exactly match the requirements\",\n        \"No extra recipients, no missing recipients, no extra docs\",\n        \"Envelope must have been sent (check 'sent' audit_event for this envelope)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Defensive helper for read-only DB queries\\n    def safe_query(db_path, sql, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(sql, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # 1. Find new envelope in final DB with the exact title\\n    expected_title = 'SOW Q2 2026 - BlueSky'\\n    # Find all envelope ids with this title in each DB\\n    init_envs = safe_query(\\n        initial_db_path, 'SELECT id FROM envelopes WHERE title = ?', (expected_title,))\\n    init_env_ids = {row[0] for row in init_envs}\\n    final_envs = safe_query(\\n        final_db_path, 'SELECT id, status FROM envelopes WHERE title = ?', (expected_title,))\\n    if not final_envs:\\n        return {'result': 'others'}  # No such envelope\\n    # Look for envelope(s) with this title not present in initial DB\\n    candidate_envs = [row for row in final_envs if row[0] not in init_env_ids]\\n    if len(candidate_envs) != 1:\\n        return {'result': 'others'}  # None or ambiguous/multiple new envelopes\\n    envelope_id = candidate_envs[0][0]\\n    status = candidate_envs[0][1]\\n    # Validate status\\n    if status not in ('Sent', 'Delivered', 'Completed'):\\n        return {'result': 'others'}\\n    # Get basic envelope info\\n    env = safe_query(final_db_path, 'SELECT id, title FROM envelopes WHERE id = ?', (envelope_id,))\\n    if not env or env[0][1] != expected_title:\\n        return {'result': 'others'}\\n    # 2. Check for sent audit event\\n    sent_audit = safe_query(final_db_path, \\\"SELECT 1 FROM audit_events WHERE envelope_id = ? AND event_type = 'sent'\\\", (envelope_id,))\\n    if not sent_audit:\\n        return {'result': 'others'}\\n    # 3. Check envelope documents: must be exactly one, and filename match\\n    env_docs = safe_query(final_db_path, 'SELECT document_id FROM envelope_documents WHERE envelope_id = ?', (envelope_id,))\\n    if len(env_docs) != 1:\\n        return {'result': 'others'}\\n    doc_id = env_docs[0][0]\\n    doc_info = safe_query(final_db_path, 'SELECT filename FROM documents WHERE id = ?', (doc_id,))\\n    if not doc_info or doc_info[0][0] != 'Consulting_SOW_Q2_2026.pdf':\\n        return {'result': 'others'}\\n    # 4. Recipients: must be exactly 2, with precise roles, orders, emails\\n    recips = safe_query(final_db_path, 'SELECT id, role, routing_order, name, email FROM envelope_recipients WHERE envelope_id = ? ORDER BY routing_order, id', (envelope_id,))\\n    if len(recips) != 2:\\n        return {'result': 'others'}\\n    # Define expected recipients\\n    expect_recip = [\\n        {'role': 'Signer', 'routing_order': 1, 'name': 'Carla Diaz', 'email': 'carla.diaz@example.com'},\\n        {'role': 'Approver', 'routing_order': 2, 'name': 'David Kim', 'email': 'david.kim@example.com'}\\n    ]\\n    # Exact match for all assignment fields (role, routing_order, name, email)\\n    for ir, er in zip(recips, expect_recip):\\n        if not (ir[1] == er['role'] and ir[2] == er['routing_order'] and ir[3] == er['name'] and ir[4].lower() == er['email']):\\n            return {'result': 'others'}\\n    # 5. Tab assignments for recipients, must be strict\\n    recips_by_name = {(r[3], r[4].lower()): r[0] for r in recips}\\n    carla_id = recips_by_name.get(('Carla Diaz', 'carla.diaz@example.com'))\\n    david_id = recips_by_name.get(('David Kim', 'david.kim@example.com'))\\n    if carla_id is None or david_id is None:\\n        return {'result': 'others'}\\n    # Tabs for Carla - must have:\\n    carla_tabs = safe_query(final_db_path, 'SELECT tab_type, required, IFNULL(label, \\\"\\\"), IFNULL(anchor_text, \\\"\\\") FROM tabs WHERE envelope_id = ? AND recipient_id = ?', (envelope_id, carla_id))\\n    types_labels = [(t[0], t[1], t[2], t[3]) for t in carla_tabs]\\n    # At least one required signature\\n    if not any(t[0] == 'signature' and t[1] == 1 for t in types_labels):\\n        return {'result': 'others'}\\n    # At least one required date_signed\\n    if not any(t[0] == 'date_signed' and t[1] == 1 for t in types_labels):\\n        return {'result': 'others'}\\n    # At least one required text tab, must match 'Company Name' in label or anchor_text (case-insensitive substring)\\n    found_company_tab = False\\n    for t in types_labels:\\n        if t[0] == 'text' and t[1] == 1:\\n            label, anchor = t[2], t[3]\\n            if re.search(r'company name', label, re.I) or re.search(r'company name', anchor, re.I):\\n                found_company_tab = True\\n                break\\n    if not found_company_tab:\\n        return {'result': 'others'}\\n    # Tabs for David - at least one required checkbox\\n    david_tabs = safe_query(final_db_path, 'SELECT tab_type, required FROM tabs WHERE envelope_id = ? AND recipient_id = ?', (envelope_id, david_id))\\n    if not any(t[0] == 'checkbox' and t[1] == 1 for t in david_tabs):\\n        return {'result': 'others'}\\n    # 6. No extra recipients\\n    recip_cnt = safe_query(final_db_path, 'SELECT COUNT(1) FROM envelope_recipients WHERE envelope_id = ?', (envelope_id,))\\n    if not recip_cnt or recip_cnt[0][0] != 2:\\n        return {'result': 'others'}\\n    # 7. No extra docs\\n    doc_cnt = safe_query(final_db_path, 'SELECT COUNT(1) FROM envelope_documents WHERE envelope_id = ?', (envelope_id,))\\n    if not doc_cnt or doc_cnt[0][0] != 1:\\n        return {'result': 'others'}\\n    # 8. No recipient with sms auth, extra roles, etc\\n    recips_full = safe_query(final_db_path, 'SELECT role, name, email, sms_phone, auth_required FROM envelope_recipients WHERE envelope_id = ?', (envelope_id,))\\n    for r in recips_full:\\n        if r[3] or (r[4] and r[4] != 0):\\n            return {'result': 'others'}\\n    # All checks passed\\n    return {'result': 'complete'}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 2, "task": "For the envelope 'Offer Letter - Jordan Lee', configure recipient authentication so Jordan Lee (Signer, jordan.lee@example.com) must pass SMS verification to +1-415-555-0199, set the envelope to expire in 10 days with automatic reminders every 2 days until completion, and then send it.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta\n\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive DB query\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n\n    # Helper to find envelope id by title\n    def find_envelope_id(db_path: str, title: str) -> int | None:\n        rows = safe_query(db_path, \"SELECT id FROM envelopes WHERE title = ?\", (title,))\n        return rows[0][0] if rows else None\n\n    # Start by checking envelope in final DB\n    title = 'Offer Letter - Jordan Lee'\n    envelope_id = find_envelope_id(final_db_path, title)\n    if envelope_id is None:\n        return {\"result\": \"others\"}\n\n    # Get envelope details in final DB\n    env_rows = safe_query(final_db_path, \"SELECT status, sent_at, expires_at, reminder_enabled, reminder_interval_days FROM envelopes WHERE id = ?\", (envelope_id,))\n    if not env_rows or len(env_rows[0]) < 5:\n        return {\"result\": \"others\"}\n    status, sent_at, expires_at, reminder_enabled, reminder_interval_days = env_rows[0]\n\n    # Must be sent or delivered or completed\n    if status not in ('Sent', 'Delivered', 'Completed'):\n        return {\"result\": \"others\"}\n    # Sent_at must be present\n    if sent_at is None:\n        return {\"result\": \"others\"}\n\n    # Check reminders enabled and interval\n    if reminder_enabled != 1:\n        return {\"result\": \"others\"}\n    if reminder_interval_days != 2:\n        return {\"result\": \"others\"}\n\n    # Check envelope expiry is exactly 10 days from sent_at\n    try:\n        sent_dt = datetime.strptime(sent_at, \"%Y-%m-%d %H:%M:%S\")\n        expires_dt = datetime.strptime(expires_at, \"%Y-%m-%d %H:%M:%S\") if expires_at else None\n    except Exception:\n        return {\"result\": \"others\"}\n    if not expires_dt:\n        return {\"result\": \"others\"}\n    expected_expiry = sent_dt + timedelta(days=10)\n    # Allow up to 2 minutes clock skew\n    if abs(int((expires_dt - expected_expiry).total_seconds())) > 120:\n        return {\"result\": \"others\"}\n\n    # Look for Jordan Lee as signer with SMS auth\n    recip_rows = safe_query(final_db_path, \"SELECT role, name, email, auth_method, auth_required, sms_phone FROM envelope_recipients WHERE envelope_id = ? AND LOWER(email) = ?\", (envelope_id, 'jordan.lee@example.com'))\n    if not recip_rows:\n        return {\"result\": \"others\"}\n    found_jordan = False\n    for role, name, email, auth_method, auth_required, sms_phone in recip_rows:\n        if (\n            role == 'Signer' and\n            name == 'Jordan Lee' and\n            email.lower() == 'jordan.lee@example.com' and\n            auth_method == 'sms' and\n            str(auth_required) == '1' and\n            sms_phone is not None and\n            sms_phone.strip().replace(' ', '') == '+1-415-555-0199'\n        ):\n            found_jordan = True\n            break\n    if not found_jordan:\n        return {\"result\": \"others\"}\n\n    # Was this envelope already present with these settings before agent? If so, cannot count as completion\n    initial_envelope_id = find_envelope_id(initial_db_path, title)\n    if initial_envelope_id:\n        initial_env = safe_query(initial_db_path, \"SELECT status, sent_at, expires_at, reminder_enabled, reminder_interval_days FROM envelopes WHERE id = ?\", (initial_envelope_id,))\n        # If present and already sent with correct config before, then agent did nothing\n        if initial_env:\n            istatus, isent_at, iexp_at, irem_enabled, irem_interval = initial_env[0]\n            if istatus in ('Sent', 'Delivered', 'Completed') and isent_at and iexp_at and irem_enabled == 1 and irem_interval == 2:\n                try:\n                    isent_dt = datetime.strptime(isent_at, \"%Y-%m-%d %H:%M:%S\")\n                    iexp_dt = datetime.strptime(iexp_at, \"%Y-%m-%d %H:%M:%S\")\n                    expected_init_expiry = isent_dt + timedelta(days=10)\n                except Exception:\n                    pass\n                else:\n                    if abs(int((iexp_dt - expected_init_expiry).total_seconds())) <= 120:\n                        # Was already present\n                        initial_recip = safe_query(initial_db_path, \"SELECT role, name, email, auth_method, auth_required, sms_phone FROM envelope_recipients WHERE envelope_id = ? AND LOWER(email) = ?\", (initial_envelope_id, 'jordan.lee@example.com'))\n                        for irole, iname, iemail, iauth_method, iauth_required, isms_phone in initial_recip:\n                            if (\n                                irole == 'Signer' and\n                                iname == 'Jordan Lee' and\n                                iemail.lower() == 'jordan.lee@example.com' and\n                                iauth_method == 'sms' and\n                                str(iauth_required) == '1' and\n                                isms_phone is not None and\n                                isms_phone.strip().replace(' ', '') == '+1-415-555-0199'\n                            ):\n                                # Already present before agent action\n                                return {\"result\": \"others\"}\n\n    # All criteria met, not pre-existing: task complete\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must ensure the envelope 'Offer Letter - Jordan Lee' was configured and sent with ALL these requirements: 1) Jordan Lee (Signer, jordan.lee@example.com) is recipient and must pass SMS verification to +1-415-555-0199; 2) envelope expires in 10 days; 3) automatic reminders every 2 days enabled until completion; 4) envelope has been sent (status 'Sent' or 'Delivered', or 'Completed'); Additional checks: reminders are enabled with 2-day interval, and envelope expiry is 10 days from the sent date. We must compare the initial and final database states, as this is a modification task. If any requirement is not met, or is ambiguous, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Envelope with title 'Offer Letter - Jordan Lee' exists in final DB\",\n        \"Envelope status is 'Sent', 'Delivered', or 'Completed'\",\n        \"Recipient 'Jordan Lee' (role 'Signer', email 'jordan.lee@example.com') exists for this envelope in final DB\",\n        \"Recipient requires SMS authentication (auth_method = 'sms', auth_required = 1, sms_phone = '+1-415-555-0199')\",\n        \"Envelope expires in exactly 10 days from 'sent_at' (expires_at = sent_at + 10 days)\",\n        \"Envelope reminders enabled (reminder_enabled = 1) with interval 2 days (reminder_interval_days = 2)\",\n        \"Envelope's 'sent_at' field is present (must have been sent)\",\n        \"All these changes occurred after initial DB (was not already present before agent actions)\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive DB query\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n\\n    # Helper to find envelope id by title\\n    def find_envelope_id(db_path: str, title: str) -> int | None:\\n        rows = safe_query(db_path, \\\"SELECT id FROM envelopes WHERE title = ?\\\", (title,))\\n        return rows[0][0] if rows else None\\n\\n    # Start by checking envelope in final DB\\n    title = 'Offer Letter - Jordan Lee'\\n    envelope_id = find_envelope_id(final_db_path, title)\\n    if envelope_id is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Get envelope details in final DB\\n    env_rows = safe_query(final_db_path, \\\"SELECT status, sent_at, expires_at, reminder_enabled, reminder_interval_days FROM envelopes WHERE id = ?\\\", (envelope_id,))\\n    if not env_rows or len(env_rows[0]) < 5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    status, sent_at, expires_at, reminder_enabled, reminder_interval_days = env_rows[0]\\n\\n    # Must be sent or delivered or completed\\n    if status not in ('Sent', 'Delivered', 'Completed'):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Sent_at must be present\\n    if sent_at is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check reminders enabled and interval\\n    if reminder_enabled != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if reminder_interval_days != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Check envelope expiry is exactly 10 days from sent_at\\n    try:\\n        sent_dt = datetime.strptime(sent_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        expires_dt = datetime.strptime(expires_at, \\\"%Y-%m-%d %H:%M:%S\\\") if expires_at else None\\n    except Exception:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not expires_dt:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    expected_expiry = sent_dt + timedelta(days=10)\\n    # Allow up to 2 minutes clock skew\\n    if abs(int((expires_dt - expected_expiry).total_seconds())) > 120:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Look for Jordan Lee as signer with SMS auth\\n    recip_rows = safe_query(final_db_path, \\\"SELECT role, name, email, auth_method, auth_required, sms_phone FROM envelope_recipients WHERE envelope_id = ? AND LOWER(email) = ?\\\", (envelope_id, 'jordan.lee@example.com'))\\n    if not recip_rows:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    found_jordan = False\\n    for role, name, email, auth_method, auth_required, sms_phone in recip_rows:\\n        if (\\n            role == 'Signer' and\\n            name == 'Jordan Lee' and\\n            email.lower() == 'jordan.lee@example.com' and\\n            auth_method == 'sms' and\\n            str(auth_required) == '1' and\\n            sms_phone is not None and\\n            sms_phone.strip().replace(' ', '') == '+1-415-555-0199'\\n        ):\\n            found_jordan = True\\n            break\\n    if not found_jordan:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Was this envelope already present with these settings before agent? If so, cannot count as completion\\n    initial_envelope_id = find_envelope_id(initial_db_path, title)\\n    if initial_envelope_id:\\n        initial_env = safe_query(initial_db_path, \\\"SELECT status, sent_at, expires_at, reminder_enabled, reminder_interval_days FROM envelopes WHERE id = ?\\\", (initial_envelope_id,))\\n        # If present and already sent with correct config before, then agent did nothing\\n        if initial_env:\\n            istatus, isent_at, iexp_at, irem_enabled, irem_interval = initial_env[0]\\n            if istatus in ('Sent', 'Delivered', 'Completed') and isent_at and iexp_at and irem_enabled == 1 and irem_interval == 2:\\n                try:\\n                    isent_dt = datetime.strptime(isent_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n                    iexp_dt = datetime.strptime(iexp_at, \\\"%Y-%m-%d %H:%M:%S\\\")\\n                    expected_init_expiry = isent_dt + timedelta(days=10)\\n                except Exception:\\n                    pass\\n                else:\\n                    if abs(int((iexp_dt - expected_init_expiry).total_seconds())) <= 120:\\n                        # Was already present\\n                        initial_recip = safe_query(initial_db_path, \\\"SELECT role, name, email, auth_method, auth_required, sms_phone FROM envelope_recipients WHERE envelope_id = ? AND LOWER(email) = ?\\\", (initial_envelope_id, 'jordan.lee@example.com'))\\n                        for irole, iname, iemail, iauth_method, iauth_required, isms_phone in initial_recip:\\n                            if (\\n                                irole == 'Signer' and\\n                                iname == 'Jordan Lee' and\\n                                iemail.lower() == 'jordan.lee@example.com' and\\n                                iauth_method == 'sms' and\\n                                str(iauth_required) == '1' and\\n                                isms_phone is not None and\\n                                isms_phone.strip().replace(' ', '') == '+1-415-555-0199'\\n                            ):\\n                                # Already present before agent action\\n                                return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All criteria met, not pre-existing: task complete\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 3, "task": "Find the most recent envelope with status 'Delivered' for recipient email 'maria.chen@example.com' and generate a status summary that includes envelopeId, subject, current recipient step, and the timestamps for sent and delivered events from the audit trail.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    import json\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n    \n    # --- Step 1: Identify the most recent 'Delivered' envelope for maria.chen@example.com ---\n    # Find all envelope_recipients for maria.chen@example.com, status 'Delivered'\n    recs = safe_query(\n        final_db_path,\n        \"\"\"\n            SELECT r.envelope_id, r.id, r.routing_order, r.role, r.delivered_at\n            FROM envelope_recipients r\n            JOIN envelopes e ON r.envelope_id = e.id\n            WHERE r.email = ? AND r.status = 'Delivered' AND e.status = 'Delivered'\n        \"\"\",\n        ('maria.chen@example.com',)\n    )\n    if not recs:\n        return {\"result\": \"others\"}\n    # For each, get envelope sent_at for tie-breaking\n    envs = []\n    for envelope_id, rec_id, routing_order, role, delivered_at in recs:\n        sent = safe_query(\n            final_db_path,\n            \"SELECT sent_at, subject FROM envelopes WHERE id = ? AND status = 'Delivered'\",\n            (envelope_id,)\n        )\n        if not sent or sent[0][0] is None:\n            continue\n        sent_at, subject = sent[0]\n        # Find the earliest delivered_at for this recipient on this envelope\n        if not delivered_at:\n            # Fallback: find in audit_events for type 'delivered' with recipientEmail and envelope_id\n            evt = safe_query(final_db_path, \n                \"SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'delivered'\",\n                (envelope_id,)\n            )\n            maria_delivered = None\n            for event_at, details_json in evt:\n                try:\n                    d = json.loads(details_json) if details_json else {}\n                    if d.get('recipientEmail','').lower() == 'maria.chen@example.com':\n                        maria_delivered = event_at\n                except Exception:\n                    continue\n            delivered_at = maria_delivered\n        # Use delivered_at as recency marker; if not, fallback to sent_at\n        envs.append({\n            'envelope_id': envelope_id,\n            'recipient_id': rec_id,\n            'routing_order': routing_order,\n            'role': role,\n            'delivered_at': delivered_at,\n            'sent_at': sent_at,\n            'subject': subject\n        })\n    if not envs:\n        return {\"result\": \"others\"}\n    def sortkey(e):\n        # delivered_at descending, then sent_at descending\n        dt1 = e.get('delivered_at') or ''\n        dt2 = e.get('sent_at') or ''\n        return (dt1, dt2)\n    # Most recent is highest delivered_at then sent_at\n    envs = [e for e in envs if e['delivered_at']]\n    if not envs:\n        return {\"result\": \"others\"}\n    most_recent = sorted(envs, key=sortkey, reverse=True)[0]\n    envelope_id = most_recent['envelope_id']\n    subject = most_recent['subject']\n    recipient_id = most_recent['recipient_id']\n    routing_order = most_recent['routing_order']\n    role = most_recent['role']\n    delivered_at = most_recent['delivered_at']\n    sent_at = most_recent['sent_at']\n    \n    # --- Step 2: Get audit trail sent/delivered timestamps for Maria on this envelope ---\n    # Find the delivered and sent events from audit_events for this envelope AND maria.chen@example.com\n    delivered_evt = safe_query(\n        final_db_path,\n        \"\"\"\n            SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'delivered'\n        \"\"\",\n        (envelope_id,)\n    )\n    delivered_time = None\n    for evt_at, details_json in delivered_evt:\n        try:\n            d = json.loads(details_json) if details_json else {}\n            if d.get('recipientEmail','').lower() == 'maria.chen@example.com':\n                delivered_time = evt_at\n                break\n        except Exception:\n            continue\n    if not delivered_time:\n        # Try backup: get delivered_at from envelope_recipients row\n        delivered_time = delivered_at\n    sent_evt = safe_query(\n        final_db_path,\n        \"SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'sent'\",\n        (envelope_id,)\n    )\n    sent_time = None\n    for evt_at, details_json in sent_evt:\n        # If no recipient in details, accept as overall envelope sent\n        try:\n            d = json.loads(details_json) if details_json else {}\n            rmail = d.get('recipientEmail', None)\n            if not rmail or rmail.lower() == 'maria.chen@example.com':\n                sent_time = evt_at\n                break\n        except Exception:\n            continue\n    # Fallback: use envelope.sent_at\n    if not sent_time:\n        sent_time = sent_at\n    \n    # --- Step 3: Determine 'current recipient step' ---\n    # Step = routing_order or (e.g., \"Signer (Step 1)\")\n    current_step = f\"{role} (Step {routing_order})\"\n    \n    # --- Step 4: Parse answer and extract values ---\n    # Accept numbers, strings, and timestamps, various formatting\n    # Look for envelope id\n    env_pat = re.compile(r\"envelope.?id.?[:=]?\\s*(\\d+)\", re.IGNORECASE)\n    subj_pat = re.compile(r\"subject.?[:=]?\\s*([\\w\\-: ().',]+)\", re.IGNORECASE)\n    step_pat = re.compile(r\"current recipient step.?[:=]?\\s*([\\w \\-()]+)\", re.IGNORECASE)\n    sent_pat = re.compile(r\"sent (at|time|date)?[:=]?\\s*([\\d]{4}-[\\d]{2}-[\\d]{2} [\\d]{2}:[\\d]{2}:[\\d]{2})\", re.IGNORECASE)\n    deliv_pat = re.compile(r\"delivered (at|time|date)?[:=]?\\s*([\\d]{4}-[\\d]{2}-[\\d]{2} [\\d]{2}:[\\d]{2}:[\\d]{2})\", re.IGNORECASE)\n    # Parse all\n    envelope_id_ans = None\n    subject_ans = None\n    step_ans = None\n    sent_ans = None\n    delivered_ans = None\n    m = env_pat.search(final_answer)\n    if m:\n        envelope_id_ans = m.group(1)\n    sm = subj_pat.search(final_answer)\n    if sm:\n        # May contain ending punctuation, trim\n        s = sm.group(1).strip().rstrip('.:;,')\n        subject_ans = s\n    stp = step_pat.search(final_answer)\n    if stp:\n        sp = stp.group(1).strip().rstrip('.:;,')\n        step_ans = sp\n    sentm = sent_pat.search(final_answer)\n    if sentm:\n        sent_ans = sentm.group(2)\n    delm = deliv_pat.search(final_answer)\n    if delm:\n        delivered_ans = delm.group(2)\n    # Defensive: if any required field missing, try looser patterns\n    if not envelope_id_ans:\n        m_alt = re.search(r\"\\b(Envelope Id|EnvelopeID|ID)\\b.?[:=]?\\s*(\\d+)\", final_answer, re.IGNORECASE)\n        if m_alt:\n            envelope_id_ans = m_alt.group(2)\n    if not subject_ans:\n        m_alt = re.search(r\"Subject.?[:=]?\\s*([\\w\\-: ().',]+)\", final_answer, re.IGNORECASE)\n        if m_alt:\n            subject_ans = m_alt.group(1).strip().rstrip('.:;,')\n    if not step_ans:\n        m_alt = re.search(r\"Step\\s*:?\\s*([\\w \\-()]+)\", final_answer, re.IGNORECASE)\n        if m_alt:\n            step_ans = m_alt.group(1).strip().rstrip('.:;,')\n    if not sent_ans:\n        m_alt = re.search(r\"Sent.?[:=]?\\s*([\\d]{4}-[\\d]{2}-[\\d]{2} [\\d]{2}:[\\d]{2}:[\\d]{2})\", final_answer, re.IGNORECASE)\n        if m_alt:\n            sent_ans = m_alt.group(1)\n    if not delivered_ans:\n        m_alt = re.search(r\"Delivered.?[:=]?\\s*([\\d]{4}-[\\d]{2}-[\\d]{2} [\\d]{2}:[\\d]{2}:[\\d]{2})\", final_answer, re.IGNORECASE)\n        if m_alt:\n            delivered_ans = m_alt.group(1)\n    # All required\n    checks = [envelope_id_ans, subject_ans, step_ans, sent_ans, delivered_ans]\n    if not all(checks):\n        return {\"result\": \"others\"}\n    # Envelope id must match\n    if str(envelope_id) != str(envelope_id_ans):\n        return {\"result\": \"others\"}\n    # Subject strict match except for minor whitespace\n    def norm(x):\n        return x.strip().replace('  ',' ')\n    if norm(subject) != norm(subject_ans):\n        return {\"result\": \"others\"}\n    # Step as above\n    if norm(current_step.lower()) != norm(step_ans.lower()):\n        return {\"result\": \"others\"}\n    # Timestamps must match\n    # Allow only as exact strings\n    if str(sent_time) != str(sent_ans):\n        return {\"result\": \"others\"}\n    if str(delivered_time) != str(delivered_ans):\n        return {\"result\": \"others\"}\n    # Only if all match\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, the agent must find the most recent envelope (by sent/delivered time) whose status is 'Delivered' for recipient email 'maria.chen@example.com'. From the correct envelope, the agent must generate a status summary including: envelopeId, subject, current recipient step, and audit trail timestamps for the 'sent' and 'delivered' events. The answer must exactly match the database contents for these fields, with correct mapping of envelope and recipient details. The verification is entirely query-based: no database modifications are required, and only if the answer fully and exactly reflects the real most recent matching envelope should 'complete' be returned.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Find all envelopes where status = 'Delivered' and where a recipient with email 'maria.chen@example.com' exists\",\n        \"Of these, select the most recent one, prioritizing delivered_at/audit_event time (tie-breaker sent_at)\",\n        \"Extract envelopeId, subject, and determine the 'current recipient step'the delivery step (e.g., routing_order/role of the recipient for Maria Chen)\",\n        \"Extract the audit_events for this envelope with event_type 'sent' and 'delivered' for Maria (by matching details_json 'recipientEmail' or recipient_id)\",\n        \"Extract timestamps for these events\",\n        \"Parse the final_answer, extract all required values (envelopeId, subject, recipient step/role, timestamps)\",\n        \"Check that all values from the answer match precisely with the data from the database; no more, no less, and can account for reasonable formatting (e.g., whitespace, ordering)\",\n        \"Handle missing/malformed answer, and ensure there is no ambiguity in envelope selection; return 'others' if any uncertainty\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    import json\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # --- Step 1: Identify the most recent 'Delivered' envelope for maria.chen@example.com ---\\n    # Find all envelope_recipients for maria.chen@example.com, status 'Delivered'\\n    recs = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n            SELECT r.envelope_id, r.id, r.routing_order, r.role, r.delivered_at\\n            FROM envelope_recipients r\\n            JOIN envelopes e ON r.envelope_id = e.id\\n            WHERE r.email = ? AND r.status = 'Delivered' AND e.status = 'Delivered'\\n        \\\"\\\"\\\",\\n        ('maria.chen@example.com',)\\n    )\\n    if not recs:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # For each, get envelope sent_at for tie-breaking\\n    envs = []\\n    for envelope_id, rec_id, routing_order, role, delivered_at in recs:\\n        sent = safe_query(\\n            final_db_path,\\n            \\\"SELECT sent_at, subject FROM envelopes WHERE id = ? AND status = 'Delivered'\\\",\\n            (envelope_id,)\\n        )\\n        if not sent or sent[0][0] is None:\\n            continue\\n        sent_at, subject = sent[0]\\n        # Find the earliest delivered_at for this recipient on this envelope\\n        if not delivered_at:\\n            # Fallback: find in audit_events for type 'delivered' with recipientEmail and envelope_id\\n            evt = safe_query(final_db_path, \\n                \\\"SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'delivered'\\\",\\n                (envelope_id,)\\n            )\\n            maria_delivered = None\\n            for event_at, details_json in evt:\\n                try:\\n                    d = json.loads(details_json) if details_json else {}\\n                    if d.get('recipientEmail','').lower() == 'maria.chen@example.com':\\n                        maria_delivered = event_at\\n                except Exception:\\n                    continue\\n            delivered_at = maria_delivered\\n        # Use delivered_at as recency marker; if not, fallback to sent_at\\n        envs.append({\\n            'envelope_id': envelope_id,\\n            'recipient_id': rec_id,\\n            'routing_order': routing_order,\\n            'role': role,\\n            'delivered_at': delivered_at,\\n            'sent_at': sent_at,\\n            'subject': subject\\n        })\\n    if not envs:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    def sortkey(e):\\n        # delivered_at descending, then sent_at descending\\n        dt1 = e.get('delivered_at') or ''\\n        dt2 = e.get('sent_at') or ''\\n        return (dt1, dt2)\\n    # Most recent is highest delivered_at then sent_at\\n    envs = [e for e in envs if e['delivered_at']]\\n    if not envs:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    most_recent = sorted(envs, key=sortkey, reverse=True)[0]\\n    envelope_id = most_recent['envelope_id']\\n    subject = most_recent['subject']\\n    recipient_id = most_recent['recipient_id']\\n    routing_order = most_recent['routing_order']\\n    role = most_recent['role']\\n    delivered_at = most_recent['delivered_at']\\n    sent_at = most_recent['sent_at']\\n    \\n    # --- Step 2: Get audit trail sent/delivered timestamps for Maria on this envelope ---\\n    # Find the delivered and sent events from audit_events for this envelope AND maria.chen@example.com\\n    delivered_evt = safe_query(\\n        final_db_path,\\n        \\\"\\\"\\\"\\n            SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'delivered'\\n        \\\"\\\"\\\",\\n        (envelope_id,)\\n    )\\n    delivered_time = None\\n    for evt_at, details_json in delivered_evt:\\n        try:\\n            d = json.loads(details_json) if details_json else {}\\n            if d.get('recipientEmail','').lower() == 'maria.chen@example.com':\\n                delivered_time = evt_at\\n                break\\n        except Exception:\\n            continue\\n    if not delivered_time:\\n        # Try backup: get delivered_at from envelope_recipients row\\n        delivered_time = delivered_at\\n    sent_evt = safe_query(\\n        final_db_path,\\n        \\\"SELECT event_at, details_json FROM audit_events WHERE envelope_id = ? AND event_type = 'sent'\\\",\\n        (envelope_id,)\\n    )\\n    sent_time = None\\n    for evt_at, details_json in sent_evt:\\n        # If no recipient in details, accept as overall envelope sent\\n        try:\\n            d = json.loads(details_json) if details_json else {}\\n            rmail = d.get('recipientEmail', None)\\n            if not rmail or rmail.lower() == 'maria.chen@example.com':\\n                sent_time = evt_at\\n                break\\n        except Exception:\\n            continue\\n    # Fallback: use envelope.sent_at\\n    if not sent_time:\\n        sent_time = sent_at\\n    \\n    # --- Step 3: Determine 'current recipient step' ---\\n    # Step = routing_order or (e.g., \\\"Signer (Step 1)\\\")\\n    current_step = f\\\"{role} (Step {routing_order})\\\"\\n    \\n    # --- Step 4: Parse answer and extract values ---\\n    # Accept numbers, strings, and timestamps, various formatting\\n    # Look for envelope id\\n    env_pat = re.compile(r\\\"envelope.?id.?[:=]?\\\\s*(\\\\d+)\\\", re.IGNORECASE)\\n    subj_pat = re.compile(r\\\"subject.?[:=]?\\\\s*([\\\\w\\\\-: ().',]+)\\\", re.IGNORECASE)\\n    step_pat = re.compile(r\\\"current recipient step.?[:=]?\\\\s*([\\\\w \\\\-()]+)\\\", re.IGNORECASE)\\n    sent_pat = re.compile(r\\\"sent (at|time|date)?[:=]?\\\\s*([\\\\d]{4}-[\\\\d]{2}-[\\\\d]{2} [\\\\d]{2}:[\\\\d]{2}:[\\\\d]{2})\\\", re.IGNORECASE)\\n    deliv_pat = re.compile(r\\\"delivered (at|time|date)?[:=]?\\\\s*([\\\\d]{4}-[\\\\d]{2}-[\\\\d]{2} [\\\\d]{2}:[\\\\d]{2}:[\\\\d]{2})\\\", re.IGNORECASE)\\n    # Parse all\\n    envelope_id_ans = None\\n    subject_ans = None\\n    step_ans = None\\n    sent_ans = None\\n    delivered_ans = None\\n    m = env_pat.search(final_answer)\\n    if m:\\n        envelope_id_ans = m.group(1)\\n    sm = subj_pat.search(final_answer)\\n    if sm:\\n        # May contain ending punctuation, trim\\n        s = sm.group(1).strip().rstrip('.:;,')\\n        subject_ans = s\\n    stp = step_pat.search(final_answer)\\n    if stp:\\n        sp = stp.group(1).strip().rstrip('.:;,')\\n        step_ans = sp\\n    sentm = sent_pat.search(final_answer)\\n    if sentm:\\n        sent_ans = sentm.group(2)\\n    delm = deliv_pat.search(final_answer)\\n    if delm:\\n        delivered_ans = delm.group(2)\\n    # Defensive: if any required field missing, try looser patterns\\n    if not envelope_id_ans:\\n        m_alt = re.search(r\\\"\\\\b(Envelope Id|EnvelopeID|ID)\\\\b.?[:=]?\\\\s*(\\\\d+)\\\", final_answer, re.IGNORECASE)\\n        if m_alt:\\n            envelope_id_ans = m_alt.group(2)\\n    if not subject_ans:\\n        m_alt = re.search(r\\\"Subject.?[:=]?\\\\s*([\\\\w\\\\-: ().',]+)\\\", final_answer, re.IGNORECASE)\\n        if m_alt:\\n            subject_ans = m_alt.group(1).strip().rstrip('.:;,')\\n    if not step_ans:\\n        m_alt = re.search(r\\\"Step\\\\s*:?\\\\s*([\\\\w \\\\-()]+)\\\", final_answer, re.IGNORECASE)\\n        if m_alt:\\n            step_ans = m_alt.group(1).strip().rstrip('.:;,')\\n    if not sent_ans:\\n        m_alt = re.search(r\\\"Sent.?[:=]?\\\\s*([\\\\d]{4}-[\\\\d]{2}-[\\\\d]{2} [\\\\d]{2}:[\\\\d]{2}:[\\\\d]{2})\\\", final_answer, re.IGNORECASE)\\n        if m_alt:\\n            sent_ans = m_alt.group(1)\\n    if not delivered_ans:\\n        m_alt = re.search(r\\\"Delivered.?[:=]?\\\\s*([\\\\d]{4}-[\\\\d]{2}-[\\\\d]{2} [\\\\d]{2}:[\\\\d]{2}:[\\\\d]{2})\\\", final_answer, re.IGNORECASE)\\n        if m_alt:\\n            delivered_ans = m_alt.group(1)\\n    # All required\\n    checks = [envelope_id_ans, subject_ans, step_ans, sent_ans, delivered_ans]\\n    if not all(checks):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Envelope id must match\\n    if str(envelope_id) != str(envelope_id_ans):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Subject strict match except for minor whitespace\\n    def norm(x):\\n        return x.strip().replace('  ',' ')\\n    if norm(subject) != norm(subject_ans):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Step as above\\n    if norm(current_step.lower()) != norm(step_ans.lower()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Timestamps must match\\n    # Allow only as exact strings\\n    if str(sent_time) != str(sent_ans):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if str(delivered_time) != str(delivered_ans):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Only if all match\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 4, "task": "Void the envelope titled 'Contract Renewal - 2025 - Redwood' that is currently in status 'Sent' and set the void reason to 'Customer requested revised pricing; canceling current draft.'", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    VOID_REASON = \"Customer requested revised pricing; canceling current draft.\"\n    ENVELOPE_TITLE = \"Contract Renewal - 2025 - Redwood\"\n\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            result = cursor.fetchall()\n            conn.close()\n            return result\n        except Exception:\n            return []\n\n    # Step 1: Find the matching envelope in initial DB\n    envs_init = safe_query(\n        initial_db_path,\n        \"\"\"\n        SELECT id, status FROM envelopes WHERE title = ?\n        \"\"\",\n        (ENVELOPE_TITLE,)\n    )\n    if not envs_init:\n        return {\"result\": \"others\"}\n    # Of all envelopes with that title, get those in Sent status\n    env_ids_in_sent = [row[0] for row in envs_init if (row[1] == \"Sent\")]\n    if len(env_ids_in_sent) != 1:\n        # The problem expects exactly one envelope in 'Sent' status with that title\n        return {\"result\": \"others\"}\n    env_id = env_ids_in_sent[0]\n\n    # Sanity check: ensure this envelope exists in final DB\n    envs_final = safe_query(\n        final_db_path,\n        \"SELECT id, status, void_reason, voided_at, title FROM envelopes WHERE id = ?\",\n        (env_id,)\n    )\n    if not envs_final or len(envs_final) != 1:\n        return {\"result\": \"others\"}\n    final_status, final_void_reason, final_voided_at, final_title = envs_final[0][1], envs_final[0][2], envs_final[0][3], envs_final[0][4]\n\n    # Step 2: Confirm requirements on the target envelope\n    if final_title != ENVELOPE_TITLE:\n        return {\"result\": \"others\"}\n    if final_status != \"Voided\":\n        return {\"result\": \"others\"}\n    if final_void_reason is None or final_void_reason.strip() != VOID_REASON:\n        return {\"result\": \"others\"}\n    if final_voided_at is None:\n        return {\"result\": \"others\"}\n\n    # Step 3: No extra envelopes with that title are voided\n    # (Should only be this one, no duplicate voidings)\n    envs_final_all = safe_query(\n        final_db_path,\n        \"SELECT id, status FROM envelopes WHERE title = ?\",\n        (ENVELOPE_TITLE,)\n    )\n    voided_ids = [row[0] for row in envs_final_all if row[1] == \"Voided\"]\n    if any(row[0] != env_id and row[1] == \"Voided\" for row in envs_final_all):\n        return {\"result\": \"others\"}\n\n    # Step 4: Check for audit log for void\n    audit_events = safe_query(\n        final_db_path,\n        \"SELECT event_type, details_json FROM audit_events WHERE envelope_id = ? ORDER BY event_at DESC\",\n        (env_id,)\n    )\n    found_voided = False\n    for etype, details_json in audit_events:\n        if etype == \"voided\":\n            # If details_json exists and is a string, check for the reason, but do not require JSON decoding (defensive)\n            if details_json is not None and VOID_REASON not in details_json:\n                continue  # wrong reason, skip\n            found_voided = True\n            break\n    if not found_voided:\n        return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the agent voided the envelope titled 'Contract Renewal - 2025 - Redwood' in 'Sent' status and set the void reason to the specified text, we must: (1) Identify the envelope by title and status 'Sent' in the initial state; (2) Ensure this same envelope has status='Voided' in the final state; (3) The void_reason field for this envelope must exactly match 'Customer requested revised pricing; canceling current draft.' in the final state; (4) voided_at must be non-NULL in the final state; (5) There must be a matching audit_events record for the envelope with event_type='voided' and details_json including the correct reason (if present); (6) No other envelopes or titles are affected by this void operation. The task is modification_based since it only concerns the database state change.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify envelope in initial DB with title='Contract Renewal - 2025 - Redwood' and status='Sent'.\",\n        \"In final DB, ensure this envelope has status='Voided', correct void_reason, and non-NULL voided_at.\",\n        \"No other envelope with this title is voided unless it is the same one.\",\n        \"In final DB, check an audit_events entry for this envelope with event_type='voided' (optionally reason in details_json).\",\n        \"No other unexpected changes to envelope title or unrelated voids.\",\n        \"Gracefully handle missing or malformed data.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    VOID_REASON = \\\"Customer requested revised pricing; canceling current draft.\\\"\\n    ENVELOPE_TITLE = \\\"Contract Renewal - 2025 - Redwood\\\"\\n\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            result = cursor.fetchall()\\n            conn.close()\\n            return result\\n        except Exception:\\n            return []\\n\\n    # Step 1: Find the matching envelope in initial DB\\n    envs_init = safe_query(\\n        initial_db_path,\\n        \\\"\\\"\\\"\\n        SELECT id, status FROM envelopes WHERE title = ?\\n        \\\"\\\"\\\",\\n        (ENVELOPE_TITLE,)\\n    )\\n    if not envs_init:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Of all envelopes with that title, get those in Sent status\\n    env_ids_in_sent = [row[0] for row in envs_init if (row[1] == \\\"Sent\\\")]\\n    if len(env_ids_in_sent) != 1:\\n        # The problem expects exactly one envelope in 'Sent' status with that title\\n        return {\\\"result\\\": \\\"others\\\"}\\n    env_id = env_ids_in_sent[0]\\n\\n    # Sanity check: ensure this envelope exists in final DB\\n    envs_final = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, status, void_reason, voided_at, title FROM envelopes WHERE id = ?\\\",\\n        (env_id,)\\n    )\\n    if not envs_final or len(envs_final) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    final_status, final_void_reason, final_voided_at, final_title = envs_final[0][1], envs_final[0][2], envs_final[0][3], envs_final[0][4]\\n\\n    # Step 2: Confirm requirements on the target envelope\\n    if final_title != ENVELOPE_TITLE:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if final_status != \\\"Voided\\\":\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if final_void_reason is None or final_void_reason.strip() != VOID_REASON:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if final_voided_at is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 3: No extra envelopes with that title are voided\\n    # (Should only be this one, no duplicate voidings)\\n    envs_final_all = safe_query(\\n        final_db_path,\\n        \\\"SELECT id, status FROM envelopes WHERE title = ?\\\",\\n        (ENVELOPE_TITLE,)\\n    )\\n    voided_ids = [row[0] for row in envs_final_all if row[1] == \\\"Voided\\\"]\\n    if any(row[0] != env_id and row[1] == \\\"Voided\\\" for row in envs_final_all):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 4: Check for audit log for void\\n    audit_events = safe_query(\\n        final_db_path,\\n        \\\"SELECT event_type, details_json FROM audit_events WHERE envelope_id = ? ORDER BY event_at DESC\\\",\\n        (env_id,)\\n    )\\n    found_voided = False\\n    for etype, details_json in audit_events:\\n        if etype == \\\"voided\\\":\\n            # If details_json exists and is a string, check for the reason, but do not require JSON decoding (defensive)\\n            if details_json is not None and VOID_REASON not in details_json:\\n                continue  # wrong reason, skip\\n            found_voided = True\\n            break\\n    if not found_voided:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 5, "task": "Create a reusable field (tab) named 'Client Legal Name' as a required text input with max length 80 and default value '' and add it to the 'MSA v5' template at anchor text '/CLIENT_LEGAL_NAME/' with offsetX 10 and offsetY 0.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive DB read\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # --- Step 1: Check reusable_tab in final_db ---\n    reusable_tab_q = (\n        \"SELECT id, owner_user_id FROM reusable_tabs \"\n        \"WHERE name=? AND tab_type='text' AND required=1 AND max_length=80 AND default_value=''\"\n    )\n    rt_rows = safe_query(final_db_path, reusable_tab_q, (\"Client Legal Name\",))\n    if len(rt_rows) != 1:\n        # Must exist and must not be ambiguous (no duplicates)\n        return {\"result\": \"others\"}\n    reusable_tab_id, owner_user_id = rt_rows[0]\n    # Defensive: make sure it's not a spurious duplicate entry\n\n    # --- Step 2: This reusable tab did NOT exist in initial_db in same form ---\n    rt_init = safe_query(initial_db_path, reusable_tab_q, (\"Client Legal Name\",))\n    if len(rt_init) != 0:\n        # If existed with exact config before, not created now\n        return {\"result\": \"others\"}\n\n    # --- Step 3: Find 'MSA v5' template id (should be 2, but never assume) ---\n    msa_tmpl_q = \"SELECT id FROM templates WHERE name=?\"\n    tmpl_rows = safe_query(final_db_path, msa_tmpl_q, (\"MSA v5\",))\n    if len(tmpl_rows) != 1:\n        return {\"result\": \"others\"}\n    msa_template_id = tmpl_rows[0][0]\n\n    # --- Step 4: Look for template_tab linking this reusable_tab to MSA v5 ---\n    tab_q = (\n        \"SELECT id, role_id, document_id FROM template_tabs \"\n        \"WHERE template_id=? AND reusable_tab_id=? AND tab_type='text' AND label=? \"\n        \"AND required=1 AND anchor_text=? AND anchor_offset_x=10 AND anchor_offset_y=0 \"\n        \"AND max_length=80 AND (default_value IS NULL OR default_value='')\"\n    )\n    tab_rows = safe_query(final_db_path, tab_q, (msa_template_id, reusable_tab_id, \"Client Legal Name\", '/CLIENT_LEGAL_NAME/'))\n    # The field must be present. Allow default_value to be NULL or empty, as some DBs write empty string as NULL.\n    if len(tab_rows) != 1:\n        return {\"result\": \"others\"}\n\n    found_tab_id, role_id, document_id = tab_rows[0]\n    # Defensive: check it's actually for a real role in the template\n    role_rows = safe_query(final_db_path, \"SELECT id FROM template_roles WHERE id=? AND template_id=?\", (role_id, msa_template_id))\n    if len(role_rows) != 1:\n        return {\"result\": \"others\"}\n\n    # --- Step 5: Ensure this template_tab did NOT already exist in initial_db ---\n    tab_init_rows = safe_query(initial_db_path, tab_q, (msa_template_id, reusable_tab_id, \"Client Legal Name\", '/CLIENT_LEGAL_NAME/'))\n    if len(tab_init_rows) != 0:\n        return {\"result\": \"others\"}\n\n    # All conditions satisfied\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify the task, we must ensure that the agent: (1) Created a reusable tab (field) named 'Client Legal Name' as a required text input with max length 80 and default value ''. (2) Made this tab reusable (i.e., it exists in reusable_tabs, not only on a single template). (3) Added this field to the 'MSA v5' template (which is template_id=2) at anchor text '/CLIENT_LEGAL_NAME/' with anchor_offset_x=10 and anchor_offset_y=0. (4) The new template_tab record for 'Client Legal Name' must reference the correct reusable tab (by id), be required, be of type 'text', have the correct max_length and default value, and be attached to a role for the 'MSA v5' template. (5) These changes must be present in final_db and not already exist in initial_db (i.e., the reusable tab or linkage must have been added as a result of the agent). Only if ALL these criteria are matched with no ambiguity do we return complete.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Verify a reusable tab named 'Client Legal Name' exists in final_db, required=1, tab_type='text', max_length=80, default_value=''\",\n        \"Ensure the reusable tab above did not exist in initial_db with these exact specs (if it did, the agent did not create it during this run -- that's an error/uncertainty)\",\n        \"Verify a template_tab exists in final_db for template_id=2 (MSA v5) which references the correct reusable_tab_id, tab_type='text', label='Client Legal Name', required=1, anchor_text='/CLIENT_LEGAL_NAME/', anchor_offset_x=10, anchor_offset_y=0, max_length=80, default_value=''\",\n        \"Ensure this template_tab record did not exist in initial_db with those exact properties\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive DB read\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # --- Step 1: Check reusable_tab in final_db ---\\n    reusable_tab_q = (\\n        \\\"SELECT id, owner_user_id FROM reusable_tabs \\\"\\n        \\\"WHERE name=? AND tab_type='text' AND required=1 AND max_length=80 AND default_value=''\\\"\\n    )\\n    rt_rows = safe_query(final_db_path, reusable_tab_q, (\\\"Client Legal Name\\\",))\\n    if len(rt_rows) != 1:\\n        # Must exist and must not be ambiguous (no duplicates)\\n        return {\\\"result\\\": \\\"others\\\"}\\n    reusable_tab_id, owner_user_id = rt_rows[0]\\n    # Defensive: make sure it's not a spurious duplicate entry\\n\\n    # --- Step 2: This reusable tab did NOT exist in initial_db in same form ---\\n    rt_init = safe_query(initial_db_path, reusable_tab_q, (\\\"Client Legal Name\\\",))\\n    if len(rt_init) != 0:\\n        # If existed with exact config before, not created now\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- Step 3: Find 'MSA v5' template id (should be 2, but never assume) ---\\n    msa_tmpl_q = \\\"SELECT id FROM templates WHERE name=?\\\"\\n    tmpl_rows = safe_query(final_db_path, msa_tmpl_q, (\\\"MSA v5\\\",))\\n    if len(tmpl_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    msa_template_id = tmpl_rows[0][0]\\n\\n    # --- Step 4: Look for template_tab linking this reusable_tab to MSA v5 ---\\n    tab_q = (\\n        \\\"SELECT id, role_id, document_id FROM template_tabs \\\"\\n        \\\"WHERE template_id=? AND reusable_tab_id=? AND tab_type='text' AND label=? \\\"\\n        \\\"AND required=1 AND anchor_text=? AND anchor_offset_x=10 AND anchor_offset_y=0 \\\"\\n        \\\"AND max_length=80 AND (default_value IS NULL OR default_value='')\\\"\\n    )\\n    tab_rows = safe_query(final_db_path, tab_q, (msa_template_id, reusable_tab_id, \\\"Client Legal Name\\\", '/CLIENT_LEGAL_NAME/'))\\n    # The field must be present. Allow default_value to be NULL or empty, as some DBs write empty string as NULL.\\n    if len(tab_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    found_tab_id, role_id, document_id = tab_rows[0]\\n    # Defensive: check it's actually for a real role in the template\\n    role_rows = safe_query(final_db_path, \\\"SELECT id FROM template_roles WHERE id=? AND template_id=?\\\", (role_id, msa_template_id))\\n    if len(role_rows) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # --- Step 5: Ensure this template_tab did NOT already exist in initial_db ---\\n    tab_init_rows = safe_query(initial_db_path, tab_q, (msa_template_id, reusable_tab_id, \\\"Client Legal Name\\\", '/CLIENT_LEGAL_NAME/'))\\n    if len(tab_init_rows) != 0:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All conditions satisfied\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 6, "task": "Update the template 'Sales Order Form' so it includes a checkbox group named 'Optional Add-ons' with options 'Premium Support' and 'Onsite Training', both unchecked by default, and assign the group to the role 'Customer Signer'.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            res = cur.fetchall()\n            conn.close()\n            return res\n        except Exception:\n            return []\n    \n    # Step 1: Get template_id for 'Sales Order Form'\n    template_rows = safe_query(final_db_path, \"SELECT id FROM templates WHERE name = ?\", ('Sales Order Form',))\n    if not template_rows or len(template_rows[0]) != 1:\n        return {\"result\": \"others\"}\n    template_id = template_rows[0][0]\n\n    # Step 2: Get role_id for 'Customer Signer' in that template\n    role_rows = safe_query(final_db_path, \"SELECT id FROM template_roles WHERE template_id = ? AND role_name = ?\", (template_id, 'Customer Signer'))\n    if not role_rows or len(role_rows[0]) != 1:\n        return {\"result\": \"others\"}\n    role_id = role_rows[0][0]\n\n    # Step 3: Confirm template_tab_group 'Optional Add-ons'\n    group_rows = safe_query(final_db_path, \"SELECT id FROM template_tab_groups WHERE template_id = ? AND role_id = ? AND name = ? AND group_type = 'checkbox_group'\", (template_id, role_id, 'Optional Add-ons'))\n    if not group_rows or len(group_rows[0]) != 1:\n        return {\"result\": \"others\"}\n    group_id = group_rows[0][0]\n\n    # Step 4: There must be two checkboxes in template_tabs assigned to this group and role, with exact labels\n    checkbox_labels = ['Premium Support', 'Onsite Training']\n    boxes = []\n    # Fetch all checkboxes in the group for this template and role\n    tabs = safe_query(final_db_path, \n        \"SELECT label, checked, tab_type, group_id, role_id FROM template_tabs WHERE template_id = ? AND role_id = ? AND group_id = ? \",\n        (template_id, role_id, group_id))\n    for t in tabs:\n        label, checked, tab_type, gid, r_id = t\n        if label in checkbox_labels and tab_type == 'checkbox' and checked == 0 and gid == group_id and r_id == role_id:\n            boxes.append(label)\n    # There must be exactly two such, one for each label, and nothing missing\n    if sorted(boxes) != sorted(checkbox_labels):\n        return {\"result\": \"others\"}\n    # Check that there are no extraneous checkboxes in the group\n    tabs_all = safe_query(final_db_path, \n        \"SELECT label, tab_type FROM template_tabs WHERE template_id = ? AND role_id = ? AND group_id = ?\",\n        (template_id, role_id, group_id))\n    for label, tab_type in tabs_all:\n        if tab_type == 'checkbox' and label not in checkbox_labels:\n            return {\"result\": \"others\"}\n    # Check for partial creation previously (should not exist in initial_db)\n    initial_group = safe_query(initial_db_path, \"SELECT id FROM template_tab_groups WHERE template_id = ? AND role_id = ? AND name = ?\", (template_id, role_id, 'Optional Add-ons'))\n    if initial_group:\n        return {\"result\": \"others\"}\n    for lbl in checkbox_labels:\n        initial_boxes = safe_query(initial_db_path, \n            \"SELECT id FROM template_tabs WHERE template_id = ? AND role_id = ? AND label = ?\", (template_id, role_id, lbl))\n        if initial_boxes:\n            return {\"result\": \"others\"}\n    # All checks passed deterministically\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the agent completed the task, we must check that in the final database, the template named 'Sales Order Form' (template_id=3) has (1) a checkbox group named 'Optional Add-ons' of group_type 'checkbox_group', (2) assigned to the role 'Customer Signer', (3) containing options (checkboxes) 'Premium Support' and 'Onsite Training', (4) that both checkboxes are unchecked by default, and (5) that all are properly linked -- the checkboxes belong to the group and role as required. The initial database does not contain this group or these checkboxes for this template, so we must verify these are new, correct additions and not partial or malformed. No information from agent text response is required.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find template_id for 'Sales Order Form'\",\n        \"Find role_id for 'Customer Signer' within that template\",\n        \"There must be a 'checkbox_group' in template_tab_groups with name 'Optional Add-ons', assigned to template_id and role_id\",\n        \"There must be two checkboxes in template_tabs for that template and role, both labeled exactly 'Premium Support' and 'Onsite Training', each with tab_type='checkbox', checked=0 (unchecked), and both related to the above group\",\n        \"No extra or missing group/checkboxes; integrity\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            res = cur.fetchall()\\n            conn.close()\\n            return res\\n        except Exception:\\n            return []\\n    \\n    # Step 1: Get template_id for 'Sales Order Form'\\n    template_rows = safe_query(final_db_path, \\\"SELECT id FROM templates WHERE name = ?\\\", ('Sales Order Form',))\\n    if not template_rows or len(template_rows[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    template_id = template_rows[0][0]\\n\\n    # Step 2: Get role_id for 'Customer Signer' in that template\\n    role_rows = safe_query(final_db_path, \\\"SELECT id FROM template_roles WHERE template_id = ? AND role_name = ?\\\", (template_id, 'Customer Signer'))\\n    if not role_rows or len(role_rows[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    role_id = role_rows[0][0]\\n\\n    # Step 3: Confirm template_tab_group 'Optional Add-ons'\\n    group_rows = safe_query(final_db_path, \\\"SELECT id FROM template_tab_groups WHERE template_id = ? AND role_id = ? AND name = ? AND group_type = 'checkbox_group'\\\", (template_id, role_id, 'Optional Add-ons'))\\n    if not group_rows or len(group_rows[0]) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    group_id = group_rows[0][0]\\n\\n    # Step 4: There must be two checkboxes in template_tabs assigned to this group and role, with exact labels\\n    checkbox_labels = ['Premium Support', 'Onsite Training']\\n    boxes = []\\n    # Fetch all checkboxes in the group for this template and role\\n    tabs = safe_query(final_db_path, \\n        \\\"SELECT label, checked, tab_type, group_id, role_id FROM template_tabs WHERE template_id = ? AND role_id = ? AND group_id = ? \\\",\\n        (template_id, role_id, group_id))\\n    for t in tabs:\\n        label, checked, tab_type, gid, r_id = t\\n        if label in checkbox_labels and tab_type == 'checkbox' and checked == 0 and gid == group_id and r_id == role_id:\\n            boxes.append(label)\\n    # There must be exactly two such, one for each label, and nothing missing\\n    if sorted(boxes) != sorted(checkbox_labels):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check that there are no extraneous checkboxes in the group\\n    tabs_all = safe_query(final_db_path, \\n        \\\"SELECT label, tab_type FROM template_tabs WHERE template_id = ? AND role_id = ? AND group_id = ?\\\",\\n        (template_id, role_id, group_id))\\n    for label, tab_type in tabs_all:\\n        if tab_type == 'checkbox' and label not in checkbox_labels:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # Check for partial creation previously (should not exist in initial_db)\\n    initial_group = safe_query(initial_db_path, \\\"SELECT id FROM template_tab_groups WHERE template_id = ? AND role_id = ? AND name = ?\\\", (template_id, role_id, 'Optional Add-ons'))\\n    if initial_group:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    for lbl in checkbox_labels:\\n        initial_boxes = safe_query(initial_db_path, \\n            \\\"SELECT id FROM template_tabs WHERE template_id = ? AND role_id = ? AND label = ?\\\", (template_id, role_id, lbl))\\n        if initial_boxes:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed deterministically\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 7, "task": "Create a new user group named 'APAC Sales' and assign it the permission set 'Send with Templates Only', then add users with emails 'sana.watanabe@example.com' and 'li.wei@example.com' to the group.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    # Helper function to safely query a database\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Task details\n    group_name = 'APAC Sales'\n    permission_name = 'Send with Templates Only'\n    member_emails = ['sana.watanabe@example.com', 'li.wei@example.com']\n    owner_user_id = 1\n\n    # Get id of permission set from name (in final)\n    perm_rows = safe_query(final_db_path, \"SELECT id FROM permission_sets WHERE name = ?\", (permission_name,))\n    if not perm_rows or not perm_rows[0] or perm_rows[0][0] is None:\n        return {\"result\": \"others\"}\n    perm_id = perm_rows[0][0]\n\n    # Find all APAC Sales groups in initial and final (by owner_user_id)\n    initial_groups = safe_query(initial_db_path, \"SELECT id, permission_set_id FROM user_groups WHERE owner_user_id = ? AND name = ?\", (owner_user_id, group_name))\n    final_groups = safe_query(final_db_path, \"SELECT id, permission_set_id FROM user_groups WHERE owner_user_id = ? AND name = ?\", (owner_user_id, group_name))\n\n    # If no APAC Sales group in final, task not complete\n    if not final_groups or not final_groups[0] or final_groups[0][0] is None:\n        return {\"result\": \"others\"}\n    # Defensive: Only accept if one group in final\n    if len(final_groups) != 1:\n        return {\"result\": \"others\"}\n    final_group_id, final_permission_set_id = final_groups[0]\n    # Group must have correct permission set\n    if final_permission_set_id != perm_id:\n        return {\"result\": \"others\"}\n\n    # Defensive: Check if a group with same name existed before\n    # If initial group exists, check if group id changed or members changed\n    if initial_groups:\n        initial_group_id, initial_perm_id = initial_groups[0]\n        # If permission set already correct, check members\n        if initial_perm_id == perm_id:\n            # Check initial members\n            initial_members = safe_query(initial_db_path, \"SELECT user_id FROM group_members WHERE group_id = ?\", (initial_group_id,))\n            initial_member_ids = set([uid[0] for uid in initial_members if uid and uid[0] is not None])\n            # Final members\n            final_members = safe_query(final_db_path, \"SELECT user_id FROM group_members WHERE group_id = ?\", (final_group_id,))\n            final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\n            # Get the user ids for the intended emails from final users\n            user_ids = []\n            for email in member_emails:\n                rows = safe_query(final_db_path, \"SELECT id FROM users WHERE email = ?\", (email,))\n                if not rows or not rows[0] or rows[0][0] is None:\n                    return {\"result\": \"others\"}\n                user_ids.append(rows[0][0])\n            # Defensive: Both users in member list, exactly\n            if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\n                # If initial set of members was NOT equal, then it was newly assigned\n                if initial_member_ids != final_member_ids:\n                    return {\"result\": \"complete\"}\n                # If both member assignment and permission set were already correct, agent may have done nothing\n                return {\"result\": \"others\"}  # If group/perm/members already present originally\n            else:\n                return {\"result\": \"others\"}\n        else:\n            # If permission set was not correct before, but now is, and members correct\n            final_members = safe_query(final_db_path, \"SELECT user_id FROM group_members WHERE group_id = ?\", (final_group_id,))\n            final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\n            user_ids = []\n            for email in member_emails:\n                rows = safe_query(final_db_path, \"SELECT id FROM users WHERE email = ?\", (email,))\n                if not rows or not rows[0] or rows[0][0] is None:\n                    return {\"result\": \"others\"}\n                user_ids.append(rows[0][0])\n            if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\n                return {\"result\": \"complete\"}\n            else:\n                return {\"result\": \"others\"}\n    else:\n        # Group did not exist before, so must check its members in final\n        final_members = safe_query(final_db_path, \"SELECT user_id FROM group_members WHERE group_id = ?\", (final_group_id,))\n        final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\n        # Find user ids for intended emails\n        user_ids = []\n        for email in member_emails:\n            rows = safe_query(final_db_path, \"SELECT id FROM users WHERE email = ?\", (email,))\n            if not rows or not rows[0] or rows[0][0] is None:\n                return {\"result\": \"others\"}\n            user_ids.append(rows[0][0])\n        # Members must match exactly, no extra\n        if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\n            return {\"result\": \"complete\"}\n        else:\n            return {\"result\": \"others\"}\n\n    return {\"result\": \"others\"}", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must deterministically confirm three requirements: (1) a new user group named 'APAC Sales' exists, (2) it has the permission set 'Send with Templates Only', and (3) the group contains users with emails 'sana.watanabe@example.com' and 'li.wei@example.com'. These must be checked against a possible change in the database from initial to final state. The checks include: whether the group 'APAC Sales' was newly created, whether its permission set is correct, and whether BOTH specified users are assigned to the group. Defensive programming is required: ensure the group, permission sets, and users all exist, and all relationships are present. Partial completion, multiples, or missing assignments must return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Determine if a group named 'APAC Sales' was newly created between initial and final database.\",\n        \"Ensure the group has permission set 'Send with Templates Only' (exact match).\",\n        \"Verify exactly two users with emails 'sana.watanabe@example.com' and 'li.wei@example.com' are members of the new group.\",\n        \"Check that both users exist in the users table.\",\n        \"Ensure no partial/missing assignments or duplicate group names.\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    # Helper function to safely query a database\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Task details\\n    group_name = 'APAC Sales'\\n    permission_name = 'Send with Templates Only'\\n    member_emails = ['sana.watanabe@example.com', 'li.wei@example.com']\\n    owner_user_id = 1\\n\\n    # Get id of permission set from name (in final)\\n    perm_rows = safe_query(final_db_path, \\\"SELECT id FROM permission_sets WHERE name = ?\\\", (permission_name,))\\n    if not perm_rows or not perm_rows[0] or perm_rows[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    perm_id = perm_rows[0][0]\\n\\n    # Find all APAC Sales groups in initial and final (by owner_user_id)\\n    initial_groups = safe_query(initial_db_path, \\\"SELECT id, permission_set_id FROM user_groups WHERE owner_user_id = ? AND name = ?\\\", (owner_user_id, group_name))\\n    final_groups = safe_query(final_db_path, \\\"SELECT id, permission_set_id FROM user_groups WHERE owner_user_id = ? AND name = ?\\\", (owner_user_id, group_name))\\n\\n    # If no APAC Sales group in final, task not complete\\n    if not final_groups or not final_groups[0] or final_groups[0][0] is None:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Defensive: Only accept if one group in final\\n    if len(final_groups) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    final_group_id, final_permission_set_id = final_groups[0]\\n    # Group must have correct permission set\\n    if final_permission_set_id != perm_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Defensive: Check if a group with same name existed before\\n    # If initial group exists, check if group id changed or members changed\\n    if initial_groups:\\n        initial_group_id, initial_perm_id = initial_groups[0]\\n        # If permission set already correct, check members\\n        if initial_perm_id == perm_id:\\n            # Check initial members\\n            initial_members = safe_query(initial_db_path, \\\"SELECT user_id FROM group_members WHERE group_id = ?\\\", (initial_group_id,))\\n            initial_member_ids = set([uid[0] for uid in initial_members if uid and uid[0] is not None])\\n            # Final members\\n            final_members = safe_query(final_db_path, \\\"SELECT user_id FROM group_members WHERE group_id = ?\\\", (final_group_id,))\\n            final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\\n            # Get the user ids for the intended emails from final users\\n            user_ids = []\\n            for email in member_emails:\\n                rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE email = ?\\\", (email,))\\n                if not rows or not rows[0] or rows[0][0] is None:\\n                    return {\\\"result\\\": \\\"others\\\"}\\n                user_ids.append(rows[0][0])\\n            # Defensive: Both users in member list, exactly\\n            if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\\n                # If initial set of members was NOT equal, then it was newly assigned\\n                if initial_member_ids != final_member_ids:\\n                    return {\\\"result\\\": \\\"complete\\\"}\\n                # If both member assignment and permission set were already correct, agent may have done nothing\\n                return {\\\"result\\\": \\\"others\\\"}  # If group/perm/members already present originally\\n            else:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        else:\\n            # If permission set was not correct before, but now is, and members correct\\n            final_members = safe_query(final_db_path, \\\"SELECT user_id FROM group_members WHERE group_id = ?\\\", (final_group_id,))\\n            final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\\n            user_ids = []\\n            for email in member_emails:\\n                rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE email = ?\\\", (email,))\\n                if not rows or not rows[0] or rows[0][0] is None:\\n                    return {\\\"result\\\": \\\"others\\\"}\\n                user_ids.append(rows[0][0])\\n            if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\\n                return {\\\"result\\\": \\\"complete\\\"}\\n            else:\\n                return {\\\"result\\\": \\\"others\\\"}\\n    else:\\n        # Group did not exist before, so must check its members in final\\n        final_members = safe_query(final_db_path, \\\"SELECT user_id FROM group_members WHERE group_id = ?\\\", (final_group_id,))\\n        final_member_ids = set([uid[0] for uid in final_members if uid and uid[0] is not None])\\n        # Find user ids for intended emails\\n        user_ids = []\\n        for email in member_emails:\\n            rows = safe_query(final_db_path, \\\"SELECT id FROM users WHERE email = ?\\\", (email,))\\n            if not rows or not rows[0] or rows[0][0] is None:\\n                return {\\\"result\\\": \\\"others\\\"}\\n            user_ids.append(rows[0][0])\\n        # Members must match exactly, no extra\\n        if set(user_ids) == final_member_ids and len(final_member_ids) == 2:\\n            return {\\\"result\\\": \\\"complete\\\"}\\n        else:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"others\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 8, "task": "Configure a Connect (webhook) subscription that posts JSON to 'https://webhook.example.com/docusign/events' for envelope events 'sent', 'delivered', 'completed', 'declined', and 'voided', including recipient and document status in the payload.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Helper to safely fetch query results\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # Specification\n    REQUIRED_ENDPOINT = 'https://webhook.example.com/docusign/events'\n    REQUIRED_CONTENT_TYPE = 'application/json'\n    REQUIRED_EVENTS = set(['sent','delivered','completed','declined','voided'])\n    \n    # 1. Check in FINAL DB for exactly one enabled subscription with all required settings\n    subs = safe_query(\n        final_db_path,\n        '''SELECT id, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status FROM connect_subscriptions WHERE endpoint_url = ?''',\n        (REQUIRED_ENDPOINT,)\n    )\n    matching_subs = []\n    for row in subs:\n        (sid, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status) = row\n        if (endpoint_url == REQUIRED_ENDPOINT and content_type == REQUIRED_CONTENT_TYPE and enabled == 1 and include_recipient_status == 1 and include_document_status == 1):\n            matching_subs.append({'id': sid, 'owner_user_id': owner_user_id})\n    if len(matching_subs) != 1:\n        # Must be exactly one enabled matching subscription\n        return {\"result\": \"others\"}\n    sub_id = matching_subs[0]['id']\n    # Confirm exactly the required events are present\n    events = safe_query(\n        final_db_path,\n        '''SELECT event_type FROM connect_subscription_events WHERE subscription_id = ?''',\n        (sub_id,)\n    )\n    event_types = set(e[0] for e in events if e and e[0])\n    if event_types != REQUIRED_EVENTS:\n        return {\"result\": \"others\"}\n    # 2. Check that this did NOT already exist in the initial DB (enabled, settings, and all events)\n    initsubs = safe_query(\n        initial_db_path,\n        '''SELECT id, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status FROM connect_subscriptions WHERE endpoint_url = ?''',\n        (REQUIRED_ENDPOINT,)\n    )\n    already_exists = False\n    for row in initsubs:\n        (isid, _, iendpoint_url, icontent_type, ienabled, iinclude_recipient_status, iinclude_document_status) = row\n        if (iendpoint_url == REQUIRED_ENDPOINT and icontent_type == REQUIRED_CONTENT_TYPE and ienabled == 1 and iinclude_recipient_status == 1 and iinclude_document_status == 1):\n            # Check if associated events all present\n            inevts = safe_query(\n                initial_db_path,\n                '''SELECT event_type FROM connect_subscription_events WHERE subscription_id = ?''',\n                (isid,)\n            )\n            inevtypes = set(e[0] for e in inevts if e and e[0])\n            if inevtypes == REQUIRED_EVENTS:\n                already_exists = True\n                break\n    if already_exists:\n        return {\"result\": \"others\"}\n    # All checks passed deterministically\n    return {\"result\": \"complete\"} ", "raw_response": "{\n    \"reasoning\": \"The task requires configuring a DocuSign Connect (webhook) subscription that meets ALL of the following conditions: 1) The subscription posts to 'https://webhook.example.com/docusign/events'. 2) It is enabled. 3) The content type is 'application/json'. 4) It is set to trigger for the exact set of envelope events: 'sent', 'delivered', 'completed', 'declined', and 'voided'. 5) Both recipient status and document status are included in the webhook payload (the corresponding boolean fields must be TRUE). No additional/irrelevant subscriptions or events are to be considered valid for completion. The verification must compare before and after state to confirm that a new or modified subscription now precisely satisfies all requirements. The code must ensure the subscription did not exist with all requirements prior and was not enabled, or if it existed previously, verify its configuration was modified to meet the requirements in the final_db only.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"In the final database, there exists exactly one enabled connect_subscriptions record (for current user) with endpoint_url = https://webhook.example.com/docusign/events, content_type = 'application/json', enabled = 1, include_recipient_status = 1, include_document_status = 1\",\n        \"In the final database, the subscription above has connect_subscription_events rows for ALL AND ONLY the events ['sent','delivered','completed','declined','voided'] (no missing, no extra events)\",\n        \"In the initial database, no connect_subscriptions record with endpoint_url = https://webhook.example.com/docusign/events had all required fields set as above AND all required events linked and enabled\",\n        \"All above checks succeed with no ambiguity or missing data\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Helper to safely fetch query results\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # Specification\\n    REQUIRED_ENDPOINT = 'https://webhook.example.com/docusign/events'\\n    REQUIRED_CONTENT_TYPE = 'application/json'\\n    REQUIRED_EVENTS = set(['sent','delivered','completed','declined','voided'])\\n    \\n    # 1. Check in FINAL DB for exactly one enabled subscription with all required settings\\n    subs = safe_query(\\n        final_db_path,\\n        '''SELECT id, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status FROM connect_subscriptions WHERE endpoint_url = ?''',\\n        (REQUIRED_ENDPOINT,)\\n    )\\n    matching_subs = []\\n    for row in subs:\\n        (sid, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status) = row\\n        if (endpoint_url == REQUIRED_ENDPOINT and content_type == REQUIRED_CONTENT_TYPE and enabled == 1 and include_recipient_status == 1 and include_document_status == 1):\\n            matching_subs.append({'id': sid, 'owner_user_id': owner_user_id})\\n    if len(matching_subs) != 1:\\n        # Must be exactly one enabled matching subscription\\n        return {\\\"result\\\": \\\"others\\\"}\\n    sub_id = matching_subs[0]['id']\\n    # Confirm exactly the required events are present\\n    events = safe_query(\\n        final_db_path,\\n        '''SELECT event_type FROM connect_subscription_events WHERE subscription_id = ?''',\\n        (sub_id,)\\n    )\\n    event_types = set(e[0] for e in events if e and e[0])\\n    if event_types != REQUIRED_EVENTS:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # 2. Check that this did NOT already exist in the initial DB (enabled, settings, and all events)\\n    initsubs = safe_query(\\n        initial_db_path,\\n        '''SELECT id, owner_user_id, endpoint_url, content_type, enabled, include_recipient_status, include_document_status FROM connect_subscriptions WHERE endpoint_url = ?''',\\n        (REQUIRED_ENDPOINT,)\\n    )\\n    already_exists = False\\n    for row in initsubs:\\n        (isid, _, iendpoint_url, icontent_type, ienabled, iinclude_recipient_status, iinclude_document_status) = row\\n        if (iendpoint_url == REQUIRED_ENDPOINT and icontent_type == REQUIRED_CONTENT_TYPE and ienabled == 1 and iinclude_recipient_status == 1 and iinclude_document_status == 1):\\n            # Check if associated events all present\\n            inevts = safe_query(\\n                initial_db_path,\\n                '''SELECT event_type FROM connect_subscription_events WHERE subscription_id = ?''',\\n                (isid,)\\n            )\\n            inevtypes = set(e[0] for e in inevts if e and e[0])\\n            if inevtypes == REQUIRED_EVENTS:\\n                already_exists = True\\n                break\\n    if already_exists:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed deterministically\\n    return {\\\"result\\\": \\\"complete\\\"} \",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "docusign_e_signature_agreement_workflow", "task_idx": 9, "task": "Using the API simulation mode, create an envelope with metadata only (no real document content) for 'Employee Handbook Acknowledgement - Feb 2026' with recipients Priya Shah (Signer, priya.shah@example.com) and HR Archive (CC, hr-archive@example.com), include tabs for Signature and Date Signed, transition the envelope through sent->delivered->signed->completed, and return the completion artifacts including certificateId and final audit event log.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n\n    def safe_query(db_path: str, query: str, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # 1. Find the envelope\n    envs = safe_query(final_db_path, \"SELECT id, status, source_type, title FROM envelopes WHERE title = ?\", ('Employee Handbook Acknowledgement - Feb 2026',))\n    if len(envs) != 1:\n        return {\"result\": \"others\"}\n    envelope_id, env_status, env_source, env_title = envs[0]\n    if env_status != 'Completed' or env_source != 'api_simulation':\n        return {\"result\": \"others\"}\n\n    # 2. Check envelope_documents (exactly 1, correct doc)\n    docs = safe_query(final_db_path,\n        \"SELECT ed.document_id, d.filename, d.storage_mode FROM envelope_documents ed JOIN documents d ON ed.document_id = d.id WHERE ed.envelope_id = ?\", (envelope_id,))\n    if len(docs) != 1:\n        return {\"result\": \"others\"}\n    doc_id, doc_filename, doc_storage = docs[0]\n    if doc_filename != 'Employee_Handbook_Acknowledgement_Feb_2026.pdf' or doc_storage != 'metadata_only':\n        return {\"result\": \"others\"}\n\n    # 3. Check recipients: must be exactly two and correct\n    recs = safe_query(final_db_path,\n        \"SELECT id, role, routing_order, name, email, status FROM envelope_recipients WHERE envelope_id = ?\", (envelope_id,))\n    if len(recs) != 2:\n        return {\"result\": \"others\"}\n    priya = None\n    hr = None\n    for r in recs:\n        (rid, role, routing_order, name, email, status) = r\n        if role == 'Signer' and name == 'Priya Shah' and email == 'priya.shah@example.com' and routing_order == 1:\n            if status != 'Completed':\n                return {\"result\": \"others\"}\n            priya = rid\n        elif role == 'CC' and name == 'HR Archive' and email == 'hr-archive@example.com' and routing_order == 2:\n            if status != 'Completed':\n                return {\"result\": \"others\"}\n            hr = rid\n    if not (priya and hr):\n        return {\"result\": \"others\"}\n\n    # 4. Check tabs for Priya Shah: must be signature and date_signed\n    tab_types = safe_query(final_db_path,\n        \"SELECT tab_type, label FROM tabs WHERE envelope_id = ? AND recipient_id = ?\", (envelope_id, priya))\n    types_needed = {'signature': False, 'date_signed': False}\n    for ttype, label in tab_types:\n        if ttype == 'signature' and label and 'Signature' in label:\n            types_needed['signature'] = True\n        elif ttype == 'date_signed' and label and 'Date Signed' in label:\n            types_needed['date_signed'] = True\n    if not all(types_needed.values()):\n        return {\"result\": \"others\"}\n\n    # 5. Check audit_events: must show sent workflow\n    events = safe_query(final_db_path,\n        \"SELECT event_type, recipient_id, event_at FROM audit_events WHERE envelope_id = ? ORDER BY event_at\", (envelope_id,))\n    # Must include (in order): created, sent, delivered (for Priya), signed (for Priya), completed\n    needed = ['created', 'sent', 'delivered', 'signed', 'completed']\n    positions = {k: None for k in needed}\n    for idx, (evtype, recid, event_at) in enumerate(events):\n        if evtype in needed and positions[evtype] is None:\n            positions[evtype] = idx\n    # Must be present and in correct order (strictly increasing indices)\n    if any(v is None for v in positions.values()):\n        return {\"result\": \"others\"}\n    order = [positions[k] for k in needed]\n    if order != sorted(order):\n        return {\"result\": \"others\"}\n    # delivered/signed should refer to Priya\n    delivered_ev = [ev for ev in events if ev[0] == 'delivered']\n    signed_ev = [ev for ev in events if ev[0] == 'signed']\n    if not (delivered_ev and delivered_ev[0][1] == priya):\n        return {\"result\": \"others\"}\n    if not (signed_ev and signed_ev[0][1] == priya):\n        return {\"result\": \"others\"}\n\n    # 6. Check envelope_artifacts for certificate and audit_log\n    artifacts = safe_query(final_db_path,\n        \"SELECT artifact_type, certificate_id FROM envelope_artifacts WHERE envelope_id = ?\", (envelope_id,))\n    cert_found = False\n    auditlog_found = False\n    cert_id_val = None\n    for atype, cert_id in artifacts:\n        if atype == 'certificate' and cert_id:\n            cert_found = True\n            cert_id_val = cert_id\n        elif atype == 'final_audit_log':\n            auditlog_found = True\n    if not cert_found or not auditlog_found:\n        return {\"result\": \"others\"}\n\n    # 7. Optionally check final_answer: must mention certificateId and audit log\n    if final_answer:\n        certid_regex = re.search(r'certificateId\\s*[:=]\\s*([\\w\\-]+)', final_answer, re.IGNORECASE)\n        auditlog_regex = re.search(r'audit\\s*event\\s*log', final_answer, re.IGNORECASE)\n        if certid_regex:\n            found_certid = certid_regex.group(1)\n            if found_certid and cert_id_val and found_certid != cert_id_val:\n                return {\"result\": \"others\"}\n        else:\n            return {\"result\": \"others\"}\n        if not auditlog_regex:\n            return {\"result\": \"others\"}\n\n    # All checks pass\n    return {\"result\": \"complete\"}", "raw_response": "{\n    \"reasoning\": \"To verify completion of this DocuSign workflow simulation task, the following must be true: An envelope was created in API simulation mode (source_type 'api_simulation') for 'Employee Handbook Acknowledgement - Feb 2026'; its only document must have storage_mode 'metadata_only' with the correct filename; two recipients must be present (Priya Shah [Signer, priya.shah@example.com] and HR Archive [CC, hr-archive@example.com]) with correct routing orders and both statuses set to 'Completed'; tabs of types 'signature' and 'date_signed' must be anchored for Priya Shah; envelope status must be 'Completed' with correct sent and completed times; audit_events must show a full workflow: 'created', 'sent', 'delivered', 'signed', 'completed', all tied to the envelope; envelope_artifacts must include both a certificate (with certificate_id) and a final_audit_log; and final_answer, if present, must include the certificateId and mention the audit log. All these checks must pass with no ambiguity for completion.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Envelope exists with title 'Employee Handbook Acknowledgement - Feb 2026', source_type 'api_simulation', status 'Completed'\",\n        \"Envelope contains 1 document with filename 'Employee_Handbook_Acknowledgement_Feb_2026.pdf', storage_mode 'metadata_only'\",\n        \"Envelope has two recipients: Priya Shah (Signer, routing_order 1, email 'priya.shah@example.com', status 'Completed'), HR Archive (CC, routing_order 2, email 'hr-archive@example.com', status 'Completed')\",\n        \"Tabs for the envelope and Priya Shah of type 'signature' (label 'Employee Signature') and type 'date_signed' (label 'Date Signed') exist\",\n        \"Audit events for the envelope include 'created', 'sent', 'delivered', 'signed', 'completed' in logical order\",\n        \"Envelope artifacts include one of type 'certificate' with non-null certificate_id, and one of type 'final_audit_log'\",\n        \"If final_answer is given, it includes (regex) certificateId and mentions the final audit event log\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n\\n    def safe_query(db_path: str, query: str, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # 1. Find the envelope\\n    envs = safe_query(final_db_path, \\\"SELECT id, status, source_type, title FROM envelopes WHERE title = ?\\\", ('Employee Handbook Acknowledgement - Feb 2026',))\\n    if len(envs) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    envelope_id, env_status, env_source, env_title = envs[0]\\n    if env_status != 'Completed' or env_source != 'api_simulation':\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 2. Check envelope_documents (exactly 1, correct doc)\\n    docs = safe_query(final_db_path,\\n        \\\"SELECT ed.document_id, d.filename, d.storage_mode FROM envelope_documents ed JOIN documents d ON ed.document_id = d.id WHERE ed.envelope_id = ?\\\", (envelope_id,))\\n    if len(docs) != 1:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    doc_id, doc_filename, doc_storage = docs[0]\\n    if doc_filename != 'Employee_Handbook_Acknowledgement_Feb_2026.pdf' or doc_storage != 'metadata_only':\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 3. Check recipients: must be exactly two and correct\\n    recs = safe_query(final_db_path,\\n        \\\"SELECT id, role, routing_order, name, email, status FROM envelope_recipients WHERE envelope_id = ?\\\", (envelope_id,))\\n    if len(recs) != 2:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    priya = None\\n    hr = None\\n    for r in recs:\\n        (rid, role, routing_order, name, email, status) = r\\n        if role == 'Signer' and name == 'Priya Shah' and email == 'priya.shah@example.com' and routing_order == 1:\\n            if status != 'Completed':\\n                return {\\\"result\\\": \\\"others\\\"}\\n            priya = rid\\n        elif role == 'CC' and name == 'HR Archive' and email == 'hr-archive@example.com' and routing_order == 2:\\n            if status != 'Completed':\\n                return {\\\"result\\\": \\\"others\\\"}\\n            hr = rid\\n    if not (priya and hr):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 4. Check tabs for Priya Shah: must be signature and date_signed\\n    tab_types = safe_query(final_db_path,\\n        \\\"SELECT tab_type, label FROM tabs WHERE envelope_id = ? AND recipient_id = ?\\\", (envelope_id, priya))\\n    types_needed = {'signature': False, 'date_signed': False}\\n    for ttype, label in tab_types:\\n        if ttype == 'signature' and label and 'Signature' in label:\\n            types_needed['signature'] = True\\n        elif ttype == 'date_signed' and label and 'Date Signed' in label:\\n            types_needed['date_signed'] = True\\n    if not all(types_needed.values()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 5. Check audit_events: must show sent workflow\\n    events = safe_query(final_db_path,\\n        \\\"SELECT event_type, recipient_id, event_at FROM audit_events WHERE envelope_id = ? ORDER BY event_at\\\", (envelope_id,))\\n    # Must include (in order): created, sent, delivered (for Priya), signed (for Priya), completed\\n    needed = ['created', 'sent', 'delivered', 'signed', 'completed']\\n    positions = {k: None for k in needed}\\n    for idx, (evtype, recid, event_at) in enumerate(events):\\n        if evtype in needed and positions[evtype] is None:\\n            positions[evtype] = idx\\n    # Must be present and in correct order (strictly increasing indices)\\n    if any(v is None for v in positions.values()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    order = [positions[k] for k in needed]\\n    if order != sorted(order):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # delivered/signed should refer to Priya\\n    delivered_ev = [ev for ev in events if ev[0] == 'delivered']\\n    signed_ev = [ev for ev in events if ev[0] == 'signed']\\n    if not (delivered_ev and delivered_ev[0][1] == priya):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    if not (signed_ev and signed_ev[0][1] == priya):\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 6. Check envelope_artifacts for certificate and audit_log\\n    artifacts = safe_query(final_db_path,\\n        \\\"SELECT artifact_type, certificate_id FROM envelope_artifacts WHERE envelope_id = ?\\\", (envelope_id,))\\n    cert_found = False\\n    auditlog_found = False\\n    cert_id_val = None\\n    for atype, cert_id in artifacts:\\n        if atype == 'certificate' and cert_id:\\n            cert_found = True\\n            cert_id_val = cert_id\\n        elif atype == 'final_audit_log':\\n            auditlog_found = True\\n    if not cert_found or not auditlog_found:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # 7. Optionally check final_answer: must mention certificateId and audit log\\n    if final_answer:\\n        certid_regex = re.search(r'certificateId\\\\s*[:=]\\\\s*([\\\\w\\\\-]+)', final_answer, re.IGNORECASE)\\n        auditlog_regex = re.search(r'audit\\\\s*event\\\\s*log', final_answer, re.IGNORECASE)\\n        if certid_regex:\\n            found_certid = certid_regex.group(1)\\n            if found_certid and cert_id_val and found_certid != cert_id_val:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        else:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if not auditlog_regex:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # All checks pass\\n    return {\\\"result\\\": \\\"complete\\\"}\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "surveymonkey_apply", "task_idx": 9, "task": "Create interview appointments for all \"Shortlisted\" submissions in cycle \"Fall 2026\" as 20-minute slots on \"2026-10-20\" between \"10:00\" and \"12:00\" America/New_York, send an automated email with subject \"Interview Invitation - STEM Scholars Grant\" and body \"Please select an interview time by Oct 15; replies are monitored,\" and then export a CSV of all \"Approved\" awardees with fields (submission_id, applicant_name, email, award_amount, decision_date).", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    from datetime import datetime, timedelta, time as dt_time, date as dt_date\n    from zoneinfo import ZoneInfo\n    import csv\n    import io\n\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive, ro-mode\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Helper to find cycle id for 'Fall 2026' (created possibly by agent), or None\n    def get_fall2026_cycle_id(db_path):\n        rows = safe_query(db_path, \"SELECT id FROM cycles WHERE name = ?\", (\"Fall 2026\",))\n        return rows[0][0] if rows else None\n\n    # Helper to get all 'Shortlisted' submissions in cycle\n    def get_shortlisted_submissions(db_path, cycle_id):\n        if not cycle_id:\n            return []\n        rows = safe_query(\n            db_path,\n            \"SELECT id, applicant_user_id FROM submissions WHERE cycle_id=? AND status='Shortlisted'\",\n            (cycle_id,)\n        )\n        return rows  # [(submission_id, applicant_user_id), ...]\n    \n    # Helper: submissions with status 'Approved'\n    def get_approved_submissions(db_path, cycle_id):\n        if not cycle_id:\n            return []\n        # Get required fields: submission_id, applicant_name, email, award_amount, decision_date\n        rows = safe_query(\n            db_path,\n            \"SELECT s.id, u.full_name, u.email, a.award_amount, a.decision_date \"\n            \"FROM submissions s \"\n            \"JOIN users u ON s.applicant_user_id = u.id \"\n            \"JOIN awards a ON s.id = a.submission_id \"\n            \"WHERE s.cycle_id=? AND s.status='Approved'\",\n            (cycle_id,)\n        )\n        return rows  # [(sub_id, name, email, award, date)]\n\n    # Helper to get all interview_campaigns and their slots for this cycle\n    def get_interview_slots_for_cycle(db_path, cycle_id):\n        rows = safe_query(db_path, \"SELECT id, time_zone FROM interview_campaigns WHERE cycle_id = ?\", (cycle_id,))\n        campaigns = {}\n        for (cid, time_zone) in rows:\n            slots = safe_query(db_path, \"SELECT id, start_at, end_at, is_booked FROM interview_slots WHERE campaign_id=?\", (cid,))\n            campaigns[cid] = { 'time_zone': time_zone, 'slots': slots }\n        return campaigns  # {campaign_id: {'time_zone':tz, 'slots':[(id, start_at, end_at, is_booked)]}}\n\n    # Helper to get slot-submission assignments\n    def get_interview_slot_assignments(db_path, campaign_id):\n        rows = safe_query(db_path, \"SELECT slot_id, submission_id FROM interview_bookings WHERE campaign_id=?\", (campaign_id,))\n        return {slot_id: submission_id for slot_id, submission_id in rows}\n\n    # Helper to get relevant emails\n    def get_interview_emails(db_path, cycle_id, shortlisted_submission_ids):\n        if not shortlisted_submission_ids:\n            return []\n        fmt = ','.join(['?']*len(shortlisted_submission_ids))\n        # subject and body must match exactly as required\n        subject_txt = 'Interview Invitation - STEM Scholars Grant'\n        body_txt = 'Please select an interview time by Oct 15; replies are monitored,'\n        rows = safe_query(\n            db_path,\n            f\"SELECT submission_id, recipient_email, subject, body, status FROM email_outbox WHERE cycle_id=? AND submission_id IN ({fmt})\",\n            (cycle_id, *shortlisted_submission_ids)\n        )\n        # Only those with the exact subject and body\n        return [r for r in rows if r[2] == subject_txt and r[3].strip() == body_txt]\n\n    # Validate interview slot time matches requirements strictly\n    def slot_is_correct(start_at, end_at):\n        # Should be 20 min slot on 2026-10-20 between 10:00 and 12:00 America/New_York\n        tz = ZoneInfo(\"America/New_York\")\n        try:\n            # Accept: 2026-10-20T10:00:00-04:00  (ISO)\n            dt1 = datetime.fromisoformat(start_at)\n            dt2 = datetime.fromisoformat(end_at)\n            if dt1.tzinfo is None:\n                dt1 = dt1.replace(tzinfo=tz)\n            else:\n                dt1 = dt1.astimezone(tz)\n            if dt2.tzinfo is None:\n                dt2 = dt2.replace(tzinfo=tz)\n            else:\n                dt2 = dt2.astimezone(tz)\n            # Must be on the exact date\n            if dt1.date() != dt_date(2026,10,20) or dt2.date() != dt_date(2026,10,20):\n                return False\n            # Time between 10:00 and 12:00\n            allowed_start = dt_time(10,0)\n            allowed_end = dt_time(12,0)\n            if not (allowed_start <= dt1.time() < allowed_end):\n                return False\n            # Slot must be exactly 20min\n            duration = (dt2 - dt1).total_seconds() / 60.0\n            if abs(duration - 20.0) > 0.1:  # 1/10th min tolerance\n                return False\n            return True\n        except Exception:\n            return False\n\n    # CSV / Table checker for final_answer\n    def parse_csv_from_answer(ans_str, n_fields):\n        if not ans_str:\n            return []\n        # Try to find a CSV fragment in the answer with correct columns\n        # We'll catch both markdown and plain CSV\n        # First line should have header including 'submission_id' etc\n        expected_fields = [\"submission_id\", \"applicant_name\", \"email\", \"award_amount\", \"decision_date\"]\n        pattern = r\"(?:submission_id\\s*,\\s*applicant_name\\s*,\\s*email\\s*,\\s*award_amount\\s*,\\s*decision_date[\\s\\S]+)\"\n        m = re.search(pattern, ans_str, re.IGNORECASE)\n        if not m:\n            return []\n        # Grab from start of header to end of table (stop at double newline or end)\n        lines = []\n        data_portion = ans_str[m.start():]\n        # Accept to next double newline, or end of string\n        for line in data_portion.splitlines():\n            if line.strip() == '':\n                break\n            lines.append(line.strip())\n        if not lines:\n            return []\n        # Parse via csv.reader, tolerate extra whitespace\n        try:\n            reader = csv.reader(lines)\n            result = [tuple(cell.strip() for cell in row) for row in reader if any(cell.strip() for cell in row)]\n            # skip header?\n            fields_ = [h.lower().replace(' ','_') for h in result[0] ]\n            if fields_[:n_fields] == expected_fields:\n                return result[1:]\n            else:\n                return []\n        except Exception:\n            return []\n\n    # --- Begin logic ---\n    # Step 1. Get new 'Fall 2026' cycle id if it exists in final DB\n    cycle_id_final = get_fall2026_cycle_id(final_db_path)\n    if not cycle_id_final:  # If agent never created the cycle\n        # Accept only if initial and final DB both lack it, and there are no spurious records\n        cycle_id_init = get_fall2026_cycle_id(initial_db_path)\n        if cycle_id_init:\n            return {\"result\": \"others\"}\n        # Check that there are no new interview_campaigns, slots or emails in final\n        has_interview_campaigns = bool(safe_query(final_db_path, \"SELECT 1 FROM interview_campaigns WHERE name LIKE 'Fall 2026%' LIMIT 1\"))\n        has_interview_emails = bool(safe_query(final_db_path, \"SELECT 1 FROM email_outbox WHERE subject LIKE 'Interview Invitation%' AND cycle_id IS NULL LIMIT 1\"))\n        if has_interview_campaigns or has_interview_emails:\n            return {\"result\": \"others\"}\n        # If also no CSV was required, 'complete' only if there are zero 'Shortlisted' submissions for this cycle (should be, since cycle does not exist)\n        return {\"result\": \"complete\"}\n    # Step 2. Find all Shortlisted submissions in FINAL DB for this cycle\n    shortlisted = get_shortlisted_submissions(final_db_path, cycle_id_final)\n    shortlisted_ids = [sid for sid, _ in shortlisted]\n    # Step 2a. If there are zero shortlisted (possibly legitimate case), nothing else must have been created for this cycle\n    if not shortlisted_ids:\n        # Check slots and emails in the final for this cycle\n        campaigns = safe_query(final_db_path, \"SELECT id FROM interview_campaigns WHERE cycle_id=?\", (cycle_id_final,))\n        if campaigns:\n            # Check if there are any interview slots\n            slots = safe_query(final_db_path, \"SELECT 1 FROM interview_slots WHERE campaign_id IN (SELECT id FROM interview_campaigns WHERE cycle_id=?) LIMIT 1\", (cycle_id_final,))\n            if slots:\n                return {\"result\": \"others\"}\n        emails = safe_query(final_db_path, \"SELECT 1 FROM email_outbox WHERE cycle_id=? AND subject LIKE 'Interview Invitation%' LIMIT 1\", (cycle_id_final,))\n        if emails:\n            return {\"result\": \"others\"}\n        return {\"result\": \"complete\"}\n    # Step 3. For every shortlisted submission, require:\n    #  (a) An interview slot assigned (or reserved) for them, and slot time is correct\n    #  (b) An email sent (status in sent/queued) with exact subject/body, to the right applicant\n    # For slot/campaign lookup, allow the agent to create any number of interview_campaigns named any way, but the slots must match the date/hours\n    slot_found_for_sub = {sid: False for sid in shortlisted_ids}\n    slot_campaigns = get_interview_slots_for_cycle(final_db_path, cycle_id_final)\n    assigned_submissions = set()\n    for campaign_id, cam in slot_campaigns.items():\n        # Accept campaign if ANY slot is within required window\n        for slot in cam['slots']:\n            slot_id, start_at, end_at, is_booked = slot\n            assignment = get_interview_slot_assignments(final_db_path, campaign_id)\n            subid = assignment.get(slot_id)\n            if subid in slot_found_for_sub:\n                if not slot_is_correct(start_at, end_at):\n                    continue  # wrong slot\n                # Only accept if this submission is uniquely mapped\n                if slot_found_for_sub[subid]:\n                    continue  # already found (double-book)\n                slot_found_for_sub[subid] = True\n                assigned_submissions.add(subid)\n    # All must have a slot\n    if not all(slot_found_for_sub.values()):\n        return {\"result\": \"others\"}\n    # Step 4. Email check\n    emails = get_interview_emails(final_db_path, cycle_id_final, shortlisted_ids)\n    # Each must have one, sent or queued, recipient email == applicant's email\n    # Get user emails\n    user_emails = {u[0]: safe_query(final_db_path, \"SELECT email FROM users WHERE id=?\", (u[1],))[0][0] for u in shortlisted}\n    email_for_sub = {e[0]: e for e in emails if e[4] in ('sent','queued') and e[2]=='Interview Invitation - STEM Scholars Grant'}\n    if len(email_for_sub) != len(shortlisted_ids):\n        return {\"result\": \"others\"}\n    # Check for exact recipient email\n    for sid in shortlisted_ids:\n        eml = email_for_sub.get(sid)\n        if not eml:\n            return {\"result\": \"others\"}\n        if eml[1].strip().lower() != user_emails[sid].strip().lower():\n            return {\"result\": \"others\"}\n\n    # Step 5. CSV export out (from final_answer)\n    if final_answer is not None:\n        # Must export 'Approved' awardees for this cycle\n        approved_rows = get_approved_submissions(final_db_path, cycle_id_final)\n        parsed_csv = parse_csv_from_answer(final_answer, 5)  # skip header\n        # To be certain, require that data matches exactly (excluding possible header)\n        set_approved = set((str(sid), str(name), str(email).lower(), str(float(award_amt)).rstrip('0').rstrip('.') if award_amt is not None else '', str(date)) for sid,name,email,award_amt,date in approved_rows)\n        set_csv = set((row[0], row[1], row[2].lower(), row[3].rstrip('0').rstrip('.'), row[4]) for row in parsed_csv)\n        if set_approved != set_csv:\n            return {\"result\": \"others\"}\n    # All checks passed\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we need to ascertain 3 main outcomes: (1) For ALL submissions with status 'Shortlisted' in cycle 'Fall 2026', interview appointments (20-minute slots between 10:00 and 12:00 America/New_York on 2026-10-20) must have been created and assigned, (2) an automated email invitation with the required subject and body was sent to each such applicant, and (3) a CSV of 'Approved' awardees with exact required fields was exported (optionally checked in the agent output, since the DB has no export log). This requires database modifications and text answer validation, thus \\\"combined\\\" strategy. All 'Shortlisted' submissions must be processed exactly, with no omissions or mistakes.\",\n    \"verification_strategy\": \"combined\",\n    \"key_checks\": [\n        \"Identify the ID of cycle 'Fall 2026' in both databases (must exist in final; may have been created by the agent)\",\n        \"Ensure all submissions with status 'Shortlisted' in cycle 'Fall 2026' have interview slots (20min) created between 10:0012:00 America/New_York on 2026-10-20\",\n        \"Interview slots must be assigned (booked or reserved) to each unique 'Shortlisted' submission; no excess, no missing\",\n        \"Each matching applicant must be sent an email (status 'sent' or 'queued') with subject 'Interview Invitation - STEM Scholars Grant' and body exactly 'Please select an interview time by Oct 15; replies are monitored,'\",\n        \"If there are no 'Shortlisted' submissions, then none of the above must have been created; pass only if both databases match (i.e., no bogus slots/emails created)\",\n        \"For the CSV export task: If final_answer is provided, extract a table or CSV from final_answer, and check its rows match exactly the set of 'Approved' submissions in the cycle, with fields (submission_id, applicant_name, email, award_amount, decision_date)\",\n        \"Any missing, surplus, or incorrect entries in interviews or emails, or mismatched CSV, means the task is incomplete\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    from datetime import datetime, timedelta, time as dt_time, date as dt_date\\n    from zoneinfo import ZoneInfo\\n    import csv\\n    import io\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()):  # Defensive, ro-mode\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Helper to find cycle id for 'Fall 2026' (created possibly by agent), or None\\n    def get_fall2026_cycle_id(db_path):\\n        rows = safe_query(db_path, \\\"SELECT id FROM cycles WHERE name = ?\\\", (\\\"Fall 2026\\\",))\\n        return rows[0][0] if rows else None\\n\\n    # Helper to get all 'Shortlisted' submissions in cycle\\n    def get_shortlisted_submissions(db_path, cycle_id):\\n        if not cycle_id:\\n            return []\\n        rows = safe_query(\\n            db_path,\\n            \\\"SELECT id, applicant_user_id FROM submissions WHERE cycle_id=? AND status='Shortlisted'\\\",\\n            (cycle_id,)\\n        )\\n        return rows  # [(submission_id, applicant_user_id), ...]\\n    \\n    # Helper: submissions with status 'Approved'\\n    def get_approved_submissions(db_path, cycle_id):\\n        if not cycle_id:\\n            return []\\n        # Get required fields: submission_id, applicant_name, email, award_amount, decision_date\\n        rows = safe_query(\\n            db_path,\\n            \\\"SELECT s.id, u.full_name, u.email, a.award_amount, a.decision_date \\\"\\n            \\\"FROM submissions s \\\"\\n            \\\"JOIN users u ON s.applicant_user_id = u.id \\\"\\n            \\\"JOIN awards a ON s.id = a.submission_id \\\"\\n            \\\"WHERE s.cycle_id=? AND s.status='Approved'\\\",\\n            (cycle_id,)\\n        )\\n        return rows  # [(sub_id, name, email, award, date)]\\n\\n    # Helper to get all interview_campaigns and their slots for this cycle\\n    def get_interview_slots_for_cycle(db_path, cycle_id):\\n        rows = safe_query(db_path, \\\"SELECT id, time_zone FROM interview_campaigns WHERE cycle_id = ?\\\", (cycle_id,))\\n        campaigns = {}\\n        for (cid, time_zone) in rows:\\n            slots = safe_query(db_path, \\\"SELECT id, start_at, end_at, is_booked FROM interview_slots WHERE campaign_id=?\\\", (cid,))\\n            campaigns[cid] = { 'time_zone': time_zone, 'slots': slots }\\n        return campaigns  # {campaign_id: {'time_zone':tz, 'slots':[(id, start_at, end_at, is_booked)]}}\\n\\n    # Helper to get slot-submission assignments\\n    def get_interview_slot_assignments(db_path, campaign_id):\\n        rows = safe_query(db_path, \\\"SELECT slot_id, submission_id FROM interview_bookings WHERE campaign_id=?\\\", (campaign_id,))\\n        return {slot_id: submission_id for slot_id, submission_id in rows}\\n\\n    # Helper to get relevant emails\\n    def get_interview_emails(db_path, cycle_id, shortlisted_submission_ids):\\n        if not shortlisted_submission_ids:\\n            return []\\n        fmt = ','.join(['?']*len(shortlisted_submission_ids))\\n        # subject and body must match exactly as required\\n        subject_txt = 'Interview Invitation - STEM Scholars Grant'\\n        body_txt = 'Please select an interview time by Oct 15; replies are monitored,'\\n        rows = safe_query(\\n            db_path,\\n            f\\\"SELECT submission_id, recipient_email, subject, body, status FROM email_outbox WHERE cycle_id=? AND submission_id IN ({fmt})\\\",\\n            (cycle_id, *shortlisted_submission_ids)\\n        )\\n        # Only those with the exact subject and body\\n        return [r for r in rows if r[2] == subject_txt and r[3].strip() == body_txt]\\n\\n    # Validate interview slot time matches requirements strictly\\n    def slot_is_correct(start_at, end_at):\\n        # Should be 20 min slot on 2026-10-20 between 10:00 and 12:00 America/New_York\\n        tz = ZoneInfo(\\\"America/New_York\\\")\\n        try:\\n            # Accept: 2026-10-20T10:00:00-04:00  (ISO)\\n            dt1 = datetime.fromisoformat(start_at)\\n            dt2 = datetime.fromisoformat(end_at)\\n            if dt1.tzinfo is None:\\n                dt1 = dt1.replace(tzinfo=tz)\\n            else:\\n                dt1 = dt1.astimezone(tz)\\n            if dt2.tzinfo is None:\\n                dt2 = dt2.replace(tzinfo=tz)\\n            else:\\n                dt2 = dt2.astimezone(tz)\\n            # Must be on the exact date\\n            if dt1.date() != dt_date(2026,10,20) or dt2.date() != dt_date(2026,10,20):\\n                return False\\n            # Time between 10:00 and 12:00\\n            allowed_start = dt_time(10,0)\\n            allowed_end = dt_time(12,0)\\n            if not (allowed_start <= dt1.time() < allowed_end):\\n                return False\\n            # Slot must be exactly 20min\\n            duration = (dt2 - dt1).total_seconds() / 60.0\\n            if abs(duration - 20.0) > 0.1:  # 1/10th min tolerance\\n                return False\\n            return True\\n        except Exception:\\n            return False\\n\\n    # CSV / Table checker for final_answer\\n    def parse_csv_from_answer(ans_str, n_fields):\\n        if not ans_str:\\n            return []\\n        # Try to find a CSV fragment in the answer with correct columns\\n        # We'll catch both markdown and plain CSV\\n        # First line should have header including 'submission_id' etc\\n        expected_fields = [\\\"submission_id\\\", \\\"applicant_name\\\", \\\"email\\\", \\\"award_amount\\\", \\\"decision_date\\\"]\\n        pattern = r\\\"(?:submission_id\\\\s*,\\\\s*applicant_name\\\\s*,\\\\s*email\\\\s*,\\\\s*award_amount\\\\s*,\\\\s*decision_date[\\\\s\\\\S]+)\\\"\\n        m = re.search(pattern, ans_str, re.IGNORECASE)\\n        if not m:\\n            return []\\n        # Grab from start of header to end of table (stop at double newline or end)\\n        lines = []\\n        data_portion = ans_str[m.start():]\\n        # Accept to next double newline, or end of string\\n        for line in data_portion.splitlines():\\n            if line.strip() == '':\\n                break\\n            lines.append(line.strip())\\n        if not lines:\\n            return []\\n        # Parse via csv.reader, tolerate extra whitespace\\n        try:\\n            reader = csv.reader(lines)\\n            result = [tuple(cell.strip() for cell in row) for row in reader if any(cell.strip() for cell in row)]\\n            # skip header?\\n            fields_ = [h.lower().replace(' ','_') for h in result[0] ]\\n            if fields_[:n_fields] == expected_fields:\\n                return result[1:]\\n            else:\\n                return []\\n        except Exception:\\n            return []\\n\\n    # --- Begin logic ---\\n    # Step 1. Get new 'Fall 2026' cycle id if it exists in final DB\\n    cycle_id_final = get_fall2026_cycle_id(final_db_path)\\n    if not cycle_id_final:  # If agent never created the cycle\\n        # Accept only if initial and final DB both lack it, and there are no spurious records\\n        cycle_id_init = get_fall2026_cycle_id(initial_db_path)\\n        if cycle_id_init:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # Check that there are no new interview_campaigns, slots or emails in final\\n        has_interview_campaigns = bool(safe_query(final_db_path, \\\"SELECT 1 FROM interview_campaigns WHERE name LIKE 'Fall 2026%' LIMIT 1\\\"))\\n        has_interview_emails = bool(safe_query(final_db_path, \\\"SELECT 1 FROM email_outbox WHERE subject LIKE 'Interview Invitation%' AND cycle_id IS NULL LIMIT 1\\\"))\\n        if has_interview_campaigns or has_interview_emails:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        # If also no CSV was required, 'complete' only if there are zero 'Shortlisted' submissions for this cycle (should be, since cycle does not exist)\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    # Step 2. Find all Shortlisted submissions in FINAL DB for this cycle\\n    shortlisted = get_shortlisted_submissions(final_db_path, cycle_id_final)\\n    shortlisted_ids = [sid for sid, _ in shortlisted]\\n    # Step 2a. If there are zero shortlisted (possibly legitimate case), nothing else must have been created for this cycle\\n    if not shortlisted_ids:\\n        # Check slots and emails in the final for this cycle\\n        campaigns = safe_query(final_db_path, \\\"SELECT id FROM interview_campaigns WHERE cycle_id=?\\\", (cycle_id_final,))\\n        if campaigns:\\n            # Check if there are any interview slots\\n            slots = safe_query(final_db_path, \\\"SELECT 1 FROM interview_slots WHERE campaign_id IN (SELECT id FROM interview_campaigns WHERE cycle_id=?) LIMIT 1\\\", (cycle_id_final,))\\n            if slots:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        emails = safe_query(final_db_path, \\\"SELECT 1 FROM email_outbox WHERE cycle_id=? AND subject LIKE 'Interview Invitation%' LIMIT 1\\\", (cycle_id_final,))\\n        if emails:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    # Step 3. For every shortlisted submission, require:\\n    #  (a) An interview slot assigned (or reserved) for them, and slot time is correct\\n    #  (b) An email sent (status in sent/queued) with exact subject/body, to the right applicant\\n    # For slot/campaign lookup, allow the agent to create any number of interview_campaigns named any way, but the slots must match the date/hours\\n    slot_found_for_sub = {sid: False for sid in shortlisted_ids}\\n    slot_campaigns = get_interview_slots_for_cycle(final_db_path, cycle_id_final)\\n    assigned_submissions = set()\\n    for campaign_id, cam in slot_campaigns.items():\\n        # Accept campaign if ANY slot is within required window\\n        for slot in cam['slots']:\\n            slot_id, start_at, end_at, is_booked = slot\\n            assignment = get_interview_slot_assignments(final_db_path, campaign_id)\\n            subid = assignment.get(slot_id)\\n            if subid in slot_found_for_sub:\\n                if not slot_is_correct(start_at, end_at):\\n                    continue  # wrong slot\\n                # Only accept if this submission is uniquely mapped\\n                if slot_found_for_sub[subid]:\\n                    continue  # already found (double-book)\\n                slot_found_for_sub[subid] = True\\n                assigned_submissions.add(subid)\\n    # All must have a slot\\n    if not all(slot_found_for_sub.values()):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Step 4. Email check\\n    emails = get_interview_emails(final_db_path, cycle_id_final, shortlisted_ids)\\n    # Each must have one, sent or queued, recipient email == applicant's email\\n    # Get user emails\\n    user_emails = {u[0]: safe_query(final_db_path, \\\"SELECT email FROM users WHERE id=?\\\", (u[1],))[0][0] for u in shortlisted}\\n    email_for_sub = {e[0]: e for e in emails if e[4] in ('sent','queued') and e[2]=='Interview Invitation - STEM Scholars Grant'}\\n    if len(email_for_sub) != len(shortlisted_ids):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Check for exact recipient email\\n    for sid in shortlisted_ids:\\n        eml = email_for_sub.get(sid)\\n        if not eml:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if eml[1].strip().lower() != user_emails[sid].strip().lower():\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Step 5. CSV export out (from final_answer)\\n    if final_answer is not None:\\n        # Must export 'Approved' awardees for this cycle\\n        approved_rows = get_approved_submissions(final_db_path, cycle_id_final)\\n        parsed_csv = parse_csv_from_answer(final_answer, 5)  # skip header\\n        # To be certain, require that data matches exactly (excluding possible header)\\n        set_approved = set((str(sid), str(name), str(email).lower(), str(float(award_amt)).rstrip('0').rstrip('.') if award_amt is not None else '', str(date)) for sid,name,email,award_amt,date in approved_rows)\\n        set_csv = set((row[0], row[1], row[2].lower(), row[3].rstrip('0').rstrip('.'), row[4]) for row in parsed_csv)\\n        if set_approved != set_csv:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    # All checks passed\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "etsy_digital_downloads", "task_idx": 6, "task": "Find the top 5 listings in my shop by revenue for the date range 2026-01-01 to 2026-01-31 and return each listing title, units sold, gross revenue, fees, and net revenue.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    \n    # Helper: Safe DB query\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # 1. Compute per-listing metrics for shop 101 in the requested date range\n    START_DT = \"2026-01-01\"\n    END_DT = \"2026-01-31\"\n    shop_id = 101\n    \n    listings = safe_query(final_db_path, \"SELECT id, title FROM listings WHERE shop_id=?\", (shop_id,))\n    if not listings:\n        return {\"result\": \"others\"}\n    listing_id_to_title = {lid: title for lid, title in listings}\n    listing_metrics = {}\n    \n    # Collect orders for shop 101 in the date range\n    orders = safe_query(final_db_path, \"SELECT id FROM orders WHERE shop_id=? AND placed_at >= ? AND placed_at <= ?\", (shop_id, START_DT + \" 00:00:00\", END_DT + \" 23:59:59\"))\n    if not orders:\n        # It's possible (edge case) that the final_answer returns empty -- still answer must match DB\n        order_ids = set()\n    else:\n        order_ids = set(oid for oid, in orders)\n    \n    # Refund info\n    refund_map = {}  # order_id -> refund_amount\n    refund_rows = safe_query(final_db_path, \"SELECT order_id, amount FROM refunds WHERE order_id IN ({seq})\".format(seq=','.join(str(oid) for oid in order_ids)), ()) if order_ids else []\n    for row in refund_rows:\n        refund_map[row[0]] = row[1]\n    \n    # Collect order items for relevant orders\n    item_rows = safe_query(final_db_path, \"SELECT id, order_id, listing_id, quantity, unit_price_amount FROM order_items WHERE order_id IN ({seq})\".format(seq=','.join(str(oid) for oid in order_ids)), ()) if order_ids else []\n    # For each listing, accumulate units sold and gross revenue\n    listing_sold = {lid: 0 for lid in listing_id_to_title}\n    listing_gross = {lid: 0.0 for lid in listing_id_to_title}\n    listing_fee = {lid: 0.0 for lid in listing_id_to_title}\n    # Map order_id -> items\n    order_item_map = {}\n    for iid, oid, lid, qty, price in item_rows:\n        if lid in listing_id_to_title:\n            listing_sold[lid] += qty\n            listing_gross[lid] += price * qty\n        order_item_map.setdefault(oid, []).append((iid, lid, qty, price))\n    \n    # Per-order: discounts\n    applied_discount = {}  # order_id -> total discount amount\n    if order_ids:\n        disc_rows = safe_query(final_db_path, \"SELECT order_id, discount_amount FROM order_applied_discounts WHERE order_id IN ({seq})\".format(seq=','.join(str(oid) for oid in order_ids)), ())\n        for order_id, disc in disc_rows:\n            applied_discount.setdefault(order_id, 0.0)\n            applied_discount[order_id] += disc\n    \n    # Per-order: fee lines\n    fee_types = ('platform_fee','processing_fee')\n    order_fee_map = {}  # order_id -> total fee amount\n    if order_ids:\n        fee_rows = safe_query(final_db_path,\n            \"SELECT order_id, amount FROM order_fee_lines WHERE fee_type IN ('platform_fee','processing_fee') AND order_id IN ({seq})\".format(seq=','.join(str(oid) for oid in order_ids)), ())\n        for order_id, fee in fee_rows:\n            order_fee_map.setdefault(order_id, 0.0)\n            order_fee_map[order_id] += fee\n    \n    # Now, allocate fee/disc/refund per listing proportionally\n    listing_fee.clear()\n    listing_refund = {lid: 0.0 for lid in listing_id_to_title}\n    for oid in order_ids:\n        items = order_item_map.get(oid, [])\n        total = sum(qty * price for iid, lid, qty, price in items)\n        if total <= 0:\n            continue\n        # Per-item allocation\n        for iid, lid, qty, price in items:\n            share = (qty * price) / total if total > 0 else 0.0\n            # Fee\n            fee_amount = order_fee_map.get(oid, 0.0) * share\n            listing_fee[lid] = listing_fee.get(lid, 0.0) + fee_amount\n            # Refund\n            refund_amount = refund_map.get(oid, 0.0) * share\n            listing_refund[lid] = listing_refund.get(lid, 0.0) + refund_amount\n            # Discount\n            # Reduce gross revenue (not fee) if any\n            disc_amount = applied_discount.get(oid, 0.0) * share\n            listing_gross[lid] -= disc_amount\n            # Also subtract refund from gross revenue\n            listing_gross[lid] -= refund_amount\n    \n    # Calculate net revenue: gross - fee\n    listing_net = {}\n    for lid in listing_id_to_title:\n        # Defensive: if negative gross from extreme discount/refund, clamp at 0.0\n        gross = round(listing_gross.get(lid, 0.0), 2)\n        fee = round(listing_fee.get(lid, 0.0), 2)\n        net = round(gross - fee, 2)\n        if net < 0:\n            net = 0.0\n        listing_metrics[lid] = {\n            'title': listing_id_to_title[lid],\n            'units_sold': listing_sold.get(lid, 0),\n            'gross_revenue': gross,\n            'fees': fee,\n            'net_revenue': net\n        }\n    \n    # Only keep listings with units sold > 0 in range\n    sold_metrics = [d for d in listing_metrics.values() if d['units_sold'] > 0]\n    # Sort by gross_revenue descending\n    sold_metrics.sort(key=lambda d: (-d['gross_revenue'], d['title']))\n    top5_metrics = sold_metrics[:5]\n    expected_titles = [d['title'] for d in top5_metrics]\n    \n    # Build reference lookup\n    expected_listing_lookup = {d['title']: d for d in top5_metrics}\n    \n    # 2. Parse final_answer and extract up to 5 listing rows\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n    \n    # Try to parse tabular or itemized answers - allow separator | , : - tab\n    listing_row_pat = re.compile(\n        r\"^(?P<title>.+?)[,:|\\t-]+\\s*(?P<units>\\d+)\\s*(units\\s*sold)?[,:|\\t-]+\\s*\\$?(?P<gross>[\\d.]+)\\s*(gross\\s*revenue)?[,:|\\t-]+\\s*\\$?(?P<fees>[\\d.]+)\\s*(fees)?[,:|\\t-]+\\s*\\$?(?P<net>[\\d.]+)\\s*(net\\s*revenue)?\",\n        re.IGNORECASE | re.MULTILINE\n    )\n    # Accept loose variants; also match row formats in |, CSV, or bulleted lists\n    found_rows = []\n    for match in listing_row_pat.finditer(final_answer):\n        title = match.group('title').strip()\n        units = match.group('units')\n        gross = match.group('gross')\n        fees = match.group('fees')\n        net = match.group('net')\n        try:\n            units = int(units)\n            gross = float(gross)\n            fees = float(fees)\n            net = float(net)\n        except Exception:\n            continue  # ignore malformed row\n        found_rows.append({'title': title, 'units_sold': units, 'gross_revenue': gross, 'fees': fees, 'net_revenue': net})\n    \n    # If nothing found, try relaxed parsing (lines with all 5 fields)\n    if not found_rows:\n        loose_row_pat = re.compile(\n            r\"^(?P<title>.+?)[,:|\\t-]+.+?(?P<units>\\d+).+\\$?(?P<gross>[\\d.]+).+\\$?(?P<fees>[\\d.]+).+\\$?(?P<net>[\\d.]+)\",\n            re.IGNORECASE | re.MULTILINE\n        )\n        for match in loose_row_pat.finditer(final_answer):\n            title = match.group('title').strip()\n            units = match.group('units')\n            gross = match.group('gross')\n            fees = match.group('fees')\n            net = match.group('net')\n            try:\n                units = int(units)\n                gross = float(gross)\n                fees = float(fees)\n                net = float(net)\n            except Exception:\n                continue\n            found_rows.append({'title': title, 'units_sold': units, 'gross_revenue': gross, 'fees': fees, 'net_revenue': net})\n    \n    # Accept only up to first 5 unique listing titles\n    unique_titles = []\n    listing_rows = []\n    for row in found_rows:\n        if row['title'] not in unique_titles:\n            unique_titles.append(row['title'])\n            listing_rows.append(row)\n        if len(listing_rows) == 5:\n            break\n    \n    # Must have exactly 5 rows\n    if len(listing_rows) != 5:\n        return {\"result\": \"others\"}\n    \n    # Validate all fields match expected metrics\n    for idx, row in enumerate(listing_rows):\n        # Defensive: allow fuzzy title match\n        found = None\n        for ex_title in expected_listing_lookup:\n            # Case-insensitive, ignore parens/extra whitespace\n            if row['title'].strip().lower() == ex_title.strip().lower():\n                found = expected_listing_lookup[ex_title]\n                break\n        if not found:\n            # Try partial substring match if unique\n            for ex_title in expected_listing_lookup:\n                if ex_title.lower() in row['title'].lower() or row['title'].lower() in ex_title.lower():\n                    found = expected_listing_lookup[ex_title]\n                    break\n            if not found:\n                return {\"result\": \"others\"}\n        # Check per-field equality (round to 2 decimal places)\n        if row['units_sold'] != found['units_sold']:\n            return {\"result\": \"others\"}\n        if abs(row['gross_revenue'] - found['gross_revenue']) > 0.01:\n            return {\"result\": \"others\"}\n        if abs(row['fees'] - found['fees']) > 0.01:\n            return {\"result\": \"others\"}\n        if abs(row['net_revenue'] - found['net_revenue']) > 0.01:\n            return {\"result\": \"others\"}\n    \n    # Validate ranking order (gross revenue descending)\n    prev = None\n    for row in listing_rows:\n        cur = row['gross_revenue']\n        if prev is not None:\n            if cur > prev:  # must not increase\n                return {\"result\": \"others\"}\n        prev = cur\n    \n    # All criteria met!\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"The task is to find and return the top 5 listings in the user's shop ranked by gross revenue for the specified date range (2026-01-01 to 2026-01-31), including their title, units sold, gross revenue, fees, and net revenue. To verify completion: (1) Extract the expected data from the final_answer, (2) Calculate these values directly from the final_db for all listings in shop 101, (3) Confirm the final_answer provides exactly 5 listings, with all fields present and matching the database-calculated values for each (including all fee, discount, refund logic), and (4) Ensure the listings are correctly ranked by gross revenue. Any deviation or missing information results in 'others'.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Extract up to 5 listing rows from final_answer; ensuring each has title, units sold, gross revenue, fees, net revenue\",\n        \"For each listing in shop 101, compute units sold, gross revenue, sum of relevant fees, net revenue for orders placed between 2026-01-01 and 2026-01-31\",\n        \"Account for discounts and refunds in all calculations\",\n        \"Validate that the listings and numeric values in final_answer exactly match database values for the same date range\",\n        \"Check that the final_answer lists exactly 5 listings, and ranks them by gross revenue descending\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    \\n    # Helper: Safe DB query\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # 1. Compute per-listing metrics for shop 101 in the requested date range\\n    START_DT = \\\"2026-01-01\\\"\\n    END_DT = \\\"2026-01-31\\\"\\n    shop_id = 101\\n    \\n    listings = safe_query(final_db_path, \\\"SELECT id, title FROM listings WHERE shop_id=?\\\", (shop_id,))\\n    if not listings:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    listing_id_to_title = {lid: title for lid, title in listings}\\n    listing_metrics = {}\\n    \\n    # Collect orders for shop 101 in the date range\\n    orders = safe_query(final_db_path, \\\"SELECT id FROM orders WHERE shop_id=? AND placed_at >= ? AND placed_at <= ?\\\", (shop_id, START_DT + \\\" 00:00:00\\\", END_DT + \\\" 23:59:59\\\"))\\n    if not orders:\\n        # It's possible (edge case) that the final_answer returns empty -- still answer must match DB\\n        order_ids = set()\\n    else:\\n        order_ids = set(oid for oid, in orders)\\n    \\n    # Refund info\\n    refund_map = {}  # order_id -> refund_amount\\n    refund_rows = safe_query(final_db_path, \\\"SELECT order_id, amount FROM refunds WHERE order_id IN ({seq})\\\".format(seq=','.join(str(oid) for oid in order_ids)), ()) if order_ids else []\\n    for row in refund_rows:\\n        refund_map[row[0]] = row[1]\\n    \\n    # Collect order items for relevant orders\\n    item_rows = safe_query(final_db_path, \\\"SELECT id, order_id, listing_id, quantity, unit_price_amount FROM order_items WHERE order_id IN ({seq})\\\".format(seq=','.join(str(oid) for oid in order_ids)), ()) if order_ids else []\\n    # For each listing, accumulate units sold and gross revenue\\n    listing_sold = {lid: 0 for lid in listing_id_to_title}\\n    listing_gross = {lid: 0.0 for lid in listing_id_to_title}\\n    listing_fee = {lid: 0.0 for lid in listing_id_to_title}\\n    # Map order_id -> items\\n    order_item_map = {}\\n    for iid, oid, lid, qty, price in item_rows:\\n        if lid in listing_id_to_title:\\n            listing_sold[lid] += qty\\n            listing_gross[lid] += price * qty\\n        order_item_map.setdefault(oid, []).append((iid, lid, qty, price))\\n    \\n    # Per-order: discounts\\n    applied_discount = {}  # order_id -> total discount amount\\n    if order_ids:\\n        disc_rows = safe_query(final_db_path, \\\"SELECT order_id, discount_amount FROM order_applied_discounts WHERE order_id IN ({seq})\\\".format(seq=','.join(str(oid) for oid in order_ids)), ())\\n        for order_id, disc in disc_rows:\\n            applied_discount.setdefault(order_id, 0.0)\\n            applied_discount[order_id] += disc\\n    \\n    # Per-order: fee lines\\n    fee_types = ('platform_fee','processing_fee')\\n    order_fee_map = {}  # order_id -> total fee amount\\n    if order_ids:\\n        fee_rows = safe_query(final_db_path,\\n            \\\"SELECT order_id, amount FROM order_fee_lines WHERE fee_type IN ('platform_fee','processing_fee') AND order_id IN ({seq})\\\".format(seq=','.join(str(oid) for oid in order_ids)), ())\\n        for order_id, fee in fee_rows:\\n            order_fee_map.setdefault(order_id, 0.0)\\n            order_fee_map[order_id] += fee\\n    \\n    # Now, allocate fee/disc/refund per listing proportionally\\n    listing_fee.clear()\\n    listing_refund = {lid: 0.0 for lid in listing_id_to_title}\\n    for oid in order_ids:\\n        items = order_item_map.get(oid, [])\\n        total = sum(qty * price for iid, lid, qty, price in items)\\n        if total <= 0:\\n            continue\\n        # Per-item allocation\\n        for iid, lid, qty, price in items:\\n            share = (qty * price) / total if total > 0 else 0.0\\n            # Fee\\n            fee_amount = order_fee_map.get(oid, 0.0) * share\\n            listing_fee[lid] = listing_fee.get(lid, 0.0) + fee_amount\\n            # Refund\\n            refund_amount = refund_map.get(oid, 0.0) * share\\n            listing_refund[lid] = listing_refund.get(lid, 0.0) + refund_amount\\n            # Discount\\n            # Reduce gross revenue (not fee) if any\\n            disc_amount = applied_discount.get(oid, 0.0) * share\\n            listing_gross[lid] -= disc_amount\\n            # Also subtract refund from gross revenue\\n            listing_gross[lid] -= refund_amount\\n    \\n    # Calculate net revenue: gross - fee\\n    listing_net = {}\\n    for lid in listing_id_to_title:\\n        # Defensive: if negative gross from extreme discount/refund, clamp at 0.0\\n        gross = round(listing_gross.get(lid, 0.0), 2)\\n        fee = round(listing_fee.get(lid, 0.0), 2)\\n        net = round(gross - fee, 2)\\n        if net < 0:\\n            net = 0.0\\n        listing_metrics[lid] = {\\n            'title': listing_id_to_title[lid],\\n            'units_sold': listing_sold.get(lid, 0),\\n            'gross_revenue': gross,\\n            'fees': fee,\\n            'net_revenue': net\\n        }\\n    \\n    # Only keep listings with units sold > 0 in range\\n    sold_metrics = [d for d in listing_metrics.values() if d['units_sold'] > 0]\\n    # Sort by gross_revenue descending\\n    sold_metrics.sort(key=lambda d: (-d['gross_revenue'], d['title']))\\n    top5_metrics = sold_metrics[:5]\\n    expected_titles = [d['title'] for d in top5_metrics]\\n    \\n    # Build reference lookup\\n    expected_listing_lookup = {d['title']: d for d in top5_metrics}\\n    \\n    # 2. Parse final_answer and extract up to 5 listing rows\\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Try to parse tabular or itemized answers - allow separator | , : - tab\\n    listing_row_pat = re.compile(\\n        r\\\"^(?P<title>.+?)[,:|\\\\t-]+\\\\s*(?P<units>\\\\d+)\\\\s*(units\\\\s*sold)?[,:|\\\\t-]+\\\\s*\\\\$?(?P<gross>[\\\\d.]+)\\\\s*(gross\\\\s*revenue)?[,:|\\\\t-]+\\\\s*\\\\$?(?P<fees>[\\\\d.]+)\\\\s*(fees)?[,:|\\\\t-]+\\\\s*\\\\$?(?P<net>[\\\\d.]+)\\\\s*(net\\\\s*revenue)?\\\",\\n        re.IGNORECASE | re.MULTILINE\\n    )\\n    # Accept loose variants; also match row formats in |, CSV, or bulleted lists\\n    found_rows = []\\n    for match in listing_row_pat.finditer(final_answer):\\n        title = match.group('title').strip()\\n        units = match.group('units')\\n        gross = match.group('gross')\\n        fees = match.group('fees')\\n        net = match.group('net')\\n        try:\\n            units = int(units)\\n            gross = float(gross)\\n            fees = float(fees)\\n            net = float(net)\\n        except Exception:\\n            continue  # ignore malformed row\\n        found_rows.append({'title': title, 'units_sold': units, 'gross_revenue': gross, 'fees': fees, 'net_revenue': net})\\n    \\n    # If nothing found, try relaxed parsing (lines with all 5 fields)\\n    if not found_rows:\\n        loose_row_pat = re.compile(\\n            r\\\"^(?P<title>.+?)[,:|\\\\t-]+.+?(?P<units>\\\\d+).+\\\\$?(?P<gross>[\\\\d.]+).+\\\\$?(?P<fees>[\\\\d.]+).+\\\\$?(?P<net>[\\\\d.]+)\\\",\\n            re.IGNORECASE | re.MULTILINE\\n        )\\n        for match in loose_row_pat.finditer(final_answer):\\n            title = match.group('title').strip()\\n            units = match.group('units')\\n            gross = match.group('gross')\\n            fees = match.group('fees')\\n            net = match.group('net')\\n            try:\\n                units = int(units)\\n                gross = float(gross)\\n                fees = float(fees)\\n                net = float(net)\\n            except Exception:\\n                continue\\n            found_rows.append({'title': title, 'units_sold': units, 'gross_revenue': gross, 'fees': fees, 'net_revenue': net})\\n    \\n    # Accept only up to first 5 unique listing titles\\n    unique_titles = []\\n    listing_rows = []\\n    for row in found_rows:\\n        if row['title'] not in unique_titles:\\n            unique_titles.append(row['title'])\\n            listing_rows.append(row)\\n        if len(listing_rows) == 5:\\n            break\\n    \\n    # Must have exactly 5 rows\\n    if len(listing_rows) != 5:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Validate all fields match expected metrics\\n    for idx, row in enumerate(listing_rows):\\n        # Defensive: allow fuzzy title match\\n        found = None\\n        for ex_title in expected_listing_lookup:\\n            # Case-insensitive, ignore parens/extra whitespace\\n            if row['title'].strip().lower() == ex_title.strip().lower():\\n                found = expected_listing_lookup[ex_title]\\n                break\\n        if not found:\\n            # Try partial substring match if unique\\n            for ex_title in expected_listing_lookup:\\n                if ex_title.lower() in row['title'].lower() or row['title'].lower() in ex_title.lower():\\n                    found = expected_listing_lookup[ex_title]\\n                    break\\n            if not found:\\n                return {\\\"result\\\": \\\"others\\\"}\\n        # Check per-field equality (round to 2 decimal places)\\n        if row['units_sold'] != found['units_sold']:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if abs(row['gross_revenue'] - found['gross_revenue']) > 0.01:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if abs(row['fees'] - found['fees']) > 0.01:\\n            return {\\\"result\\\": \\\"others\\\"}\\n        if abs(row['net_revenue'] - found['net_revenue']) > 0.01:\\n            return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # Validate ranking order (gross revenue descending)\\n    prev = None\\n    for row in listing_rows:\\n        cur = row['gross_revenue']\\n        if prev is not None:\\n            if cur > prev:  # must not increase\\n                return {\\\"result\\\": \\\"others\\\"}\\n        prev = cur\\n    \\n    # All criteria met!\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "gofundme", "task_idx": 4, "task": "Create a one-time donation intent of 75 USD to the campaign \"Community Food Pantry Restock\" with donor name \"Alex Kim\", a public message \"Happy to helpthank you for feeding our neighbors!\", and set anonymity to false.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    \n    # Constants for task requirements\n    CAMPAIGN_TITLE = \"Community Food Pantry Restock\"\n    DONOR_NAME = \"Alex Kim\"\n    MESSAGE = \"Happy to helpthank you for feeding our neighbors!\"\n    IS_ANONYMOUS = 0  # False\n    AMOUNT_CENTS = 7500\n    KIND = \"one_time\"\n    CURRENCY = \"USD\"\n    # Status could be 'active' or 'completed' (intent is created, may be completed immediately)\n    \n    def norm(x):\n        # normalize for comparison (case, whitespace, dashes)\n        if isinstance(x, str):\n            return x.strip().replace('', '-')\n        return x\n\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            results = cursor.fetchall()\n            conn.close()\n            return results\n        except Exception:\n            return []\n    \n    # Step 1: Get campaign_id for campaign title\n    final_campaigns = safe_query(final_db_path, \n        \"SELECT id FROM campaigns WHERE title = ? LIMIT 1\", (CAMPAIGN_TITLE,))\n    if not final_campaigns or not isinstance(final_campaigns[0][0], int):\n        return {\"result\": \"others\"}\n    campaign_id = final_campaigns[0][0]\n    \n    # Step 2: Look for matching donation intent in FINAL db\n    final_intents = safe_query(\n        final_db_path,\n        \"SELECT donor_name, message, amount_cents, kind, currency_code, is_anonymous, status FROM donation_intents WHERE campaign_id = ?\",\n        (campaign_id,)\n    )\n    # Find matching row(s)\n    matches = [\n        row for row in final_intents\n        if (\n            norm(row[0]) == norm(DONOR_NAME)\n            and norm(row[1]) == norm(MESSAGE)\n            and row[2] == AMOUNT_CENTS\n            and row[3] == KIND\n            and row[4] == CURRENCY\n            and row[5] == IS_ANONYMOUS\n            and row[6] in (\"active\", \"completed\")\n        )\n    ]\n    if not matches:\n        return {\"result\": \"others\"}\n    # There must be at least one matching donation intent\n    # Step 3: Ensure this did NOT exist in initial_db\n    initial_intents = safe_query(\n        initial_db_path,\n        \"SELECT donor_name, message, amount_cents, kind, currency_code, is_anonymous, status FROM donation_intents WHERE campaign_id = ?\",\n        (campaign_id,)\n    )\n    for row in initial_intents:\n        if (\n            norm(row[0]) == norm(DONOR_NAME)\n            and norm(row[1]) == norm(MESSAGE)\n            and row[2] == AMOUNT_CENTS\n            and row[3] == KIND\n            and row[4] == CURRENCY\n            and row[5] == IS_ANONYMOUS\n            and row[6] in (\"active\", \"completed\")\n        ):\n            # This already existed before agent acted\n            return {\"result\": \"others\"}\n    \n    # All required checks satisfied exactly\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"This task asks to verify that the agent created a one-time donation intent of 75 USD (7500 cents) for the campaign \\\"Community Food Pantry Restock\\\" with donor name \\\"Alex Kim\\\", public message \\\"Happy to helpthank you for feeding our neighbors!\\\", and anonymity set to false. The verification must establish that, in the final state, this donation intent appears in the donation_intents table and was NOT present in the initial state. All values must match exactly and the intent must be for this specific campaign, donor, amount, anonymity, and message. Only modification of database is relevant; final_answer is ignored. The completion check requires: (1) finding the correct campaign_id, (2) confirming no such donation intent exists in initial_db, (3) confirming exact presence in final_db, (4) checking all fields for exact match (one_time, USD, 7500 cents, public message, not anonymous, completed or active status). If any ambiguity or mismatch, return 'others'.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Find campaign_id for 'Community Food Pantry Restock'\",\n        \"Ensure no matching donation intent (kind, donor_name, message, anonymity, amount) existed in initial_db\",\n        \"Check that a new donation intent matching all requirements exists in final_db\",\n        \"Validate donor_name, message, is_anonymous, kind ('one_time'), currency_code ('USD'), amount_cents (7500), status ('active' or 'completed')\",\n        \"Handle any missing, malformed, or ambiguous data gracefully\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    \\n    # Constants for task requirements\\n    CAMPAIGN_TITLE = \\\"Community Food Pantry Restock\\\"\\n    DONOR_NAME = \\\"Alex Kim\\\"\\n    MESSAGE = \\\"Happy to helpthank you for feeding our neighbors!\\\"\\n    IS_ANONYMOUS = 0  # False\\n    AMOUNT_CENTS = 7500\\n    KIND = \\\"one_time\\\"\\n    CURRENCY = \\\"USD\\\"\\n    # Status could be 'active' or 'completed' (intent is created, may be completed immediately)\\n    \\n    def norm(x):\\n        # normalize for comparison (case, whitespace, dashes)\\n        if isinstance(x, str):\\n            return x.strip().replace('', '-')\\n        return x\\n\\n    def safe_query(db_path: str, query: str, params: tuple = ()) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            results = cursor.fetchall()\\n            conn.close()\\n            return results\\n        except Exception:\\n            return []\\n    \\n    # Step 1: Get campaign_id for campaign title\\n    final_campaigns = safe_query(final_db_path, \\n        \\\"SELECT id FROM campaigns WHERE title = ? LIMIT 1\\\", (CAMPAIGN_TITLE,))\\n    if not final_campaigns or not isinstance(final_campaigns[0][0], int):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    campaign_id = final_campaigns[0][0]\\n    \\n    # Step 2: Look for matching donation intent in FINAL db\\n    final_intents = safe_query(\\n        final_db_path,\\n        \\\"SELECT donor_name, message, amount_cents, kind, currency_code, is_anonymous, status FROM donation_intents WHERE campaign_id = ?\\\",\\n        (campaign_id,)\\n    )\\n    # Find matching row(s)\\n    matches = [\\n        row for row in final_intents\\n        if (\\n            norm(row[0]) == norm(DONOR_NAME)\\n            and norm(row[1]) == norm(MESSAGE)\\n            and row[2] == AMOUNT_CENTS\\n            and row[3] == KIND\\n            and row[4] == CURRENCY\\n            and row[5] == IS_ANONYMOUS\\n            and row[6] in (\\\"active\\\", \\\"completed\\\")\\n        )\\n    ]\\n    if not matches:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # There must be at least one matching donation intent\\n    # Step 3: Ensure this did NOT exist in initial_db\\n    initial_intents = safe_query(\\n        initial_db_path,\\n        \\\"SELECT donor_name, message, amount_cents, kind, currency_code, is_anonymous, status FROM donation_intents WHERE campaign_id = ?\\\",\\n        (campaign_id,)\\n    )\\n    for row in initial_intents:\\n        if (\\n            norm(row[0]) == norm(DONOR_NAME)\\n            and norm(row[1]) == norm(MESSAGE)\\n            and row[2] == AMOUNT_CENTS\\n            and row[3] == KIND\\n            and row[4] == CURRENCY\\n            and row[5] == IS_ANONYMOUS\\n            and row[6] in (\\\"active\\\", \\\"completed\\\")\\n        ):\\n            # This already existed before agent acted\\n            return {\\\"result\\\": \\\"others\\\"}\\n    \\n    # All required checks satisfied exactly\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "samsara_fleet_asset_maintenance_management", "task_idx": 6, "task": "Create a preventive maintenance schedule for 'Truck-12' called 'Oil Change' due every 7,500 miles or 250 engine hours, with the next due at odometer 52,500 and engine hours 2,350, and enable due-soon notifications 500 miles/20 hours ahead.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n\n    # Helper to safely query database\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            rows = cursor.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n    \n    # FIELD REQUIREMENTS\n    req = {\n        'name': 'Oil Change',\n        'interval_miles': 7500,\n        'interval_engine_hours': 250.0,\n        'next_due_odometer_miles': 52500,\n        'next_due_engine_hours': 2350.0,\n        'due_soon_miles': 500,\n        'due_soon_engine_hours': 20.0,\n        'enabled': 1\n    }\n    # Find Truck-12 vehicle_id in both DBs\n    vehicle_id_init = None\n    vehicle_id_final = None\n    rows_init = safe_query(initial_db_path, \"SELECT id FROM vehicles WHERE name=?\", (\"Truck-12\",))\n    rows_final = safe_query(final_db_path, \"SELECT id FROM vehicles WHERE name=?\", (\"Truck-12\",))\n    if not rows_init or not rows_final:\n        return {\"result\": \"others\"}\n    vehicle_id_init = rows_init[0][0]\n    vehicle_id_final = rows_final[0][0]\n    # They should be identical, but check both for robustness\n    if vehicle_id_init != vehicle_id_final:\n        return {\"result\": \"others\"}\n    vehicle_id = vehicle_id_final\n    # Check for any enabled schedule named Oil Change for Truck-12 that matches ALL of the required fields in the final db\n    # For floats, we use absolute tolerance\n    def find_exact_schedule(db_path, vehicle_id, req):\n        query = '''SELECT id, interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled FROM maintenance_schedules WHERE vehicle_id=? AND name=?'''\n        schedules = safe_query(db_path, query, (vehicle_id, req['name']))\n        results = []\n        for row in schedules:\n            (\n                _id, interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours,\n                due_soon_miles, due_soon_engine_hours, enabled\n            ) = row\n            # Defensive: handle nulls\n            # interval_miles, next_due_odometer_miles, due_soon_miles INT; interval_engine_hours, next_due_engine_hours, due_soon_engine_hours FLOAT\n            # Must match ALL values, with tolerance for floats\n            def feq(x, y, tol=1e-2):\n                try:\n                    return x is not None and y is not None and abs(float(x)-float(y)) <= tol\n                except Exception:\n                    return False\n            match = (\n                interval_miles == req['interval_miles'] and\n                feq(interval_engine_hours, req['interval_engine_hours']) and\n                next_due_odometer_miles == req['next_due_odometer_miles'] and\n                feq(next_due_engine_hours, req['next_due_engine_hours']) and\n                due_soon_miles == req['due_soon_miles'] and\n                feq(due_soon_engine_hours, req['due_soon_engine_hours']) and\n                enabled == req['enabled']\n            )\n            if match:\n                results.append(_id)\n        return results\n    # Now, get matching schedule(s) in final db\n    correct_final = find_exact_schedule(final_db_path, vehicle_id, req)\n    if len(correct_final) != 1:\n        # There should be exactly one correct enabled matching schedule\n        return {\"result\": \"others\"}\n    # Now verify that in the initial db, there was not a schedule with these exact settings\n    correct_initial = find_exact_schedule(initial_db_path, vehicle_id, req)\n    if len(correct_initial) == 0:\n        # OK, creation case: did not exist before, now exists.\n        return {\"result\": \"complete\"}\n    # If there WAS such a schedule in the initial db, it is not new, so fail\n    # If there was an Oil Change for Truck-12 that did NOT match all the requirements, but now does, that's an update. Check if any such entries existed\n    # We'll allow for update if ALL 'Oil Change' entries for Truck-12 in the initial db did NOT match ALL requirements\n    def other_schedules_differ(db_path, vehicle_id, req):\n        query = '''SELECT interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled FROM maintenance_schedules WHERE vehicle_id=? AND name=?'''\n        schedules = safe_query(db_path, query, (vehicle_id, req['name']))\n        for row in schedules:\n            interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled = row\n            def feq(x, y, tol=1e-2):\n                try:\n                    return x is not None and y is not None and abs(float(x)-float(y)) <= tol\n                except Exception:\n                    return False\n            match = (\n                interval_miles == req['interval_miles'] and\n                feq(interval_engine_hours, req['interval_engine_hours']) and\n                next_due_odometer_miles == req['next_due_odometer_miles'] and\n                feq(next_due_engine_hours, req['next_due_engine_hours']) and\n                due_soon_miles == req['due_soon_miles'] and\n                feq(due_soon_engine_hours, req['due_soon_engine_hours']) and\n                enabled == req['enabled']\n            )\n            if match:\n                return False  # Found a match: can't be an 'update' case\n        return True\n    if other_schedules_differ(initial_db_path, vehicle_id, req):\n        # There were 'Oil Change' schedules but none matched exactly; now one does, so update is ok\n        return {\"result\": \"complete\"}\n    # All other cases: uncertain or duplicate/conflicting schedules\n    return {\"result\": \"others\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify this task, we must determine if the agent created a new (or updated an existing) preventive maintenance schedule for 'Truck-12' named 'Oil Change' with the required settings: intervals of 7,500 miles OR 250 engine hours, next due at odometer 52,500 and engine hours 2,350, and due-soon notifications enabled 500 miles and 20 hours ahead. We must compare the initial and final db states, and ensure the schedule appears after but not before; OR, if updating, that values in the schedule changed from not matching to matching. All key fields must match exactly (including enabled=1). No extra schedules for Truck-12 with these settings are allowed unless an update scenario (from non-matching to matching) is clearly detectable. We must ensure the modification was not spurious. Other tables are not relevant.\",\n    \"verification_strategy\": \"modification_based\",\n    \"key_checks\": [\n        \"Identify 'Truck-12' vehicle_id in both DBs\",\n        \"Check if exactly ONE enabled schedule named 'Oil Change' for 'Truck-12' matches ALL required constraints in the FINAL db\",\n        \"Check that in the INITIAL db, NO such enabled schedule exists for 'Truck-12' matching all required fields\",\n        \"If there was an 'Oil Change' schedule for 'Truck-12' in the initial db, verify it did NOT meet all required values but does in the final db (i.e., updated, not preexisting)\",\n        \"Verify all relevant fields (interval_miles = 7500, interval_engine_hours = 250, next_due_odometer_miles = 52500, next_due_engine_hours = 2350, due_soon_miles = 500, due_soon_engine_hours = 20, enabled = 1, etc.)\",\n        \"Return 'complete' only if and ONLY if the schedule is present and correct ONLY in the final DB\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n\\n    # Helper to safely query database\\n    def safe_query(db_path: str, query: str, params: tuple = ( )) -> list:\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cursor = conn.cursor()\\n            cursor.execute(query, params)\\n            rows = cursor.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n    \\n    # FIELD REQUIREMENTS\\n    req = {\\n        'name': 'Oil Change',\\n        'interval_miles': 7500,\\n        'interval_engine_hours': 250.0,\\n        'next_due_odometer_miles': 52500,\\n        'next_due_engine_hours': 2350.0,\\n        'due_soon_miles': 500,\\n        'due_soon_engine_hours': 20.0,\\n        'enabled': 1\\n    }\\n    # Find Truck-12 vehicle_id in both DBs\\n    vehicle_id_init = None\\n    vehicle_id_final = None\\n    rows_init = safe_query(initial_db_path, \\\"SELECT id FROM vehicles WHERE name=?\\\", (\\\"Truck-12\\\",))\\n    rows_final = safe_query(final_db_path, \\\"SELECT id FROM vehicles WHERE name=?\\\", (\\\"Truck-12\\\",))\\n    if not rows_init or not rows_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id_init = rows_init[0][0]\\n    vehicle_id_final = rows_final[0][0]\\n    # They should be identical, but check both for robustness\\n    if vehicle_id_init != vehicle_id_final:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    vehicle_id = vehicle_id_final\\n    # Check for any enabled schedule named Oil Change for Truck-12 that matches ALL of the required fields in the final db\\n    # For floats, we use absolute tolerance\\n    def find_exact_schedule(db_path, vehicle_id, req):\\n        query = '''SELECT id, interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled FROM maintenance_schedules WHERE vehicle_id=? AND name=?'''\\n        schedules = safe_query(db_path, query, (vehicle_id, req['name']))\\n        results = []\\n        for row in schedules:\\n            (\\n                _id, interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours,\\n                due_soon_miles, due_soon_engine_hours, enabled\\n            ) = row\\n            # Defensive: handle nulls\\n            # interval_miles, next_due_odometer_miles, due_soon_miles INT; interval_engine_hours, next_due_engine_hours, due_soon_engine_hours FLOAT\\n            # Must match ALL values, with tolerance for floats\\n            def feq(x, y, tol=1e-2):\\n                try:\\n                    return x is not None and y is not None and abs(float(x)-float(y)) <= tol\\n                except Exception:\\n                    return False\\n            match = (\\n                interval_miles == req['interval_miles'] and\\n                feq(interval_engine_hours, req['interval_engine_hours']) and\\n                next_due_odometer_miles == req['next_due_odometer_miles'] and\\n                feq(next_due_engine_hours, req['next_due_engine_hours']) and\\n                due_soon_miles == req['due_soon_miles'] and\\n                feq(due_soon_engine_hours, req['due_soon_engine_hours']) and\\n                enabled == req['enabled']\\n            )\\n            if match:\\n                results.append(_id)\\n        return results\\n    # Now, get matching schedule(s) in final db\\n    correct_final = find_exact_schedule(final_db_path, vehicle_id, req)\\n    if len(correct_final) != 1:\\n        # There should be exactly one correct enabled matching schedule\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Now verify that in the initial db, there was not a schedule with these exact settings\\n    correct_initial = find_exact_schedule(initial_db_path, vehicle_id, req)\\n    if len(correct_initial) == 0:\\n        # OK, creation case: did not exist before, now exists.\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    # If there WAS such a schedule in the initial db, it is not new, so fail\\n    # If there was an Oil Change for Truck-12 that did NOT match all the requirements, but now does, that's an update. Check if any such entries existed\\n    # We'll allow for update if ALL 'Oil Change' entries for Truck-12 in the initial db did NOT match ALL requirements\\n    def other_schedules_differ(db_path, vehicle_id, req):\\n        query = '''SELECT interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled FROM maintenance_schedules WHERE vehicle_id=? AND name=?'''\\n        schedules = safe_query(db_path, query, (vehicle_id, req['name']))\\n        for row in schedules:\\n            interval_miles, interval_engine_hours, next_due_odometer_miles, next_due_engine_hours, due_soon_miles, due_soon_engine_hours, enabled = row\\n            def feq(x, y, tol=1e-2):\\n                try:\\n                    return x is not None and y is not None and abs(float(x)-float(y)) <= tol\\n                except Exception:\\n                    return False\\n            match = (\\n                interval_miles == req['interval_miles'] and\\n                feq(interval_engine_hours, req['interval_engine_hours']) and\\n                next_due_odometer_miles == req['next_due_odometer_miles'] and\\n                feq(next_due_engine_hours, req['next_due_engine_hours']) and\\n                due_soon_miles == req['due_soon_miles'] and\\n                feq(due_soon_engine_hours, req['due_soon_engine_hours']) and\\n                enabled == req['enabled']\\n            )\\n            if match:\\n                return False  # Found a match: can't be an 'update' case\\n        return True\\n    if other_schedules_differ(initial_db_path, vehicle_id, req):\\n        # There were 'Oil Change' schedules but none matched exactly; now one does, so update is ok\\n        return {\\\"result\\\": \\\"complete\\\"}\\n    # All other cases: uncertain or duplicate/conflicting schedules\\n    return {\\\"result\\\": \\\"others\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
{"scenario": "fortnite_item_shop", "task_idx": 2, "task": "For the offer named 'Crimson Strike', fetch the full preview metadata (description, rarity, set name, included styles/variants, and image URLs) and return it as a structured object.", "verification": {"code": "def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\n    import sqlite3\n    import re\n    import json\n\n    # Helper: normalize strings for comparison\n    def normalize(s):\n        return s.strip().lower() if isinstance(s, str) else s\n\n    # Helper: Query DB safely\n    def safe_query(db_path, query, params=()):\n        try:\n            conn = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n            cur = conn.cursor()\n            cur.execute(query, params)\n            rows = cur.fetchall()\n            conn.close()\n            return rows\n        except Exception:\n            return []\n\n    # Step 1: Get Crimson Strike metadata from DB\n    item_row = safe_query(final_db_path, \"SELECT id, description, rarity, set_name FROM items WHERE name=?\", (\"Crimson Strike\",))\n    if not item_row or len(item_row[0]) < 4:\n        return {\"result\": \"others\"}\n    item_id, db_description, db_rarity, db_set_name = item_row[0][0], item_row[0][1], item_row[0][2], item_row[0][3]\n    if not item_id:\n        return {\"result\": \"others\"}\n\n    # Variants/styles\n    variants = safe_query(final_db_path, \"SELECT variant_name, variant_type FROM item_variants WHERE item_id=? ORDER BY sort_order ASC\", (item_id,))\n    db_variants = []\n    for v in variants:\n        name, vtype = v[0], v[1] if v[1] else None\n        db_variants.append({\"name\": name, \"type\": vtype})\n\n    # Images\n    images = safe_query(final_db_path, \"SELECT image_type, url FROM item_images WHERE item_id=? ORDER BY sort_order ASC\", (item_id,))\n    db_images = {}\n    for t, url in images:\n        db_images[t] = url\n\n    item_md = {\n        \"description\": db_description,\n        \"rarity\": db_rarity,\n        \"set_name\": db_set_name,\n        \"variants\": db_variants,\n        \"images\": db_images\n    }\n\n    # Step 2: Parse agent answer for structured metadata\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\n        return {\"result\": \"others\"}\n\n    # Try to parse JSON/dict from final_answer\n    ans_md = None\n    try:\n        # Replace single quotes with double quotes safely for JSON parsing\n        cleaned = final_answer.strip()\n        if cleaned.startswith('{') and cleaned.endswith('}'):  # Likely JSON-like\n            # Avoid reckless replacements\n            try:\n                ans_md = json.loads(cleaned)\n            except:\n                # Try to parse after changing single quotes to double quotes\n                cleaned = re.sub(r\"'(.*?)'\", r'\"\\1\"', cleaned)\n                try:\n                    ans_md = json.loads(cleaned)\n                except:\n                    ans_md = None\n    except Exception:\n        ans_md = None\n\n    # If not parseable, try regex extraction for all fields\n    if ans_md is None:\n        fields = {}\n        # Description\n        m = re.search(r\"description\\s*[:=]\\s*['\\\"]?(.*?)[\\n,}]\", final_answer, re.IGNORECASE)\n        if m:\n            fields['description'] = m.group(1).strip()\n        # Rarity\n        m = re.search(r\"rarity\\s*[:=]\\s*['\\\"]?(\\w+)\", final_answer, re.IGNORECASE)\n        if m:\n            fields['rarity'] = m.group(1).strip()\n        # Set Name\n        m = re.search(r\"set[_\\s]?name\\s*[:=]\\s*['\\\"]?(.*?)[\\n,}]\", final_answer, re.IGNORECASE)\n        if m:\n            fields['set_name'] = m.group(1).strip()\n        # Variants/styles (try to extract as list)\n        # Look for key \"variants\", \"styles\", or something similar\n        m = re.search(r\"(?:variants|styles|included variants|included styles)\\s*[:=]\\s*\\[([\\s\\S]*?)\\]\", final_answer, re.IGNORECASE)\n        variants = []\n        if m:\n            variants_raw = m.group(1)\n            variants = re.findall(r\"['\\\"]?(.*?)[,'\\\"]\", variants_raw)\n        else:\n            # Try individual lines\n            variants = re.findall(r\"-\\s*([A-Za-z0-9 \\-']+)\", final_answer)\n        fields['variants'] = [v.strip() for v in variants if v.strip()]\n        # Image URLs\n        images = {}\n        for img_type in ['icon', 'featured', 'background']:\n            m = re.search(rf\"{img_type}.*?url\\s*[:=]\\s*['\\\"](https?://[\\w./\\-]+)\", final_answer, re.IGNORECASE)\n            if m:\n                images[img_type] = m.group(1)\n            else:\n                # Try loose capture\n                m = re.search(rf\"{img_type}.*?(https?://[\\w./\\-]+)\", final_answer, re.IGNORECASE)\n                if m:\n                    images[img_type] = m.group(1)\n        fields['images'] = images\n        ans_md = fields\n\n    # Step 3: Validate ALL fields are present and correct\n    # Description\n    ans_desc = ans_md.get(\"description\") if ans_md else None\n    if not ans_desc or normalize(ans_desc) != normalize(item_md[\"description\"]):\n        return {\"result\": \"others\"}\n    # Rarity\n    ans_rarity = ans_md.get(\"rarity\") if ans_md else None\n    if not ans_rarity or normalize(ans_rarity) != normalize(item_md[\"rarity\"]):\n        return {\"result\": \"others\"}\n    # Set Name\n    ans_set = ans_md.get(\"set_name\") if ans_md else None\n    if not ans_set or normalize(ans_set) != normalize(item_md[\"set_name\"]):\n        return {\"result\": \"others\"}\n    # Variants\n    ans_variants = ans_md.get(\"variants\") if ans_md else None\n    if not ans_variants or not isinstance(ans_variants, list):\n        return {\"result\": \"others\"}\n    # Compare variant names (case insensitive, as set)\n    db_variants_set = set([normalize(v[\"name\"]) for v in item_md[\"variants\"]])\n    ans_variants_set = set([normalize(v[\"name\"] if isinstance(v, dict) and \"name\" in v else v) for v in ans_variants])\n    if db_variants_set != ans_variants_set:\n        return {\"result\": \"others\"}\n    # Images\n    ans_images = ans_md.get(\"images\") if ans_md else None\n    if not ans_images or not isinstance(ans_images, dict):\n        return {\"result\": \"others\"}\n    for img_type in [\"icon\", \"featured\", \"background\"]:\n        db_url = item_md[\"images\"].get(img_type)\n        ans_url = ans_images.get(img_type)\n        if not db_url or not ans_url or normalize(db_url) != normalize(ans_url):\n            return {\"result\": \"others\"}\n\n    # Structured object format: Must be a top-level dict containing all keys (not just a flat string)\n    required_keys = {\"description\", \"rarity\", \"set_name\", \"variants\", \"images\"}\n    if not isinstance(ans_md, dict):\n        return {\"result\": \"others\"}\n    for k in required_keys:\n        if k not in ans_md:\n            return {\"result\": \"others\"}\n\n    return {\"result\": \"complete\"}\n", "raw_response": "{\n    \"reasoning\": \"To verify the user task, we must ensure the agent fetched the full preview metadata for the 'Crimson Strike' offer and returned it as a structured object. The required fields are description, rarity, set name, included styles/variants, and image URLs. The verification must check (1) that the final_answer contains *all* required fields for 'Crimson Strike', in structured form (dict/object), (2) that the values exactly match those in the database. Task completion is deterministically confirmed only if no field is missing or incorrect.\",\n    \"verification_strategy\": \"query_based\",\n    \"key_checks\": [\n        \"Extract required fields (description, rarity, set_name, variants/styles, image URLs) from final_answer in a structured way\",\n        \"Cross-check that all extracted metadata matches exactly the database records for the item 'Crimson Strike'\",\n        \"Verify that the answer format is structured (dict/JSON-like) and not partial or ambiguous\",\n        \"Handle cases where final_answer is missing, incomplete, not structured, or not matching\"\n    ],\n    \"python_code\": \"def verify_task_completion(initial_db_path: str, final_db_path: str, final_answer: str | None = None) -> dict:\\n    import sqlite3\\n    import re\\n    import json\\n\\n    # Helper: normalize strings for comparison\\n    def normalize(s):\\n        return s.strip().lower() if isinstance(s, str) else s\\n\\n    # Helper: Query DB safely\\n    def safe_query(db_path, query, params=()):\\n        try:\\n            conn = sqlite3.connect(f\\\"file:{db_path}?mode=ro\\\", uri=True)\\n            cur = conn.cursor()\\n            cur.execute(query, params)\\n            rows = cur.fetchall()\\n            conn.close()\\n            return rows\\n        except Exception:\\n            return []\\n\\n    # Step 1: Get Crimson Strike metadata from DB\\n    item_row = safe_query(final_db_path, \\\"SELECT id, description, rarity, set_name FROM items WHERE name=?\\\", (\\\"Crimson Strike\\\",))\\n    if not item_row or len(item_row[0]) < 4:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    item_id, db_description, db_rarity, db_set_name = item_row[0][0], item_row[0][1], item_row[0][2], item_row[0][3]\\n    if not item_id:\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Variants/styles\\n    variants = safe_query(final_db_path, \\\"SELECT variant_name, variant_type FROM item_variants WHERE item_id=? ORDER BY sort_order ASC\\\", (item_id,))\\n    db_variants = []\\n    for v in variants:\\n        name, vtype = v[0], v[1] if v[1] else None\\n        db_variants.append({\\\"name\\\": name, \\\"type\\\": vtype})\\n\\n    # Images\\n    images = safe_query(final_db_path, \\\"SELECT image_type, url FROM item_images WHERE item_id=? ORDER BY sort_order ASC\\\", (item_id,))\\n    db_images = {}\\n    for t, url in images:\\n        db_images[t] = url\\n\\n    item_md = {\\n        \\\"description\\\": db_description,\\n        \\\"rarity\\\": db_rarity,\\n        \\\"set_name\\\": db_set_name,\\n        \\\"variants\\\": db_variants,\\n        \\\"images\\\": db_images\\n    }\\n\\n    # Step 2: Parse agent answer for structured metadata\\n    if not final_answer or not isinstance(final_answer, str) or not final_answer.strip():\\n        return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Try to parse JSON/dict from final_answer\\n    ans_md = None\\n    try:\\n        # Replace single quotes with double quotes safely for JSON parsing\\n        cleaned = final_answer.strip()\\n        if cleaned.startswith('{') and cleaned.endswith('}'):  # Likely JSON-like\\n            # Avoid reckless replacements\\n            try:\\n                ans_md = json.loads(cleaned)\\n            except:\\n                # Try to parse after changing single quotes to double quotes\\n                cleaned = re.sub(r\\\"'(.*?)'\\\", r'\\\"\\\\1\\\"', cleaned)\\n                try:\\n                    ans_md = json.loads(cleaned)\\n                except:\\n                    ans_md = None\\n    except Exception:\\n        ans_md = None\\n\\n    # If not parseable, try regex extraction for all fields\\n    if ans_md is None:\\n        fields = {}\\n        # Description\\n        m = re.search(r\\\"description\\\\s*[:=]\\\\s*['\\\\\\\"]?(.*?)[\\\\n,}]\\\", final_answer, re.IGNORECASE)\\n        if m:\\n            fields['description'] = m.group(1).strip()\\n        # Rarity\\n        m = re.search(r\\\"rarity\\\\s*[:=]\\\\s*['\\\\\\\"]?(\\\\w+)\\\", final_answer, re.IGNORECASE)\\n        if m:\\n            fields['rarity'] = m.group(1).strip()\\n        # Set Name\\n        m = re.search(r\\\"set[_\\\\s]?name\\\\s*[:=]\\\\s*['\\\\\\\"]?(.*?)[\\\\n,}]\\\", final_answer, re.IGNORECASE)\\n        if m:\\n            fields['set_name'] = m.group(1).strip()\\n        # Variants/styles (try to extract as list)\\n        # Look for key \\\"variants\\\", \\\"styles\\\", or something similar\\n        m = re.search(r\\\"(?:variants|styles|included variants|included styles)\\\\s*[:=]\\\\s*\\\\[([\\\\s\\\\S]*?)\\\\]\\\", final_answer, re.IGNORECASE)\\n        variants = []\\n        if m:\\n            variants_raw = m.group(1)\\n            variants = re.findall(r\\\"['\\\\\\\"]?(.*?)[,'\\\\\\\"]\\\", variants_raw)\\n        else:\\n            # Try individual lines\\n            variants = re.findall(r\\\"-\\\\s*([A-Za-z0-9 \\\\-']+)\\\", final_answer)\\n        fields['variants'] = [v.strip() for v in variants if v.strip()]\\n        # Image URLs\\n        images = {}\\n        for img_type in ['icon', 'featured', 'background']:\\n            m = re.search(rf\\\"{img_type}.*?url\\\\s*[:=]\\\\s*['\\\\\\\"](https?://[\\\\w./\\\\-]+)\\\", final_answer, re.IGNORECASE)\\n            if m:\\n                images[img_type] = m.group(1)\\n            else:\\n                # Try loose capture\\n                m = re.search(rf\\\"{img_type}.*?(https?://[\\\\w./\\\\-]+)\\\", final_answer, re.IGNORECASE)\\n                if m:\\n                    images[img_type] = m.group(1)\\n        fields['images'] = images\\n        ans_md = fields\\n\\n    # Step 3: Validate ALL fields are present and correct\\n    # Description\\n    ans_desc = ans_md.get(\\\"description\\\") if ans_md else None\\n    if not ans_desc or normalize(ans_desc) != normalize(item_md[\\\"description\\\"]):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Rarity\\n    ans_rarity = ans_md.get(\\\"rarity\\\") if ans_md else None\\n    if not ans_rarity or normalize(ans_rarity) != normalize(item_md[\\\"rarity\\\"]):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Set Name\\n    ans_set = ans_md.get(\\\"set_name\\\") if ans_md else None\\n    if not ans_set or normalize(ans_set) != normalize(item_md[\\\"set_name\\\"]):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Variants\\n    ans_variants = ans_md.get(\\\"variants\\\") if ans_md else None\\n    if not ans_variants or not isinstance(ans_variants, list):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Compare variant names (case insensitive, as set)\\n    db_variants_set = set([normalize(v[\\\"name\\\"]) for v in item_md[\\\"variants\\\"]])\\n    ans_variants_set = set([normalize(v[\\\"name\\\"] if isinstance(v, dict) and \\\"name\\\" in v else v) for v in ans_variants])\\n    if db_variants_set != ans_variants_set:\\n        return {\\\"result\\\": \\\"others\\\"}\\n    # Images\\n    ans_images = ans_md.get(\\\"images\\\") if ans_md else None\\n    if not ans_images or not isinstance(ans_images, dict):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    for img_type in [\\\"icon\\\", \\\"featured\\\", \\\"background\\\"]:\\n        db_url = item_md[\\\"images\\\"].get(img_type)\\n        ans_url = ans_images.get(img_type)\\n        if not db_url or not ans_url or normalize(db_url) != normalize(ans_url):\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    # Structured object format: Must be a top-level dict containing all keys (not just a flat string)\\n    required_keys = {\\\"description\\\", \\\"rarity\\\", \\\"set_name\\\", \\\"variants\\\", \\\"images\\\"}\\n    if not isinstance(ans_md, dict):\\n        return {\\\"result\\\": \\\"others\\\"}\\n    for k in required_keys:\\n        if k not in ans_md:\\n            return {\\\"result\\\": \\\"others\\\"}\\n\\n    return {\\\"result\\\": \\\"complete\\\"}\\n\",\n    \"function_name\": \"verify_task_completion\"\n}"}}
